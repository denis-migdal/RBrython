{"version":3,"file":"libs/Runner/index.js","mappings":"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","sources":["webpack://rbrython/./src/rbry/corelib-aot/int.js","webpack://rbrython/./src/rbry/corelib-aot/bool.js","webpack://rbrython/./src/rbry/corelib-aot/str.js","webpack://rbrython/./src/rbry/corelib-aot/float.js","webpack://rbrython/webpack/bootstrap","webpack://rbrython/webpack/runtime/define property getters","webpack://rbrython/webpack/runtime/hasOwnProperty shorthand","webpack://rbrython/./src/rbry/runlib/tmp_corelib/type.ts","webpack://rbrython/./src/rbry/runlib/helpers/getClass.ts","webpack://rbrython/./src/rbry/runlib/tmp_corelib/NotImplemented.ts","webpack://rbrython/./src/rbry/runlib/interface/op.ts","webpack://rbrython/./src/rbry/runlib/interface/KW.ts","webpack://rbrython/./src/rbry/runlib/index.ts","webpack://rbrython/./src/rbry/runlib/interface/uop.ts","webpack://rbrython/./src/rbry/runlib/interface/call.ts","webpack://rbrython/./src/rbry/runlib/helpers/isClass.ts","webpack://rbrython/./src/rbry/runlib/interface/mcall.ts","webpack://rbrython/./src/rbry/runlib/interface/assert.ts","webpack://rbrython/./src/rbry/runlib/interface/attr.ts","webpack://rbrython/./src/rbry/runlib/interface/setattr.ts","webpack://rbrython/./src/rbry/runlib/interface/getModule.ts","webpack://rbrython/./src/rbry/runners/interface.ts","webpack://rbrython/./src/rbry/runners/RBrythonGlobalRunner.ts","webpack://rbrython/./src/libs/Runner/index.ts"],"sourcesContent":["export default \";\\n;\\nvar int = (() =>{\\n        function int() {\\n            return Object.create(int.prototype);\\n        }\\n    int.prototype.__new__ = function __new__(o, base, ){const cls = this;\\n        if( $RB.op($RB.call(type, o, ), \\\"eq\\\", str) ) {\\n        return (\\n\\n                    (x, base) => {\\n\\n                        if( base !== 16)\\n\\n                            return BigInt(x);\\n\\n                        \\n\\n                        let result = 0n;\\n\\n                        for(let i = 2; i < x.length; ++i)\\n\\n                            result = result << 4n + BigInt( parseInt(this.slice(i, i+8), 16) );\\n\\n                        return result;\\n\\n                    }\\n\\n                )(o,base);\\n\\n    };\\nreturn $RB.mcall($RB.call(type, o, ), \\\"__int__\\\", o,  );\\n\\n    };\\nint.prototype.__eq__ = function __eq__(o, ){const self = this;\\n        return self == o;\\n\\n    };\\nint.prototype.__add__ = function __add__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return self + o;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__radd__ = function __radd__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return o + self;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__sub__ = function __sub__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return self - o;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__rsub__ = function __rsub__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return o - self;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__mul__ = function __mul__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return self * o;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__rmul__ = function __rmul__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return o * self;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__pow__ = function __pow__(o, mod, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return self ** o;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__rpow__ = function __rpow__(o, mod, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return o ** self;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__div__ = function __div__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return $RB.call(__JS_AS_NUMBER__, self, ) / $RB.call(__JS_AS_NUMBER__, o, );\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__rdiv__ = function __rdiv__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return $RB.call(__JS_AS_NUMBER__, o, ) * $RB.call(__JS_AS_NUMBER__, self, );\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__mod__ = function __mod__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return self % o;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__rmod__ = function __rmod__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return self % o;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__or__ = function __or__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return self | o;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__ror__ = function __ror__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return self | o;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__and__ = function __and__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return self & o;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__rand__ = function __rand__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return self & o;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__xor__ = function __xor__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return self ^ o;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__rxor__ = function __rxor__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return self ^ o;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__lshift__ = function __lshift__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return self << o;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__rlshift__ = function __rlshift__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return self << o;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__rshift__ = function __rshift__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return self >> o;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__rrshift__ = function __rrshift__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return self >> o;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nint.prototype.__invert__ = function __invert__(){const self = this;\\n        return ~self;\\n\\n    };\\nint.prototype.__neg__ = function __neg__(){const self = this;\\n        return -self;\\n\\n    };\\nint.prototype.__abs__ = function __abs__(){const self = this;\\n        return (x => x < 0n ? -x : x)(self);\\n\\n    };\\n\\n        return int;\\n    })();\\n    ;\\n\\nconst __exported__ = {int}\";","export default \";\\nvar bool = (() =>{\\n        function bool() {\\n            return Object.create(bool.prototype);\\n        }\\n    bool.prototype.__eq__ = function __eq__(o, ){const self = this;\\n        return self == o;\\n\\n    };\\n\\n        return bool;\\n    })();\\n    ;\\n\\nconst __exported__ = {bool}\";","export default \";\\n;\\nvar str = (() =>{\\n        function str() {\\n            return Object.create(str.prototype);\\n        }\\n    str.prototype.__new__ = function __new__(o, ){const cls = this;\\n        return $RB.call(__JS_AS_STRING__, o, );\\n\\n    };\\nstr.prototype.__eq__ = function __eq__(o, ){const self = this;\\n        return self == o;\\n\\n    };\\nstr.prototype.__mul__ = function __mul__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return self.repeat(Number(b));\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nstr.prototype.__rmul__ = function __rmul__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"int\\\") {\\n            return self.repeat(Number(b));\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\n\\n        return str;\\n    })();\\n    ;\\n\\nconst __exported__ = {str}\";","export default \";\\n;\\nvar float = (() =>{\\n        function float() {\\n            return Object.create(float.prototype);\\n        }\\n    float.prototype.__new__ = function __new__(o, ){const cls = this;\\n        if( $RB.call(type, o, ) === str ) {\\n        return $RB.call(__JS_AS_NUMBER__, o, );\\n\\n    };\\nreturn $RB.mcall($RB.call(type, o, ), \\\"__float__\\\", o,  );\\n\\n    };\\nfloat.prototype.__eq__ = function __eq__(o, ){const self = this;\\n        return self == o;\\n\\n    };\\nfloat.prototype.__add__ = function __add__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"float\\\") {\\n            return self + o;\\n\\n        }else if( tname === \\\"int\\\") {\\n            return self + $RB.call(__JS_AS_NUMBER__, o, );\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nfloat.prototype.__radd__ = function __radd__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"float\\\") {\\n            return o + self;\\n\\n        }else if( tname === \\\"int\\\") {\\n            return $RB.call(__JS_AS_NUMBER__, o, ) + self;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nfloat.prototype.__sub__ = function __sub__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"float\\\") {\\n            return self - o;\\n\\n        }else if( tname === \\\"int\\\") {\\n            return self - $RB.call(__JS_AS_NUMBER__, o, );\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nfloat.prototype.__rsub__ = function __rsub__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"float\\\") {\\n            return o - self;\\n\\n        }else if( tname === \\\"int\\\") {\\n            return $RB.call(__JS_AS_NUMBER__, o, ) - self;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nfloat.prototype.__mul__ = function __mul__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"float\\\") {\\n            return self * o;\\n\\n        }else if( tname === \\\"int\\\") {\\n            return self * $RB.call(__JS_AS_NUMBER__, o, );\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nfloat.prototype.__rmul__ = function __rmul__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"float\\\") {\\n            return o * self;\\n\\n        }else if( tname === \\\"int\\\") {\\n            return $RB.call(__JS_AS_NUMBER__, o, ) * self;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nfloat.prototype.__div__ = function __div__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"float\\\") {\\n            return self / o;\\n\\n        }else if( tname === \\\"int\\\") {\\n            return self / $RB.call(__JS_AS_NUMBER__, o, );\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nfloat.prototype.__rdiv__ = function __rdiv__(o, ){const self = this;\\n        {const tname = type(o).name;if( tname === \\\"float\\\") {\\n            return o / self;\\n\\n        }else if( tname === \\\"int\\\") {\\n            return $RB.call(__JS_AS_NUMBER__, o, ) / self;\\n\\n        }else {\\n            return NotImplemented;\\n\\n    }};\\n\\n    };\\nfloat.prototype.__neg__ = function __neg__(){const self = this;\\n        return -self;\\n\\n    };\\nfloat.prototype.__int__ = function __int__(){const self = this;\\n        return ((x) => Math.trunc(x))(self);\\n\\n    };\\nfloat.prototype.__abs__ = function __abs__(){const self = this;\\n        return ((x) => Math.abs(x))(self);\\n\\n    };\\n\\n        return float;\\n    })();\\n    ;\\n\\nconst __exported__ = {float}\";","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export class type {\n    //TODO...\n    __call__(...args: any[]) {\n\n        // @ts-ignore\n        const factory = this.prototype.__new__;\n        const self = factory !== undefined\n                        ? factory.call(this, ...args)\n                        // @ts-ignore\n                        : new this(...args);\n        // @ts-ignore\n        const init = this.prototype.__init__;\n        if( init !== undefined)\n            init.call(self, ...args);\n        \n        return self\n    }\n    __eq__(b: unknown) {\n        return this == b;\n    }\n}","import { type } from \"../tmp_corelib/type\";\n\nconst mapper = {\n    \"bigint\" : \"int\",\n    \"number\" : \"float\",\n    \"string\" : \"str\",\n    \"boolean\": \"bool\"\n}\n\nexport function getClass(o: unknown) {\n\n    const typename = typeof o;\n\n    if( typename === \"function\" ) {\n        //TODO: is class ? is something else ?\n        return type;\n    }\n\n    if( typename === \"object\" ) {\n        // @ts-ignore;\n        return o.constructor;\n    }\n\n    // @ts-ignore\n    const lit_class = globalThis[mapper[typename]];\n    if( lit_class !== undefined)\n        return lit_class;\n\n    throw new Error(`JS type ${typename} not implemented yet`);\n}","//TODO...\nexport const NotImplemented = Symbol();","import { getClass } from \"../helpers/getClass\";\nimport { NotImplemented } from \"../tmp_corelib/NotImplemented\";\n\nexport default function op(a: unknown, op: string, b: unknown) {\n    const ka = getClass(a);\n\n    if( ka === undefined ) {\n        console.warn(a, op);\n        throw new Error(\"?\")\n    }\n\n    let fct = ka.prototype[`__${op}__`];\n\n    if( fct === undefined ) {\n        if( op === \"ne\" )\n            return ! ka.prototype[\"__eq__\"].call(a, b);\n        if( op[0] === \"i\")\n            fct = ka.prototype[`__${op.slice(1)}__`];\n        if( fct === undefined)\n            fct = defaults[op as keyof typeof defaults];\n    }\n    \n    let result = fct.call(a, b);\n\n    if( result === NotImplemented) {\n\n        const kb = getClass(b);\n        if( kb === undefined ) {\n            console.warn(b, \"r\" + op);\n            throw new Error(\"?\");\n        }\n\n        let fct = kb.prototype[`__r${op}__`];\n        result = fct.call(b, a);\n    }\n\n    return result;\n}\n\n//TODO: move to corelib ?\nconst defaults = {\n    eq: function(b: unknown) { return this == b }\n}","export let KW: Record<string, any>|null = null;\n\nexport const IGNORE_ARG = Symbol();\n\nexport function setKW(args: Record<string, any>) {\n    KW = args;\n    return IGNORE_ARG;\n}\n\nexport function getKW() {\n    if( KW === null )\n        return {};\n    const args = KW;\n    KW = null;\n    return args;\n}","// interface\nimport op     from \"./interface/op\";\nimport uop    from \"./interface/uop\";\nimport call   from \"./interface/call\";\nimport mcall  from \"./interface/mcall\";\nimport assert from \"./interface/assert\";\nimport attr   from \"./interface/attr\";\nimport setattr from \"./interface/setattr\";\nimport getModule from \"./interface/getModule\";\nimport { getKW, setKW } from \"./interface/KW\";\n\n// @ts-ignore\nglobalThis.$RB = {\n    // interface\n    op,\n    uop,\n    call,\n    mcall,\n    assert,\n    attr,\n    setattr,\n    getKW,\n    setKW,\n    getModule\n}\n\n//TODO: corelib\nimport {NotImplemented} from \"./tmp_corelib/NotImplemented\";\nimport { getClass } from \"./helpers/getClass\";\n\n// @ts-ignore\nglobalThis.abs = function( a: unknown) {\n    const ka = getClass(a);\n    return ka.prototype[`__abs__`].call(a);\n}\n\n// @ts-ignore\nglobalThis.type = function(a: unknown) {\n    return getClass(a); //TODO...\n}\n\n// @ts-ignore\nglobalThis.NotImplemented = NotImplemented;\n\n// @ts-ignore\nglobalThis.range = function*(a: number) {\n    for(let i = 0; i < a; ++i)\n        yield i;\n}\n\n// @ts-ignore\nglobalThis.Exception = function(msg: string) {\n    throw new Error(msg);\n}\n\n// =====================================================\n\n//TODO: as macro...\nexport const IVALUE = Symbol();\n\n// @ts-ignore\nglobalThis.__JS_SET_IVALUE__ = (self, v) => self[IVALUE] = v;\n// @ts-ignore\nglobalThis.__JS_GET_IVALUE__ = (self) => self[IVALUE];","import { getClass } from \"../helpers/getClass\";\n\nexport default function uop(op:string, a: unknown) {\n\n    if( op === \"not\") {\n        // @ts-ignore\n        return ! a;\n    }\n\n    const ka = getClass(a);\n\n    if( ka === undefined ) {\n        console.warn(a, op);\n        throw new Error(\"?\")\n    }\n\n    let fct = ka.prototype[`__${op}__`];\n    return fct.call(a);\n}","import { getClass } from \"../helpers/getClass\";\nimport isClass from \"../helpers/isClass\";\nimport { IGNORE_ARG } from \"./KW\";\n\nexport default function call(a: (...args:unknown[]) => unknown, ...args: unknown[]) {\n\n    if( args[args.length-1] === IGNORE_ARG)\n        args = args.slice(0,-1);\n\n    // @ts-ignore\n    let fct = a.__call__\n\n    if( fct === undefined ) {\n        fct = a;\n\n        // h4cky\n        if( fct.prototype?.__new__ !== undefined ) {\n            const b = getClass(fct).prototype.__call__;\n            if( b !== undefined) {\n                return b.call(fct, ...args);\n            }\n        }\n\n        if( isClass(fct) ) // only for JS classes now...\n            return new fct(...args);\n    }\n\n    return fct(...args);\n}\n","export default function isClass(o: unknown) {\n    // from https://stackoverflow.com/questions/526559/testing-if-something-is-a-class-in-javascript\n    return Object.getOwnPropertyDescriptors(o)?.prototype?.writable === false;\n}\n// + https://github.com/brython-dev/brython/issues/2513","import { IGNORE_ARG } from \"./KW\";\n\nexport default function mcall(o: unknown, name: string, ...args: unknown[]) {\n    \n    if( args[args.length-1] === IGNORE_ARG)\n        args = args.slice(0,-1);\n    \n    // @ts-ignore\n    let fct = o[name];\n    if( fct === undefined)\n        // @ts-ignore\n        return o.prototype[name].call(...args);\n\n    // @ts-ignore\n    return o[name](...args);\n}","export default function assert(cond: boolean) {\n    if( ! cond )\n        throw new Error(`Assertion failed`);\n}","export default function attr(o: any, attr: string) {\n    if( ! (attr in o) )\n        return o.constructor[attr];\n    return o[attr];\n}","export default function setattr(obj: object, key: string, value:unknown) {\n    // @ts-ignore\n    return obj[key] = value;\n}","import { modules } from \"@RBrython/rbry/runners/RBrythonGlobalRunner\";\n\nexport default function getModule(name: string) {\n\n    // h4ck\n    const module = modules[name];\n    if( module === undefined )\n        throw new Error(`module ${name} not found`);\n\n    return module;\n}\n    ","export type PyModule = Record<string, any>;\n\nexport default abstract class Runner {\n    \n    abstract registerBuiltins(symbols: PyModule): void;\n    abstract registerBuiltin(name: string, value: any): void;\n\n    abstract registerModule(name: string, symbols: PyModule): void;\n    abstract      getModule(name: string): PyModule;\n\n    // low level\n    abstract loadAsFunction(jscode: string): () => PyModule;\n}","import \"@RBrython/rbry/runlib\";\n\nimport Runner, { PyModule } from \"./interface\";\n\nexport const modules: Record<string, any> = {};\n\nexport default class RBrythonGlobalRunner extends Runner {\n\n    #module   = modules; // h4ck\n    #builtins: Record<string, any> = {};\n\n    override loadAsFunction(jscode: string): () => PyModule {\n        return Function(\"'use strict';\" + jscode + \"; return __exported__;\") as () => PyModule;\n    }\n\n    // modules\n    override registerModule(name: string, symbols: PyModule): void {\n        this.#module[name] = symbols;\n    }\n    override getModule(name: string): PyModule {\n        return this.#module[name];\n    } \n\n    // builtins\n    override registerBuiltins(symbols: PyModule): void {\n        for(let name in symbols)\n            this.registerBuiltin(name, symbols[name]);\n    }\n    override registerBuiltin(name: string, value: any): void {\n        this.#builtins[name] = value;\n\n        // @ts-ignore\n        globalThis[name] = value;\n    }\n\n    /*\n    // helpers\n    override registerHelpers(helpers: Record<string, any>) {\n        for(let name in helpers)\n            this.registerHelper(name, helpers[name]);\n    }\n    override registerHelper(name: string, value: any) {\n        \n    }*/\n}","import Runner from \"@RBrython/rbry/runners/RBrythonGlobalRunner\";\n\nconst runner = new Runner();\n\nrunner.registerModule(\"JS\", globalThis);\n\nconst builtins = [\n    require(\"!!raw-loader!@RBrython/rbry/corelib-aot/bool.js\").default,\n    require(\"!!raw-loader!@RBrython/rbry/corelib-aot/float.js\").default,\n    require(\"!!raw-loader!@RBrython/rbry/corelib-aot/int.js\").default,\n    require(\"!!raw-loader!@RBrython/rbry/corelib-aot/str.js\").default\n]\n\nfor(let builtin of builtins)\n    runner.registerBuiltins( runner.loadAsFunction( builtin ) );\n\nexport default runner;"],"names":["__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","type","__call__","args","factory","this","__new__","self","init","__init__","__eq__","b","mapper","getClass","typename","constructor","lit_class","globalThis","Error","NotImplemented","Symbol","defaults","eq","KW","IGNORE_ARG","$RB","op","a","ka","console","warn","fct","slice","result","kb","uop","length","getOwnPropertyDescriptors","writable","mcall","name","assert","cond","attr","setattr","value","getKW","setKW","getModule","modules","abs","range","i","Exception","msg","IVALUE","__JS_SET_IVALUE__","v","__JS_GET_IVALUE__","Runner","runner","loadAsFunction","jscode","Function","registerModule","symbols","registerBuiltins","registerBuiltin","builtins","require","builtin"],"sourceRoot":""}