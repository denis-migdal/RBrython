var __webpack_modules__={178:(n,t,e)=>{e.d(t,{A:()=>_});const _=';\n;\nvar int = (() =>{\n        function int() {\n            return Object.create(int.prototype);\n        }\n    int.prototype.__new__ = function __new__(o, base, ){const cls = this;\n        if( $RB.op($RB.call(type, o, ), "eq", str) ) {\n        return (\n\n                    (x, base) => {\n\n                        if( base !== 16)\n\n                            return BigInt(x);\n\n                        \n\n                        let result = 0n;\n\n                        for(let i = 2; i < x.length; ++i)\n\n                            result = result << 4n + BigInt( parseInt(this.slice(i, i+8), 16) );\n\n                        return result;\n\n                    }\n\n                )(o,base);\n\n    };\nreturn $RB.mcall($RB.call(type, o, ), "__int__", o,  );\n\n    };\nint.prototype.__eq__ = function __eq__(o, ){const self = this;\n        return self == o;\n\n    };\nint.prototype.__add__ = function __add__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self + o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__radd__ = function __radd__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return o + self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__sub__ = function __sub__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self - o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rsub__ = function __rsub__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return o - self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__mul__ = function __mul__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self * o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rmul__ = function __rmul__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return o * self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__pow__ = function __pow__(o, mod, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self ** o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rpow__ = function __rpow__(o, mod, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return o ** self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__div__ = function __div__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return Number(self) / Number(o);\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rdiv__ = function __rdiv__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return Number(o) * Number(self);\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__mod__ = function __mod__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self % o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rmod__ = function __rmod__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self % o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__or__ = function __or__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self | o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__ror__ = function __ror__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self | o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__and__ = function __and__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self & o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rand__ = function __rand__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self & o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__xor__ = function __xor__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self ^ o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rxor__ = function __rxor__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self ^ o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__lshift__ = function __lshift__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self << o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rlshift__ = function __rlshift__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self << o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rshift__ = function __rshift__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self >> o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rrshift__ = function __rrshift__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self >> o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__invert__ = function __invert__(){const self = this;\n        return ~self;\n\n    };\nint.prototype.__neg__ = function __neg__(){const self = this;\n        return -self;\n\n    };\nint.prototype.__abs__ = function __abs__(){const self = this;\n        return (x => x < 0n ? -x : x)(self);\n\n    };\n\n        return int;\n    })();\n    ;\n\nconst __exported__ = {int}'},2312:(n,t,e)=>{e.d(t,{A:()=>_});class _{}},6586:(n,t,e)=>{e.d(t,{t:()=>c});const _={bigint:"int",number:"float",string:"str",boolean:"bool"};function o(n){const t=typeof n;if("function"===t)return type;if("object"===t)return n.constructor;const e=globalThis[_[t]];if(void 0!==e)return e;throw new Error(`JS type ${t} not implemented yet`)}const r=globalThis.NotImplemented=Symbol(),s={lt:"gt",gt:"lt",le:"ge",ge:"le",ne:"ne",eq:"eq"};let i=null;const l=Symbol();var u=e(8958);let a=null;const c=globalThis.$RB={op:function(n,t,e){const _=o(n);if(void 0===_)throw console.warn(n,t),new Error("?");let i=r,l=_.prototype[`__${t}__`];if(void 0!==l&&(i=l.call(n,e)),i!==r)return i;if("i"===t[0]&&(t=t.slice(1),l=_.prototype[`__${t}__`],void 0!==l&&(i=l.call(n,e)),i!==r))return i;const u=o(e);if(void 0===u)throw console.warn(e,"r"+t),new Error("?");let a;if(a=2==t.length&&"or"!==t?s[t]:`r${t}`,l=u.prototype[`__${a}__`],void 0!==l&&(i=l.call(e,n)),i!==r)return i;if("eq"===t)return n===e;if("ne"===t)return n!==e;throw new Error(`Operation not implemented ${_.name} ${t} ${u.name}`)},uop:function(n,t){const e=o(t);if(void 0===e)throw console.warn(t,n),new Error("?");return e.prototype[`__${n}__`].call(t)},call:function(n,...t){t[t.length-1]===l&&(t=t.slice(0,-1));let e=n.__call__;if(void 0===e){if(e=n,void 0!==e.prototype?.__new__){const n=o(e).prototype.__call__;if(void 0!==n)return n.call(e,...t)}if(_=e,!1===Object.getOwnPropertyDescriptors(_)?.prototype?.writable)return new e(...t)}var _;return e(...t)},mcall:function(n,t,...e){return e[e.length-1]===l&&(e=e.slice(0,-1)),void 0===n[t]?(void 0===n.prototype[t]&&console.warn(n,n.name,t),n.prototype[t].call(...e)):n[t](...e)},assert:function(n,t=""){if(!n)throw new Error(`Assertion failed: ${t}`)},attr:function(n,t){return t in n?n[t]:n.constructor[t]},setattr:function(n,t,e){return n[t]=e},getKW:function(){if(null===i)return{};const n=i;return i=null,n},setKW:function(n){return i=n,l},tmp:function(){return a},getTmp:function(){const n=a;return a=null,n},saveTmp:function(n){return a=n},withTmp:function(n){return a=null,n},getModule:async function(n){const t=u.a[n];if(void 0!==t)return t;if(n in globalThis)return u.a[n]=globalThis[n];if("__BRYTHON__"in globalThis&&n in __BRYTHON__.imported)return u.a[n]=__BRYTHON__.pyobj2jsob(__BRYTHON__.imported[n]);throw new Error(`module ${n} not found`)},getModuleSync:function(n){const t=u.a[n];if(void 0!==t)return t;if(n in globalThis)return u.a[n]=globalThis[n];if("__BRYTHON__"in globalThis&&n in __BRYTHON__.imported)return u.a[n]=__BRYTHON__.pyobj2jsob(__BRYTHON__.imported[n]);throw new Error(`module ${n} not found`)},getClass:o};globalThis.abs=function(n){return o(n).prototype.__abs__.call(n)},globalThis.range=function*(...n){let t=0n,e=n[0],_=1n;n.length>=2&&(t=n[0],e=n[1],3===n.length&&(_=n[2]));for(let n=t;n<e;n+=_)yield n},globalThis.Exception=function(n){throw new Error(n)};const f=Symbol();globalThis.__JS_SET_IVALUE__=(n,t)=>n[f]=t,globalThis.__JS_GET_IVALUE__=n=>n[f]},7937:(n,t,e)=>{e.d(t,{A:()=>_});const _='function abs(o, ){\n        return $RB.mcall(o, "__abs__",  );\n\n    };\n\nconst __exported__ = {abs}'},8745:(n,t,e)=>{e.d(t,{A:()=>_});const _=";\nvar bool = (() =>{\n        function bool() {\n            return Object.create(bool.prototype);\n        }\n    bool.prototype.__eq__ = function __eq__(o, ){const self = this;\n        return self == o;\n\n    };\n\n        return bool;\n    })();\n    ;\n\nconst __exported__ = {bool}"},8780:(n,t,e)=>{e.d(t,{A:()=>_});const _=';\n;\nvar str = (() =>{\n        function str() {\n            return Object.create(str.prototype);\n        }\n    str.prototype.__new__ = function __new__(o, ){const cls = this;\n        return `${o}`;\n\n    };\nstr.prototype.__eq__ = function __eq__(o, ){const self = this;\n        return self == o;\n\n    };\nstr.prototype.__mul__ = function __mul__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self.repeat(Number(b));\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nstr.prototype.__rmul__ = function __rmul__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self.repeat(Number(b));\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\n\n        return str;\n    })();\n    ;\n\nconst __exported__ = {str}'},8787:(n,t,e)=>{e.d(t,{A:()=>_});const _=';\n;\nvar float = (() =>{\n        function float() {\n            return Object.create(float.prototype);\n        }\n    float.prototype.__new__ = function __new__(o, ){const cls = this;\n        if( $RB.call(type, o, ) === str ) {\n        if( $RB.op(o, "eq", "infinity")||$RB.op(o, "eq", "inf") ) {\n        return Number.POSITIVE_INFINITY;\n\n    };\nif( $RB.op(o, "eq", "-infinity")||$RB.op(o, "eq", "-inf") ) {\n        return Number.NEGATIVE_INFINITY;\n\n    };\nreturn Number(o);\n\n    };\nreturn $RB.mcall($RB.call(type, o, ), "__float__", o,  );\n\n    };\nfloat.prototype.__eq__ = function __eq__(o, ){const self = this;\n        return self == o;\n\n    };\nfloat.prototype.__add__ = function __add__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return self + o;\n\n        }else if( tname === "int") {\n            return self + Number(o);\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__radd__ = function __radd__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return o + self;\n\n        }else if( tname === "int") {\n            return Number(o) + self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__sub__ = function __sub__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return self - o;\n\n        }else if( tname === "int") {\n            return self - Number(o);\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__rsub__ = function __rsub__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return o - self;\n\n        }else if( tname === "int") {\n            return Number(o) - self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__mul__ = function __mul__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return self * o;\n\n        }else if( tname === "int") {\n            return self * Number(o);\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__rmul__ = function __rmul__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return o * self;\n\n        }else if( tname === "int") {\n            return Number(o) * self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__div__ = function __div__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return self / o;\n\n        }else if( tname === "int") {\n            return self / Number(o);\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__rdiv__ = function __rdiv__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return o / self;\n\n        }else if( tname === "int") {\n            return Number(o) / self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__neg__ = function __neg__(){const self = this;\n        return -self;\n\n    };\nfloat.prototype.__int__ = function __int__(){const self = this;\n        return ((x) => Math.trunc(x))(self);\n\n    };\nfloat.prototype.__abs__ = function __abs__(){const self = this;\n        return ((x) => Math.abs(x))(self);\n\n    };\n\n        return float;\n    })();\n    ;\n\nconst __exported__ = {float}'},8958:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>RBrythonGlobalRunner,a:()=>modules});var _RBrython_rbry_runlib__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(6586),_interface__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(2312);const modules={};class RBrythonGlobalRunner extends _interface__WEBPACK_IMPORTED_MODULE_1__.A{#n=modules;#t={};async run(n){return await this.runFunction(this.loadAsFunction(n))}runSync(n){return this.runSyncFunction(this.loadAsSyncFunction(n))}loadAsFunction(jscode){return eval(jscode)}async runFunction(n){return await n(_RBrython_rbry_runlib__WEBPACK_IMPORTED_MODULE_0__.t)}loadAsSyncFunction(jscode){return eval(jscode)}runSyncFunction(n){return n(_RBrython_rbry_runlib__WEBPACK_IMPORTED_MODULE_0__.t)}registerModule(n,t){this.#n[n]=t}getModule(n){return this.#n[n]}registerBuiltins(n){for(let t in n)this.registerBuiltin(t,n[t])}registerBuiltin(n,t){this.#t[n]=t,globalThis[n]=t}}}},__webpack_module_cache__={};function __webpack_require__(n){var t=__webpack_module_cache__[n];if(void 0!==t)return t.exports;var e=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](e,e.exports,__webpack_require__),e.exports}__webpack_require__.d=(n,t)=>{for(var e in t)__webpack_require__.o(t,e)&&!__webpack_require__.o(n,e)&&Object.defineProperty(n,e,{enumerable:!0,get:t[e]})},__webpack_require__.o=(n,t)=>Object.prototype.hasOwnProperty.call(n,t);var __webpack_exports__={};__webpack_require__.d(__webpack_exports__,{A:()=>Runner});var Runner_RBrython_rbry_runners_RBrythonGlobalRunner_WEBPACK_IMPORTED_MODULE_0_=__webpack_require__(8958);const Runner_runner=new Runner_RBrython_rbry_runners_RBrythonGlobalRunner_WEBPACK_IMPORTED_MODULE_0_.A;Runner_runner.registerModule("JS",globalThis);const Runner_builtins=[__webpack_require__(8745).A,__webpack_require__(8787).A,__webpack_require__(178).A,__webpack_require__(8780).A,__webpack_require__(7937).A];for(let n of Runner_builtins)Runner_runner.registerBuiltins(Runner_runner.loadAsFunction(n));const Runner=Runner_runner;var __webpack_exports__default=__webpack_exports__.A;export{__webpack_exports__default as default};
//# sourceMappingURL=index.js.map