var n={178:(n,t,e)=>{e.d(t,{A:()=>o});const o=';\n;\nvar int = (() =>{\n        function int() {\n            return Object.create(int.prototype);\n        }\n    int.prototype.__new__ = function __new__(o, base, ){const cls = this;\n        if( $RB.op($RB.call(type, o, ), "eq", str) ) {\n        return (\n\n                    (x, base) => {\n\n                        if( base !== 16)\n\n                            return BigInt(x);\n\n                        \n\n                        let result = 0n;\n\n                        for(let i = 2; i < x.length; ++i)\n\n                            result = result << 4n + BigInt( parseInt(this.slice(i, i+8), 16) );\n\n                        return result;\n\n                    }\n\n                )(o,base);\n\n    };\nreturn $RB.mcall($RB.call(type, o, ), "__int__", o,  );\n\n    };\nint.prototype.__eq__ = function __eq__(o, ){const self = this;\n        return self == o;\n\n    };\nint.prototype.__add__ = function __add__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self + o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__radd__ = function __radd__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return o + self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__sub__ = function __sub__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self - o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rsub__ = function __rsub__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return o - self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__mul__ = function __mul__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self * o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rmul__ = function __rmul__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return o * self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__pow__ = function __pow__(o, mod, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self ** o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rpow__ = function __rpow__(o, mod, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return o ** self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__div__ = function __div__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return $RB.call(__JS_AS_NUMBER__, self, ) / $RB.call(__JS_AS_NUMBER__, o, );\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rdiv__ = function __rdiv__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return $RB.call(__JS_AS_NUMBER__, o, ) * $RB.call(__JS_AS_NUMBER__, self, );\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__mod__ = function __mod__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self % o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rmod__ = function __rmod__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self % o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__or__ = function __or__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self | o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__ror__ = function __ror__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self | o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__and__ = function __and__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self & o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rand__ = function __rand__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self & o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__xor__ = function __xor__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self ^ o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rxor__ = function __rxor__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self ^ o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__lshift__ = function __lshift__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self << o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rlshift__ = function __rlshift__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self << o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rshift__ = function __rshift__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self >> o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rrshift__ = function __rrshift__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self >> o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__invert__ = function __invert__(){const self = this;\n        return ~self;\n\n    };\nint.prototype.__neg__ = function __neg__(){const self = this;\n        return -self;\n\n    };\nint.prototype.__abs__ = function __abs__(){const self = this;\n        return (x => x < 0n ? -x : x)(self);\n\n    };\n\n        return int;\n    })();\n    ;\n\nconst __exported__ = {int}'},745:(n,t,e)=>{e.d(t,{A:()=>o});const o=";\nvar bool = (() =>{\n        function bool() {\n            return Object.create(bool.prototype);\n        }\n    bool.prototype.__eq__ = function __eq__(o, ){const self = this;\n        return self == o;\n\n    };\n\n        return bool;\n    })();\n    ;\n\nconst __exported__ = {bool}"},780:(n,t,e)=>{e.d(t,{A:()=>o});const o=';\n;\nvar str = (() =>{\n        function str() {\n            return Object.create(str.prototype);\n        }\n    str.prototype.__new__ = function __new__(o, ){const cls = this;\n        return $RB.call(__JS_AS_STRING__, o, );\n\n    };\nstr.prototype.__eq__ = function __eq__(o, ){const self = this;\n        return self == o;\n\n    };\nstr.prototype.__mul__ = function __mul__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self.repeat(Number(b));\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nstr.prototype.__rmul__ = function __rmul__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self.repeat(Number(b));\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\n\n        return str;\n    })();\n    ;\n\nconst __exported__ = {str}'},787:(n,t,e)=>{e.d(t,{A:()=>o});const o=';\n;\nvar float = (() =>{\n        function float() {\n            return Object.create(float.prototype);\n        }\n    float.prototype.__new__ = function __new__(o, ){const cls = this;\n        if( $RB.call(type, o, ) === str ) {\n        return $RB.call(__JS_AS_NUMBER__, o, );\n\n    };\nreturn $RB.mcall($RB.call(type, o, ), "__float__", o,  );\n\n    };\nfloat.prototype.__eq__ = function __eq__(o, ){const self = this;\n        return self == o;\n\n    };\nfloat.prototype.__add__ = function __add__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return self + o;\n\n        }else if( tname === "int") {\n            return self + $RB.call(__JS_AS_NUMBER__, o, );\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__radd__ = function __radd__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return o + self;\n\n        }else if( tname === "int") {\n            return $RB.call(__JS_AS_NUMBER__, o, ) + self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__sub__ = function __sub__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return self - o;\n\n        }else if( tname === "int") {\n            return self - $RB.call(__JS_AS_NUMBER__, o, );\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__rsub__ = function __rsub__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return o - self;\n\n        }else if( tname === "int") {\n            return $RB.call(__JS_AS_NUMBER__, o, ) - self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__mul__ = function __mul__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return self * o;\n\n        }else if( tname === "int") {\n            return self * $RB.call(__JS_AS_NUMBER__, o, );\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__rmul__ = function __rmul__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return o * self;\n\n        }else if( tname === "int") {\n            return $RB.call(__JS_AS_NUMBER__, o, ) * self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__div__ = function __div__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return self / o;\n\n        }else if( tname === "int") {\n            return self / $RB.call(__JS_AS_NUMBER__, o, );\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__rdiv__ = function __rdiv__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return o / self;\n\n        }else if( tname === "int") {\n            return $RB.call(__JS_AS_NUMBER__, o, ) / self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__neg__ = function __neg__(){const self = this;\n        return -self;\n\n    };\nfloat.prototype.__int__ = function __int__(){const self = this;\n        return ((x) => Math.trunc(x))(self);\n\n    };\nfloat.prototype.__abs__ = function __abs__(){const self = this;\n        return ((x) => Math.abs(x))(self);\n\n    };\n\n        return float;\n    })();\n    ;\n\nconst __exported__ = {float}'}},t={};function e(o){var _=t[o];if(void 0!==_)return _.exports;var r=t[o]={exports:{}};return n[o](r,r.exports,e),r.exports}e.d=(n,t)=>{for(var o in t)e.o(t,o)&&!e.o(n,o)&&Object.defineProperty(n,o,{enumerable:!0,get:t[o]})},e.o=(n,t)=>Object.prototype.hasOwnProperty.call(n,t);var o={};e.d(o,{A:()=>y});class _{__call__(...n){const t=this.prototype.__new__,e=void 0!==t?t.call(this,...n):new this(...n),o=this.prototype.__init__;return void 0!==o&&o.call(e,...n),e}__eq__(n){return this==n}}const r={bigint:"int",number:"float",string:"str",boolean:"bool"};function s(n){const t=typeof n;if("function"===t)return _;if("object"===t)return n.constructor;const e=globalThis[r[t]];if(void 0!==e)return e;throw new Error(`JS type ${t} not implemented yet`)}const l=Symbol(),i={eq:function(n){return this==n}};let f=null;const u=Symbol();globalThis.$RB={op:function(n,t,e){const o=s(n);if(void 0===o)throw console.warn(n,t),new Error("?");let _=o.prototype[`__${t}__`];if(void 0===_){if("ne"===t)return!o.prototype.__eq__.call(n,e);"i"===t[0]&&(_=o.prototype[`__${t.slice(1)}__`]),void 0===_&&(_=i[t])}let r=_.call(n,e);if(r===l){const o=s(e);if(void 0===o)throw console.warn(e,"r"+t),new Error("?");r=o.prototype[`__r${t}__`].call(e,n)}return r},uop:function(n,t){if("not"===n)return!t;const e=s(t);if(void 0===e)throw console.warn(t,n),new Error("?");return e.prototype[`__${n}__`].call(t)},call:function(n,...t){t[t.length-1]===u&&(t=t.slice(0,-1));let e=n.__call__;if(void 0===e){if(e=n,void 0!==e.prototype?.__new__){const n=s(e).prototype.__call__;if(void 0!==n)return n.call(e,...t)}if(o=e,!1===Object.getOwnPropertyDescriptors(o)?.prototype?.writable)return new e(...t)}var o;return e(...t)},mcall:function(n,t,...e){return e[e.length-1]===u&&(e=e.slice(0,-1)),void 0===n[t]?n.prototype[t].call(...e):n[t](...e)},assert:function(n){if(!n)throw new Error("Assertion failed")},attr:function(n,t){return t in n?n[t]:n.constructor[t]},setattr:function(n,t,e){return n[t]=e},getKW:function(){if(null===f)return{};const n=f;return f=null,n},setKW:function(n){return f=n,u},getModule:function(n){const t=p[n];if(void 0===t)throw new Error(`module ${n} not found`);return t}},globalThis.abs=function(n){return s(n).prototype.__abs__.call(n)},globalThis.type=function(n){return s(n)},globalThis.NotImplemented=l,globalThis.range=function*(n){for(let t=0;t<n;++t)yield t},globalThis.Exception=function(n){throw new Error(n)};const a=Symbol();globalThis.__JS_SET_IVALUE__=(n,t)=>n[a]=t,globalThis.__JS_GET_IVALUE__=n=>n[a];class c{}const p={},m=new class extends c{#n=p;#t={};loadAsFunction(n){return Function("'use strict';"+n+"; return __exported__;")}registerModule(n,t){this.#n[n]=t}getModule(n){return this.#n[n]}registerBuiltins(n){for(let t in n)this.registerBuiltin(t,n[t])}registerBuiltin(n,t){this.#t[n]=t,globalThis[n]=t}};m.registerModule("JS",globalThis);const d=[e(745).A,e(787).A,e(178).A,e(780).A];for(let n of d)m.registerBuiltins(m.loadAsFunction(n));const y=m;var h=o.A;export{h as default};
//# sourceMappingURL=index.js.map