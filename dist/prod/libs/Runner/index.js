var n={178:(n,t,e)=>{e.d(t,{A:()=>o});const o=';\n;\nvar int = (() =>{\n        function int() {\n            return Object.create(int.prototype);\n        }\n    int.prototype.__new__ = function __new__(o, base, ){const cls = this;\n        if( $RB.op($RB.call(type, o, ), "eq", str) ) {\n        return (\n\n                    (x, base) => {\n\n                        if( base !== 16)\n\n                            return BigInt(x);\n\n                        \n\n                        let result = 0n;\n\n                        for(let i = 2; i < x.length; ++i)\n\n                            result = result << 4n + BigInt( parseInt(this.slice(i, i+8), 16) );\n\n                        return result;\n\n                    }\n\n                )(o,base);\n\n    };\nreturn $RB.mcall($RB.call(type, o, ), "__int__", o,  );\n\n    };\nint.prototype.__eq__ = function __eq__(o, ){const self = this;\n        return self == o;\n\n    };\nint.prototype.__add__ = function __add__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self + o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__radd__ = function __radd__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return o + self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__sub__ = function __sub__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self - o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rsub__ = function __rsub__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return o - self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__mul__ = function __mul__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self * o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rmul__ = function __rmul__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return o * self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__pow__ = function __pow__(o, mod, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self ** o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rpow__ = function __rpow__(o, mod, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return o ** self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__div__ = function __div__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return Number(self) / Number(o);\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rdiv__ = function __rdiv__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return Number(o) * Number(self);\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__mod__ = function __mod__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self % o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rmod__ = function __rmod__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self % o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__or__ = function __or__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self | o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__ror__ = function __ror__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self | o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__and__ = function __and__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self & o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rand__ = function __rand__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self & o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__xor__ = function __xor__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self ^ o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rxor__ = function __rxor__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self ^ o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__lshift__ = function __lshift__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self << o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rlshift__ = function __rlshift__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self << o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rshift__ = function __rshift__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self >> o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__rrshift__ = function __rrshift__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self >> o;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nint.prototype.__invert__ = function __invert__(){const self = this;\n        return ~self;\n\n    };\nint.prototype.__neg__ = function __neg__(){const self = this;\n        return -self;\n\n    };\nint.prototype.__abs__ = function __abs__(){const self = this;\n        return (x => x < 0n ? -x : x)(self);\n\n    };\n\n        return int;\n    })();\n    ;\n\nconst __exported__ = {int}'},7937:(n,t,e)=>{e.d(t,{A:()=>o});const o='function abs(o, ){\n        return $RB.mcall(o, "__abs__",  );\n\n    };\n\nconst __exported__ = {abs}'},8745:(n,t,e)=>{e.d(t,{A:()=>o});const o=";\nvar bool = (() =>{\n        function bool() {\n            return Object.create(bool.prototype);\n        }\n    bool.prototype.__eq__ = function __eq__(o, ){const self = this;\n        return self == o;\n\n    };\n\n        return bool;\n    })();\n    ;\n\nconst __exported__ = {bool}"},8780:(n,t,e)=>{e.d(t,{A:()=>o});const o=';\n;\nvar str = (() =>{\n        function str() {\n            return Object.create(str.prototype);\n        }\n    str.prototype.__new__ = function __new__(o, ){const cls = this;\n        return `${o}`;\n\n    };\nstr.prototype.__eq__ = function __eq__(o, ){const self = this;\n        return self == o;\n\n    };\nstr.prototype.__mul__ = function __mul__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self.repeat(Number(b));\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nstr.prototype.__rmul__ = function __rmul__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "int") {\n            return self.repeat(Number(b));\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\n\n        return str;\n    })();\n    ;\n\nconst __exported__ = {str}'},8787:(n,t,e)=>{e.d(t,{A:()=>o});const o=';\n;\nvar float = (() =>{\n        function float() {\n            return Object.create(float.prototype);\n        }\n    float.prototype.__new__ = function __new__(o, ){const cls = this;\n        if( $RB.call(type, o, ) === str ) {\n        if( $RB.op(o, "eq", "infinity")||$RB.op(o, "eq", "inf") ) {\n        return Number.POSITIVE_INFINITY;\n\n    };\nif( $RB.op(o, "eq", "-infinity")||$RB.op(o, "eq", "-inf") ) {\n        return Number.NEGATIVE_INFINITY;\n\n    };\nreturn Number(o);\n\n    };\nreturn $RB.mcall($RB.call(type, o, ), "__float__", o,  );\n\n    };\nfloat.prototype.__eq__ = function __eq__(o, ){const self = this;\n        return self == o;\n\n    };\nfloat.prototype.__add__ = function __add__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return self + o;\n\n        }else if( tname === "int") {\n            return self + Number(o);\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__radd__ = function __radd__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return o + self;\n\n        }else if( tname === "int") {\n            return Number(o) + self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__sub__ = function __sub__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return self - o;\n\n        }else if( tname === "int") {\n            return self - Number(o);\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__rsub__ = function __rsub__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return o - self;\n\n        }else if( tname === "int") {\n            return Number(o) - self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__mul__ = function __mul__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return self * o;\n\n        }else if( tname === "int") {\n            return self * Number(o);\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__rmul__ = function __rmul__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return o * self;\n\n        }else if( tname === "int") {\n            return Number(o) * self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__div__ = function __div__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return self / o;\n\n        }else if( tname === "int") {\n            return self / Number(o);\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__rdiv__ = function __rdiv__(o, ){const self = this;\n        {const tname = type(o).name;if( tname === "float") {\n            return o / self;\n\n        }else if( tname === "int") {\n            return Number(o) / self;\n\n        }else {\n            return NotImplemented;\n\n    }};\n\n    };\nfloat.prototype.__neg__ = function __neg__(){const self = this;\n        return -self;\n\n    };\nfloat.prototype.__int__ = function __int__(){const self = this;\n        return ((x) => Math.trunc(x))(self);\n\n    };\nfloat.prototype.__abs__ = function __abs__(){const self = this;\n        return ((x) => Math.abs(x))(self);\n\n    };\n\n        return float;\n    })();\n    ;\n\nconst __exported__ = {float}'}},t={};function e(o){var r=t[o];if(void 0!==r)return r.exports;var _=t[o]={exports:{}};return n[o](_,_.exports,e),_.exports}e.d=(n,t)=>{for(var o in t)e.o(t,o)&&!e.o(n,o)&&Object.defineProperty(n,o,{enumerable:!0,get:t[o]})},e.o=(n,t)=>Object.prototype.hasOwnProperty.call(n,t);var o={};e.d(o,{A:()=>h});class r{__call__(...n){console.warn("really called");const t=this.prototype.__new__,e=void 0!==t?t.call(this,...n):new this(...n),o=this.prototype.__init__;return void 0!==o&&o.call(e,...n),e}__eq__(n){return this==n}}const _={bigint:"int",number:"float",string:"str",boolean:"bool"};function s(n){const t=typeof n;if("function"===t)return r;if("object"===t)return n.constructor;const e=globalThis[_[t]];if(void 0!==e)return e;throw new Error(`JS type ${t} not implemented yet`)}const i=globalThis.NotImplemented=Symbol(),l={eq:function(n){return this==n}};let f=null;const u=Symbol(),a={op:function(n,t,e){const o=s(n);if(void 0===o)throw console.warn(n,t),new Error("?");let r=o.prototype[`__${t}__`];if(void 0===r){if("ne"===t)return!o.prototype.__eq__.call(n,e);"i"===t[0]&&(r=o.prototype[`__${t.slice(1)}__`]),void 0===r&&(r=l[t])}let _=r.call(n,e);if(_===i){const o=s(e);if(void 0===o)throw console.warn(e,"r"+t),new Error("?");_=o.prototype[`__r${t}__`].call(e,n)}return _},uop:function(n,t){if("not"===n)return!t;const e=s(t);if(void 0===e)throw console.warn(t,n),new Error("?");return e.prototype[`__${n}__`].call(t)},call:function(n,...t){t[t.length-1]===u&&(t=t.slice(0,-1));let e=n.__call__;if(void 0===e){if(e=n,void 0!==e.prototype?.__new__){const n=s(e).prototype.__call__;if(void 0!==n)return n.call(e,...t)}if(o=e,!1===Object.getOwnPropertyDescriptors(o)?.prototype?.writable)return new e(...t)}var o;return e(...t)},mcall:function(n,t,...e){return e[e.length-1]===u&&(e=e.slice(0,-1)),void 0===n[t]?n.prototype[t].call(...e):n[t](...e)},assert:function(n){if(!n)throw new Error("Assertion failed")},attr:function(n,t){return t in n?n[t]:n.constructor[t]},setattr:function(n,t,e){return n[t]=e},getKW:function(){if(null===f)return{};const n=f;return f=null,n},setKW:function(n){return f=n,u},getModule:function(n){const t=m[n];if(void 0===t)throw new Error(`module ${n} not found`);return t}};globalThis.type=function(n){return s(n)},globalThis.abs=function(n){return s(n).prototype.__abs__.call(n)},globalThis.range=function*(n){for(let t=0;t<n;++t)yield t},globalThis.Exception=function(n){throw new Error(n)};const c=Symbol();globalThis.__JS_SET_IVALUE__=(n,t)=>n[c]=t,globalThis.__JS_GET_IVALUE__=n=>n[c];class p{}globalThis.$RB=a;const m={},d=new class extends p{#n=m;#t={};run(n){return this.runFunction(this.loadAsFunction(n))}loadAsFunction(n){return Function("$RB",n)}runFunction(n){return n(a)}registerModule(n,t){this.#n[n]=t}getModule(n){return this.#n[n]}registerBuiltins(n){for(let t in n)this.registerBuiltin(t,n[t])}registerBuiltin(n,t){this.#t[n]=t,globalThis[n]=t}};d.registerModule("JS",globalThis);const y=[e(8745).A,e(8787).A,e(178).A,e(8780).A,e(7937).A];for(let n of y)d.registerBuiltins(d.loadAsFunction(n));const h=d;var b=o.A;export{b as default};
//# sourceMappingURL=index.js.map