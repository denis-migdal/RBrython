var e={116:(e,n,t)=>{t.d(n,{A:()=>r});const r='from RBM import __JS_OP__, boolean\n\nclass bool(boolean): # type: ignore (bool is Final)\n    def __eq__(self, o: object, /) -> bool:\n        return __JS_OP__(self, "==", o)'},180:(e,n,t)=>{t.d(n,{A:()=>r});const r='from types import NotImplementedType\nfrom RBM import __JS_OP__, __JS_AS_NUMBER__, number\n\nclass float(number):\n    def __new__(cls, o: object, /) -> float:\n        if type(o) is str:\n            return __JS_AS_NUMBER__(o)\n        return type(o).__float__(o) # type: ignore\n    \n    def __eq__(self, o: object, /) -> bool:\n        return __JS_OP__(self, "==", o)    \n\n    def __add__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(self, "+", o)\n            case int  (): return __JS_OP__(self, "+", __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n\n    def __radd__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(o                  , "+", self)\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), "+", self)\n            case _      : return NotImplemented\n\n    def __sub__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(self, "-", o)\n            case int  (): return __JS_OP__(self, "-", __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n\n    def __rsub__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(o                  , "-", self)\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), "-", self)\n            case _      : return NotImplemented\n\n    def __mul__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(self, "*", o)\n            case int  (): return __JS_OP__(self, "*", __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n\n    def __rmul__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(o                  , "*", self)\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), "*", self)\n            case _      : return NotImplemented\n\n    def __div__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(self, "/", o)\n            case int  (): return __JS_OP__(self, "/", __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n\n    def __rdiv__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(o                  , "/", self)\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), "/", self)\n            case _      : return NotImplemented\n\n    ### unary operators ###\n\n    def __neg__(self, /) -> float:\n        return __JS_OP__("-", self)\n    \n    def __int__(self, /) -> int:\n        return __JS_RUN__(\'(x) => Math.trunc(x)\', self) # type: ignore\n    \n    def __abs__(self, /) -> int:\n         return __JS_RUN__(\'(x) => Math.abs(x)\', self) # type: ignore'},541:(e,n,t)=>{t.d(n,{A:()=>r});const r='from types     import NotImplementedType\n\nfrom RBM import __JS_AS_NUMBER__, __JS_OP__, bigint\n\nclass int(bigint):\n\n    def __new__(cls, o: object, base: int, /) -> int:\n        if type(o) == str:\n            return __JS_RUN__( # type: ignore\n                \'\'\'\n                    (x, base) => {\n                        if( base !== 16)\n                            return BigInt(x);\n                        \n                        let result = 0n;\n                        for(let i = 2; i < x.length; ++i)\n                            result = result << 4n + BigInt( parseInt(this.slice(i, i+8), 16) );\n                        return result;\n                    }\n                \'\'\', o, base) # type: ignore\n        return type(o).__int__(o) # type: ignore\n    \n    def __eq__(self, o: object, /) -> bool:\n        return __JS_OP__(self, "==", o)\n\n\n    def __add__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "+", o)\n            case _      : return NotImplemented\n    \n    def __radd__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(o, "+", self)\n            case _      : return NotImplemented\n    \n\n    def __sub__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "-", o)\n            case _      : return NotImplemented\n    \n    def __rsub__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(o, "-", self)\n            case _      : return NotImplemented\n    \n    def __mul__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "*", o)\n            case _      : return NotImplemented\n    \n    def __rmul__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(o, "*", self)\n            case _      : return NotImplemented\n\n    def __pow__(self, o: object, mod: int|None = None, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "**", o)\n            case _      : return NotImplemented\n    \n    def __rpow__(self, o: object, mod: int|None = None, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(o, "**", self)\n            case _      : return NotImplemented\n\n    def __div__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(self),\n                                           "/",\n                                           __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n    \n    def __rdiv__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o),\n                                           "*",\n                                           __JS_AS_NUMBER__(self) )\n            case _      : return NotImplemented\n\n    def __mod__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "%", o)\n            case _      : return NotImplemented\n    \n    def __rmod__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "%", o)\n            case _      : return NotImplemented\n    \n    def __or__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "|", o)\n            case _      : return NotImplemented\n    \n    def __ror__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "|", o)\n            case _      : return NotImplemented\n\n    def __and__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "&", o)\n            case _      : return NotImplemented\n    \n    def __rand__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "&", o)\n            case _      : return NotImplemented\n        \n    def __xor__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "^", o)\n            case _      : return NotImplemented\n    \n    def __rxor__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "^", o)\n            case _      : return NotImplemented\n\n    def __lshift__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "<<", o)\n            case _      : return NotImplemented\n    \n    def __rlshift__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "<<", o)\n            case _      : return NotImplemented\n\n    def __rshift__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, ">>", o)\n            case _      : return NotImplemented\n    \n    def __rrshift__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, ">>", o)\n            case _      : return NotImplemented\n    \n    ### unary operators ###\n    def __invert__(self, /) -> int:\n        return __JS_OP__("~", self)\n\n    def __neg__(self, /) -> int:\n        return __JS_OP__("-", self)\n    \n    def __abs__(self, /) -> int:\n         return __JS_RUN__("x => x < 0n ? -x : x", self) # type: ignore'},711:(e,n,t)=>{t.d(n,{A:()=>r});const r='from types     import NotImplementedType\nfrom RBM import __JS_OP__, string\n\nclass str(string):\n    def __new__(cls, o: object, /) -> str:\n        return __JS_AS_STRING__(o) # type: ignore\n        #return type(o).__str__(o) # type: ignore\n    \n    def __eq__(self, o: object, /) -> bool:\n        return __JS_OP__(self, "==", o)\n\n    def __mul__(self, o: object, /) -> NotImplementedType|str:\n        match o:\n            case int  (): return __JS_WRITE__("self.repeat(Number(b))") # type: ignore\n            case _      : return NotImplemented\n    \n    def __rmul__(self, o: object, /) -> NotImplementedType|str:\n        match o:\n            case int  (): return __JS_WRITE__("self.repeat(Number(b))") # type: ignore\n            case _      : return NotImplemented'}},n={};function t(r){var o=n[r];if(void 0!==o)return o.exports;var _=n[r]={exports:{}};return e[r](_,_.exports,t),_.exports}t.d=(e,n)=>{for(var r in n)t.o(n,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:n[r]})},t.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n);var r={};function o(e){return e.constructor.$name}function _(e){return e.constructor.$name}t.d(r,{A:()=>A});const s={};function l(e,n,...t){const r=s[o(e)];if(void 0===r)throw console.warn(e),new Error(`Node type ${o(e)} is unknown`);return r(e,n,...t)}const i={__JS_OP__:(...e)=>2===e.length?`${e[0].value}${l(e[1])}`:`${l(e[0])} ${e[1].value} ${l(e[2])}`,__JS_RUN__:(...e)=>{return`(${n=e[0].value,n=n.replaceAll("\\n\\","\n")})(${e.slice(1).map((e=>l(e))).join(",")})`;var n},__JS_WRITE__:e=>e.value},a={int:t(541).A,float:t(180).A,bool:t(116).A,str:t(711).A};class u{__call__(...e){const n=this.prototype.__new__,t=void 0!==n?n.call(this,...e):new this(...e),r=this.prototype.__init__;return void 0!==r&&r.call(t,...e),t}__eq__(e){return this==e}}const c={bigint:"int",number:"float",string:"str",boolean:"bool"};function f(e){const n=typeof e;if("function"===n)return u;if("object"===n)return e.constructor;const t=globalThis[c[n]];if(void 0!==t)return t;throw new Error(`JS type ${n} not implemented yet`)}const m=Symbol(),p={eq:function(e){return this==e}};let d=null;const b=Symbol();globalThis.$RB={op:function(e,n,t){const r=f(e);if(void 0===r)throw console.warn(e,n),new Error("?");let o=r.prototype[`__${n}__`];if(void 0===o){if("ne"===n)return!r.prototype.__eq__.call(e,t);"i"===n[0]&&(o=r.prototype[`__${n.slice(1)}__`]),void 0===o&&(o=p[n])}let _=o.call(e,t);if(_===m){const r=f(t);if(void 0===r)throw console.warn(t,"r"+n),new Error("?");_=r.prototype[`__r${n}__`].call(t,e)}return _},uop:function(e,n){if("not"===e)return!n;const t=f(n);if(void 0===t)throw console.warn(n,e),new Error("?");return t.prototype[`__${e}__`].call(n)},call:function(e,...n){n[n.length-1]===b&&(n=n.slice(0,-1));let t=e.__call__;if(void 0===t){if(t=e,void 0!==t.prototype?.__new__){const e=f(t).prototype.__call__;if(void 0!==e)return e.call(t,...n)}if(r=t,!1===Object.getOwnPropertyDescriptors(r)?.prototype?.writable)return new t(...n)}var r;return t(...n)},mcall:function(e,n,...t){return t[t.length-1]===b&&(t=t.slice(0,-1)),void 0===e[n]?e.prototype[n].call(...t):e[n](...t)},assert:function(e){if(!e)throw new Error("Assertion failed")},attr:function(e,n){return n in e?e[n]:e.constructor[n]},setattr:function(e,n,t){return e[n]=t},getKW:function(){if(null===d)return{};const e=d;return d=null,e},setKW:function(e){return d=e,b},getModule:function(e){const n=y[e];if(void 0===n)throw new Error(`module ${e} not found`);return n}},globalThis.abs=function(e){return f(e).prototype.__abs__.call(e)},globalThis.type=function(e){return f(e)},globalThis.NotImplemented=m,globalThis.range=function*(e){for(let n=0;n<e;++n)yield n},globalThis.Exception=function(e){throw new Error(e)},globalThis.__JS_LOG__=(...e)=>console.log(...e);const g=Symbol();globalThis.__JS_SET_IVALUE__=(e,n)=>e[g]=n,globalThis.__JS_GET_IVALUE__=e=>e[g],globalThis.__JS_AS_NUMBER__=e=>"infinity"===e||"inf"===e?Number.POSITIVE_INFINITY:"-infinity"===e||"-inf"===e?Number.NEGATIVE_INFINITY:Number(e),globalThis.__JS_AS_STRING__=e=>`${e}`;class h{}const y={};class $ extends h{#e=y;#n={};loadAsFunction(e){return Function("'use strict';"+e+"; return __exported__;")}registerModule(e,n){this.#e[e]=n}getModule(e){return this.#e[e]}registerBuiltins(e){for(let n in e)this.registerBuiltin(n,e[n])}registerBuiltin(e,n){this.#n[e]=n,globalThis[e]=n}}class S{}class N extends S{parser;emitter;runner;constructor(e,n,t){super(),this.parser=e,this.emitter=n,this.runner=t}run(e){return this.loadAsFunction(this.emit(this.parse(e)))()}registerModule(e,n){"string"==typeof n&&(n=this.run(n)),this.runner.registerModule(e,n)}getModule(e){return this.runner.getModule(e)}registerBuiltins(e){"string"==typeof e&&(e=this.run(e)),this.runner.registerBuiltins(e)}registerBuiltin(e,n){this.runner.registerBuiltin(e,n)}parse(e){return this.parser(e,"_")}emit(e){return this.emitter(e)}loadAsFunction(e){return this.runner.loadAsFunction(e)}}function I(e,n){let t="";for(let r=0;r<e.length;++r)t+=l(e[r],n)+";\n";return t}const J={Add:"add",Sub:"sub",Mult:"mul",Div:"div",Pow:"pow",Mod:"mod",BitOr:"or",BitAnd:"and",LShift:"lshift",RShift:"rshift"},O={Eq:"eq",NotEq:"ne"},v={Invert:"invert",USub:"neg",Not:"not"};s.ClassDef=function(e,n){const t=e.name,r=e.body,o=n.children.find((e=>e.name===t));let _=`var ${t} = (() =>{\n        function ${t}() {\n            return Object.create(${t}.prototype);\n        }\n    `;if((1!==e.bases.length||!["number","bigint","boolean","string"].includes(e.bases[0].id))&&e.bases.length>=1){_+=`${t}.prototype = Object.create(${l(e.bases[0])}.prototype);\n`;for(let n=1;n<e.bases.length;++n)_+=`Object.assign(${t}.prototype, ${l(e.bases[n])}.prototype);`;_+=`${t}.prototype.constructor = ${t};\n`}return _+=I(r,o),_+=`\n        return ${t};\n    })();\n    `,_},s.FunctionDef=function(e,n){const t=1===n.type,r=e.name,o=e.body,_=n.children.find((e=>e.name===r));let s="";1===n.type&&(s+=`${n.name}.prototype.${r} = `);for(let n=0;n<e.decorator_list.length;++n)s+=`${l(e.decorator_list[n])}(`;if(s+=`function ${r}(`,s+=l(e.args,n,t),s+="){",t){let n="";n=e.args.posonlyargs.length>0?e.args.posonlyargs[0].arg:e.args.args[0].arg,s+=`const ${n} = this;`}s+=`\n        ${I(o,_)}\n    }`;for(let n=0;n<e.decorator_list.length;++n)s+=")";return s},s.Lambda=function(e,n){return`(${l(e.args,n)}) => { return ${l(e.body)}}`},s.arguments=function(e,n,t=!1){let r="",o=0,_=0;t&&(e.posonlyargs.length?++o:++_);for(let n=o;n<e.posonlyargs.length;++n)r+=`${e.posonlyargs[n].arg}, `;for(let n=_;n<e.args.length;++n)r+=`_${e.args[n].arg}, `;if(e.args.length){r+="{";for(let n=_;n<e.args.length;++n)r+=`${e.args[n].arg} = _${e.args[n].arg}, `;r+="} = $RB.getKW()"}return r},s.Assert=function(e){return`$RB.assert(${l(e.test)})`},s.Pass=function(e){return""},s.Return=function(e){return`return ${l(e.value)}`},s.Assign=function(e,n){let t="",r="var ";if("Attribute"===o(e.targets[0]))return`$RB.setattr(${l(e.targets[0].value)}, "${e.targets[0].attr}", ${l(e.value)})`;for(let n=1;n<e.targets.length;++n)t+=`${r}${l(e.targets[n])};`;t+=r+l(e.targets[0])+" = ";for(let n=1;n<e.targets.length;++n)t+=l(e.targets[n])+" = ";return t+l(e.value)},s.Attribute=function(e){return`$RB.attr(${l(e.value)}, "${e.attr}")`},s.AugAssign=function(e){const n=e.target,t=_(e.op),r=e.value,o=J[t];if(void 0===o)throw new Error(`BinOp ${t} not impl`);return`${l(n)} = $RB.op(${l(n)}, "i${o}", ${l(r)})`},s.BinOp=function(e){const n=e.left,t=e.right,r=_(e.op),o=J[r];if(void 0===o)throw new Error(`BinOp ${r} not impl`);return`$RB.op(${l(n)}, "${o}", ${l(t)})`},s.Call=function(e){const n=e.func,t=e.args,r=e.keywords;if(n.id in i)return i[n.id](...e.args);let _="";for(let e=0;e<t.length;++e)_+=l(t[e])+", ";if(r.length){_+="$RB.setKW({";for(let e=0;e<r.length;++e)_+=`${r[e].arg}: ${l(r[e].value)},`;_+="})"}if("Attribute"===o(n)){const e=n;return`$RB.mcall(${l(e.value)}, "${e.attr}", ${_} )`}return`$RB.call(${l(n)}, ${_})`},s.Compare=function(e){const n=e.left,t=_(e.ops[0]),r=e.comparators[0];if("Is"===t)return`${l(n)} === ${l(r)}`;const o=O[t];if(void 0===o)throw console.warn(t),new Error(`CmpOp ${t} not impl`);return`$RB.op(${l(n)}, "${o}", ${l(r)})`},s.UnaryOp=function(e){const n=e.operand,t=_(e.op),r=v[t];if(void 0===r)throw new Error(`UnaryOp ${t} not impl`);return`$RB.uop("${r}", ${l(n)})`},s.Constant=function(e){const n=typeof e.value;if("object"===n){const n=e.value.__class__.__qualname__,t=e.value.value;if("float"===n)return`${t}`;if("int"===n)return`${t}n`;if("NoneType"===n)return"null"}if("string"===n)return`"${e.value}"`;if("number"===n)return`${e.value}n`;if("boolean"===n)return`${e.value}`;throw console.warn(e,n),new Error(`Unknown Cste ${n}`)},s.Expr=function(e){return l(e.value)},s.Name=function(e){return e.id},s.JoinedStr=function(e){console.warn(e);let n="`";for(let t=0;t<e.values.length;++t){const r=e.values[t];n+="Constant"===o(r)?r.value:`\${${l(r.value)}}`}return n+="`",n},s.If=function(e,n){let t=`if( ${l(e.test)} ) {\n        ${I(e.body,n)}\n    }`;for(let n=0;n<e.orelse.length;++n){const r=e.orelse[n];t+="If"===o(r)?"else "+l(r):`else { ${l(r)} }`}return t},s.While=function(e,n){return`while( ${l(e.test)} ) {\n        ${I(e.body,n)}\n    }`},s.For=function(e,n){return`for(${l(e.target)} of ${l(e.iter)}){\n        ${I(e.body,n)}\n    }`},s.Try=function(e,n){return`try {\n        ${I(e.body,n)}\n    } catch {\n        ${I(e.handlers[0].body,n)}\n    }`},s.Match=function(e,n){let t="{";t+=`const tname = type(${l(e.subject)}).name;`;for(let r=0;r<e.cases.length-1;++r)0!==r&&(t+="else "),t+=`if( tname === "${e.cases[r].pattern.cls.id}") {\n            ${I(e.cases[r].body,n)}\n        }`;return t+=`else {\n            ${I(e.cases[e.cases.length-1].body,n)}\n    }`,t+="}",t},s.Continue=function(e){return"continue;"},s.Break=function(e){return"break;"},s.Raise=function(e){return`throw ${l(e.exc)};`},s.ImportFrom=function(e){const n=e.module;if("RBM"===n)return"";if("types"===n||"typing"===n)return"";if("functools"===n)return console.warn("Import not implemented yet"),"";let t="const {";for(let n=0;n<e.names.length;++n)t+=`${e.names[n].name},`;return t+`} = $RB.getModule("${n}")`},s.Import=function(e){const n=e.names[0].name;return"RBM"===n?"":`const ${n} = $RB.getModule("${n}")`};const T=["ClassDef","FunctionDef"];function P(e){const n=e.ast.body,t=I(n,e.symtable),r=new Array;for(let e=0;e<n.length;++e){const t=n[e].constructor.$name;T.includes(t)&&r.push(n[e].name)}return t+`\nconst __exported__ = {${r.join(",")}}`}function w(e,n){const t=new $B.Parser(e,n,"file"),r=$B._PyPegen.run_parser(t),o=$B.future_features(r,n);return{filename:n,pycode:e,ast:r,symtable:$B._PySymtable_Build(r,n,o)}}function B(e){const n=e.search(/[\S]/),t=e.lastIndexOf("\n",n);if(-1===t)return e;const r=n-t-1;return e.slice(1).split("\n").map((e=>e.slice(r))).join("\n")}const j=document.querySelectorAll("script[type='text/rbrython']"),R=function(){const e=new $,n=new N(w,P,e);n.registerModule("JS",globalThis);for(let e in a)n.registerBuiltins(a[e]);return n}();for(let e=0;e<j.length;++e)R.run(B(j[e].textContent));const A=R;var E=r.A;export{E as default};
//# sourceMappingURL=index.js.map