{"version":3,"file":"libs/RBrython-dev/index.js","mappings":"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","sources":["webpack://rbrython/./src/rbry/emitter/hmacros/BE.ts","webpack://rbrython/./src/rbry/macros/__JS_OP__.ts","webpack://rbrython/./src/rbry/corelib/primitives/str.py","webpack://rbrython/./src/rbry/emitter/hmacros/tmp.ts","webpack://rbrython/./src/rbry/corelib/iterators/range.py","webpack://rbrython/./src/rbry/emitter/handlers/vars/Tuple.ts","webpack://rbrython/./src/rbry/macros/__JS_RUN__.ts","webpack://rbrython/./src/rbry/corelib/primitives/tuple.py","webpack://rbrython/./src/rbry/optimizers/safe/hmacros/bool.ts","webpack://rbrython/./src/rbry/ast/index.ts","webpack://rbrython/./src/rbry/emitter/hmacros/BB.ts","webpack://rbrython/./src/rbry/corelib/Exception.py","webpack://rbrython/./src/rbry/emitter/handlers/vars/DictComp.ts","webpack://rbrython/./src/rbry/emitter/handlers/controlflows/IfExp.ts","webpack://rbrython/./src/rbry/optimizers/safe/hmacros/getTmp.ts","webpack://rbrython/./src/rbry/corelib/primitives/float.py","webpack://rbrython/./src/rbry/corelib/primitives/object.py","webpack://rbrython/./src/rbry/runners/interface.ts","webpack://rbrython/./src/rbry/corelib/isinstance.py","webpack://rbrython/./src/rbry/corelib/operators/len.py","webpack://rbrython/./src/rbry/emitter/handlers/operators/NamedExpr.ts","webpack://rbrython/./src/rbry/corelib/print/format.py","webpack://rbrython/./src/rbry/emitter/handlers/vars/GeneratorExp.ts","webpack://rbrython/./src/rbry/checker/handlers/vars/Constant.ts","webpack://rbrython/./src/rbry/macros/__JS_LOG__.ts","webpack://rbrython/./src/rbry/emitter/hmacros/withTmp.ts","webpack://rbrython/./src/rbry/corelib/primitives/list.py","webpack://rbrython/./src/rbry/emitter/hmacros/getTmp.ts","webpack://rbrython/./src/rbry/macros/__JS_WRITE__.ts","webpack://rbrython/./src/rbry/emitter/handlers/definitions/AsyncFunctionDef.ts","webpack://rbrython/./src/rbry/macros/__JS_AS_BIGINT__.ts","webpack://rbrython/./src/rbry/corelib/print/print.py","webpack://rbrython/./src/rbry/emitter/handlers/controlflows/With.ts","webpack://rbrython/./src/rbry/corelib/primitives/bool.py","webpack://rbrython/./src/rbry/emitter/hmacros/saveTmp.ts","webpack://rbrython/./src/rbry/emitter/hmacros/NL.ts","webpack://rbrython/./src/rbry/corelib/iterators/next.py","webpack://rbrython/./src/rbry/corelib/operators/abs.py","webpack://rbrython/./src/rbry/emitter/handlers/vars/List.ts","webpack://rbrython/./src/rbry/emitter/handlers/vars/Dict.ts","webpack://rbrython/./src/rbry/corelib/primitives/type.py","webpack://rbrython/./src/rbry/emitter/handlers/keywords/Delete.ts","webpack://rbrython/./src/rbry/checker/handlers/definitions/FunctionDef.ts","webpack://rbrython/./src/rbry/emitter/handlers/keywords/Await.ts","webpack://rbrython/./src/rbry/corelib/primitives/dict.py","webpack://rbrython/./src/rbry/corelib/primitives/int.py","webpack://rbrython/./src/rbry/emitter/handlers/operators/Call.ts","webpack://rbrython/./src/rbry/optimizers/safe/hmacros/saveTmp.ts","webpack://rbrython/./src/rbry/emitter/hmacros/bool.ts","webpack://rbrython/./src/rbry/corelib/print/repr.py","webpack://rbrython/./src/rbry/emitter/handlers/keywords/YieldFrom.ts","webpack://rbrython/./src/rbry/emitter/handlers/vars/ListComp.ts","webpack://rbrython/./src/rbry/macros/__JS_AWAIT__.ts","webpack://rbrython/./src/rbry/macros/__JS_AS_STRING__.ts","webpack://rbrython/./src/rbry/macros/__JS_SHADOW__.ts","webpack://rbrython/./src/rbry/checker/types/index.ts","webpack://rbrython/./src/rbry/checker/handlers/operators/UnaryOp.ts","webpack://rbrython/./src/rbry/macros/__JS_AS_NUMBER__.ts","webpack://rbrython/./src/rbry/runners/RBrythonGlobalRunner.ts","webpack://rbrython/./src/rbry/optimizers/safe/handlers/Call.ts","webpack://rbrython/./src/rbry/runlib/interface/shadowJS.ts","webpack://rbrython/./src/rbry/runlib/helpers/getClass.ts","webpack://rbrython/./src/rbry/runlib/interface/op.ts","webpack://rbrython/./src/rbry/runlib/interface/KW.ts","webpack://rbrython/./src/rbry/runlib/interface/tmp.ts","webpack://rbrython/./src/rbry/runlib/index.ts","webpack://rbrython/./src/rbry/runlib/interface/uop.ts","webpack://rbrython/./src/rbry/runlib/interface/call.ts","webpack://rbrython/./src/rbry/runlib/helpers/isClass.ts","webpack://rbrython/./src/rbry/runlib/interface/mcall.ts","webpack://rbrython/./src/rbry/runlib/interface/assert.ts","webpack://rbrython/./src/rbry/runlib/interface/getitem.ts","webpack://rbrython/./src/rbry/runlib/interface/setitem.ts","webpack://rbrython/./src/rbry/runlib/interface/delitem.ts","webpack://rbrython/./src/rbry/runlib/interface/getattr.ts","webpack://rbrython/./src/rbry/runlib/interface/setattr.ts","webpack://rbrython/./src/rbry/runlib/interface/delattr.ts","webpack://rbrython/./src/rbry/runlib/interface/getModule.ts","webpack://rbrython/./src/rbry/runlib/interface/getModuleSync.ts","webpack://rbrython/./src/rbry/runlib/interface/in.ts","webpack://rbrython/./src/rbry/runlib/interface/ro.ts","webpack://rbrython/./src/rbry/optimizers/safe/hmacros/tmp.ts","webpack://rbrython/./src/rbry/emitter/handlers/keywords/Yield.ts","webpack://rbrython/./src/rbry/optimizers/safe/hmacros/withTmp.ts","webpack://rbrython/./src/rbry/checker/handlers/operators/Compare.ts","webpack://rbrython/webpack/bootstrap","webpack://rbrython/webpack/runtime/define property getters","webpack://rbrython/webpack/runtime/hasOwnProperty shorthand","webpack://rbrython/./src/rbry/engines/interface.ts","webpack://rbrython/./src/rbry/emitter/handlers/index.ts","webpack://rbrython/./src/rbry/emitter/handlers/definitions/ClassDef.ts","webpack://rbrython/./src/rbry/emitter/handlers/definitions/FunctionDef.ts","webpack://rbrython/./src/rbry/emitter/handlers/definitions/Lambda.ts","webpack://rbrython/./src/rbry/emitter/handlers/definitions/Arguments.ts","webpack://rbrython/./src/rbry/emitter/handlers/vars/Global.ts","webpack://rbrython/./src/rbry/emitter/handlers/vars/Nonlocal.ts","webpack://rbrython/./src/rbry/emitter/handlers/operators/Subscript.ts","webpack://rbrython/./src/rbry/emitter/handlers/keywords/Assert.ts","webpack://rbrython/./src/rbry/emitter/handlers/keywords/Pass.ts","webpack://rbrython/./src/rbry/emitter/handlers/keywords/Return.ts","webpack://rbrython/./src/rbry/ast/types/index.ts","webpack://rbrython/./src/rbry/emitter/EmitContext.ts","webpack://rbrython/./src/rbry/emitter/handlers/operators/Assign.ts","webpack://rbrython/./src/rbry/emitter/handlers/operators/Attribute.ts","webpack://rbrython/./src/rbry/emitter/handlers/operators/BinOp.ts","webpack://rbrython/./src/rbry/emitter/handlers/operators/AugAssign.ts","webpack://rbrython/./src/rbry/emitter/handlers/operators/Compare.ts","webpack://rbrython/./src/rbry/emitter/handlers/operators/UnaryOp.ts","webpack://rbrython/./src/rbry/emitter/handlers/vars/Constant.ts","webpack://rbrython/./src/rbry/emitter/handlers/vars/Expr.ts","webpack://rbrython/./src/rbry/emitter/handlers/vars/Name.ts","webpack://rbrython/./src/rbry/emitter/handlers/vars/JoinedStr.ts","webpack://rbrython/./src/rbry/emitter/handlers/controlflows/If.ts","webpack://rbrython/./src/rbry/emitter/handlers/controlflows/While.ts","webpack://rbrython/./src/rbry/emitter/handlers/controlflows/For.ts","webpack://rbrython/./src/rbry/emitter/handlers/controlflows/Try.ts","webpack://rbrython/./src/rbry/emitter/handlers/controlflows/Match.ts","webpack://rbrython/./src/rbry/emitter/handlers/keywords/Continue.ts","webpack://rbrython/./src/rbry/emitter/handlers/keywords/Break.ts","webpack://rbrython/./src/rbry/emitter/handlers/keywords/Raise.ts","webpack://rbrython/./src/rbry/emitter/handlers/imports/ImportFrom.ts","webpack://rbrython/./src/rbry/emitter/handlers/imports/Import.ts","webpack://rbrython/./src/rbry/emitter/handlers/operators/BoolOp.ts","webpack://rbrython/./src/rbry/emitter/exports/global.ts","webpack://rbrython/./src/rbry/emitter/exports/return.ts","webpack://rbrython/./src/rbry/emitter/exports/module.ts","webpack://rbrython/./src/rbry/emitter/exports/brython.ts","webpack://rbrython/./src/rbry/emitter/handlers/list.ts","webpack://rbrython/./src/rbry/emitter/targets/raw.ts","webpack://rbrython/./src/rbry/checker/handlers/index.ts","webpack://rbrython/./src/rbry/checker/Walker.ts","webpack://rbrython/./src/rbry/emitter/hmacros/list.ts","webpack://rbrython/./src/rbry/optimizers/safe/handlers/index.ts","webpack://rbrython/./src/rbry/optimizers/safe/hmacros/index.ts","webpack://rbrython/./src/rbry/optimizers/index.ts","webpack://rbrython/./src/rbry/emitter/index.ts","webpack://rbrython/./src/rbry/emitter/targets/function.ts","webpack://rbrython/./src/rbry/engines/Base/index.ts","webpack://rbrython/./src/rbry/parser/index.ts","webpack://rbrython/./src/rbry/engines/RBrython/index.ts","webpack://rbrython/./src/libs/RBrython-dev/index.ts"],"sourcesContent":["import { EmitContext } from \"../EmitContext\";\n\nexport default function BE() {\n    return function(ctx: EmitContext) {\n        --ctx.indent_level;\n        ctx.w_line();\n    }\n}","import { ASTNode } from \"../ast/types\";\nimport { EmitContext } from \"../emitter/EmitContext\";\n\nexport default function __JS_OP__(ctx: EmitContext, ...args: ASTNode[]) {\n    \n    if(args.length === 2) {// unary op\n        // @ts-ignore\n        const op = args[0].value;\n        ctx.w`${op}${args[1]}`;\n        return;\n    }\n    \n    // binary op\n    // @ts-ignore\n    const op = args[1].value;\n\n    if( op === \"[]\")\n        return ctx.w`${args[0]}[${args[2]}]`;\n\n    ctx.w`${args[0]} ${op} ${args[2]}`;\n}","export default \"from types import NotImplementedType\\nfrom RBM import __JS_OP__, __JS_SHADOW__, string\\n\\n@__JS_SHADOW__(\\\"string\\\")\\nclass str(string):\\n    def __new__(cls, o: object, /) -> str:\\n        #return __JS_AS_STRING__(o) # type: ignore\\n        return type(o).__str__(o) # type: ignore\\n    \\n    def __eq__(self, o: object, /) -> bool:\\n        return __JS_OP__(self, \\\"==\\\", o)\\n    \\n    def __add__(self, o: object, /) -> NotImplementedType|str:\\n        match o:\\n            case str  (): return __JS_OP__(self, \\\"+\\\", o) # type: ignore\\n            case _      : return NotImplemented\\n\\n    def __mul__(self, o: object, /) -> NotImplementedType|str:\\n        match o:\\n            case int  (): return __JS_WRITE__(\\\"self.repeat(Number(b))\\\") # type: ignore\\n            case _      : return NotImplemented\\n    \\n    def __rmul__(self, o: object, /) -> NotImplementedType|str:\\n        match o:\\n            case int  (): return __JS_WRITE__(\\\"self.repeat(Number(b))\\\") # type: ignore\\n            case _      : return NotImplemented\";","import { EmitContext } from \"../EmitContext\";\n\nexport default function tmp() {\n    return function(ctx: EmitContext) {\n        ctx.w`$RB.tmp()`;\n    }\n}","export default \"def range(a1: int, a2: int|None = None, a3: int|None = None):\\n    beg = 0\\n    end = a1\\n    inc = 1\\n\\n    if a2 is not None:\\n        beg = a1\\n        end = a2\\n\\n        if a3 is not None:\\n            inc = a3\\n\\n    i = beg\\n    while i != end:\\n        yield i\\n        i += inc\";","import { TupleNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Tuple(node: TupleNode, ctx: EmitContext) {\n    ctx.w`$RB.ro([`;\n\n    for(let i = 0; i < node.elts.length; ++i) {\n        ctx.w_node(node.elts[i]);\n        ctx.w_str(', ');\n    }\n\n    ctx.w`])`;\n}","import { ASTNode, StringNode } from \"../ast/types\";\nimport { EmitContext } from \"../emitter/EmitContext\";\n\nexport default function __JS_RUN__(ctx: EmitContext, code: ASTNode, ...args: ASTNode[]) {\n    \n    ctx.w`(${unescape((code as StringNode).value)})(`;\n    for(let i = 0; i < args.length; ++i)\n        ctx.w`${args[i]},`;    \n    ctx.w`)`;\n}\n\nfunction unescape(str: string) {\n    str = str.replaceAll(\"\\\\n\\\\\", \"\\n\");\n    return str;\n}","export default \"from RBM import __JS_OP__, __JS_SHADOW__, __JS_WRITE__, ROArray\\n\\n@__JS_SHADOW__(\\\"Array\\\", True)\\nclass tuple(ROArray):\\n    def __getitem__(self, i: int):\\n        return __JS_OP__(self, \\\"[]\\\", i)\\n    \\n    def __len__(self):\\n        return __JS_WRITE__(\\\"this.length\\\")\";","import { TypedASTNode } from \"@RBrython/rbry/checker/Walker\";\nimport { EmitContext } from \"@RBrython/rbry/emitter/EmitContext\";\nimport { HMacro } from \"../..\";\nimport { BoolType, isInstance } from \"@RBrython/rbry/checker/types\";\n\nexport default function bool(fallback: HMacro, node: TypedASTNode) {\n\n    if( isInstance(node.result_type, BoolType ) )\n        return (ctx: EmitContext) => ctx.w`(${node})`;\n\n    return fallback(node);\n\n    /* \n        return function(ctx: EmitContext) {\n            console.warn(node);\n            ctx.w`bool(${node})`;\n        }\n    */\n}","import { ASTNode, OperatorNode } from \"./types\";\n\nexport function isASTNode(o: unknown): o is ASTNode {\n    if( o == null)\n        return false;\n    return \"$name\" in (o as object).constructor;\n}\n\nexport function nodeType(node: ASTNode): string {\n    // @ts-ignore\n    return node.constructor.$name;\n}\n\nexport function getOp(op: OperatorNode): string {\n    // @ts-ignore\n    return op.constructor.$name\n}\n\nexport function getChildren(elem: ASTNode): ASTNode[] {\n    return [...Object.values(elem)].filter(e => typeof e === \"object\"\n                                            // @ts-ignore\n                                        && e.constructor.$name !== undefined);\n}","import { EmitContext } from \"../EmitContext\";\n\nexport default function BB() {\n    return function(ctx: EmitContext) {\n        ++ctx.indent_level;\n        ctx.w_line();\n    }\n}\n\n","export default \"\\nfrom RBM import __JS_WRITE__\\n\\nclass Exception():\\n\\n    def __new__(cls, arg: str|None):\\n        return __JS_WRITE__(\\\"new Error(arg)\\\")\\n\\n    def __str__(self):\\n        return __JS_WRITE__(\\\"this.message\\\")\";","import { DictCompNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function ListComp(node: DictCompNode, ctx: EmitContext) {\n\n    console.warn(node);\n\n    ctx.w`(function(){${ctx.hm.BB()}`;\n\n    ctx.w`const _r_ = [];${ctx.hm.NL()}`\n\n    for(let i = 0; i < node.generators.length; ++i) {\n        const gen = node.generators[i];\n        ctx.w`for(let ${gen.target} of ${gen.iter}){${ctx.hm.BB()}`;\n\n        for(let j = 0; j < gen.ifs.length; ++j) {\n            ctx.w`if(${gen.ifs[j]}){${ctx.hm.BB()}`;\n        }\n    }\n\n    ctx.w`_r_.push([${node.key}, ${node.value}])`;\n\n    for(let i = 0; i < node.generators.length; ++i) {\n        ctx.w`${ctx.hm.BE()}}`;\n\n        for(let j = 0; j < node.generators[i].ifs.length; ++j) {\n            ctx.w`${ctx.hm.BE()}}`;\n        }\n    }\n\n    ctx.w`${ctx.hm.NL()}return dict(_r_);`;\n\n    ctx.w`${ctx.hm.BE()}})()`\n}","import { IfExpNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function If(node: IfExpNode, ctx: EmitContext) {\n    ctx.w`( ${ctx.hm.bool(node.test)} ? ${node.body} : ${node.orelse} )`;\n}","import { EmitContext } from \"@RBrython/rbry/emitter/EmitContext\";\nimport { HMacro } from \"../..\";\nimport { ASTNode } from \"@RBrython/rbry/ast/types\";\nimport { isSimple } from \"./saveTmp\";\n\nexport default function getTmp(fallback: HMacro, node: ASTNode) {\n\n    if( isSimple(node) )\n        return (ctx: EmitContext) => ctx.w_node(node);\n\n    return fallback(node);\n}","export default \"from types import NotImplementedType\\nfrom RBM import __JS_OP__, __JS_AS_NUMBER__, __JS_SHADOW__, __JS_WRITE__, number\\n\\n@__JS_SHADOW__(\\\"number\\\")\\nclass float(number):\\n    def __new__(cls, o: object, /) -> float:\\n        if type(o) is str:\\n            if o == \\\"infinity\\\" or o == \\\"inf\\\":\\n                return __JS_WRITE__(\\\"Number.POSITIVE_INFINITY\\\") # pyright: ignore[reportReturnType]\\n            if o == \\\"-infinity\\\" or o == \\\"-inf\\\":\\n                return __JS_WRITE__(\\\"Number.NEGATIVE_INFINITY\\\") # pyright: ignore[reportReturnType]\\n            return __JS_AS_NUMBER__(o)\\n        return type(o).__float__(o) # type: ignore\\n    \\n    def __str__(self):\\n        return __JS_WRITE__(\\\"`${this}`\\\")\\n    \\n    def __eq__(self, o: object, /) -> bool:\\n        return __JS_OP__(self, \\\"==\\\", o)    \\n\\n    def __add__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case float(): return __JS_OP__(self, \\\"+\\\", o)\\n            case int  (): return __JS_OP__(self, \\\"+\\\", __JS_AS_NUMBER__(o))\\n            case _      : return NotImplemented\\n\\n    def __radd__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case float(): return __JS_OP__(o                  , \\\"+\\\", self)\\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), \\\"+\\\", self)\\n            case _      : return NotImplemented\\n\\n    def __sub__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case float(): return __JS_OP__(self, \\\"-\\\", o)\\n            case int  (): return __JS_OP__(self, \\\"-\\\", __JS_AS_NUMBER__(o))\\n            case _      : return NotImplemented\\n\\n    def __rsub__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case float(): return __JS_OP__(o                  , \\\"-\\\", self)\\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), \\\"-\\\", self)\\n            case _      : return NotImplemented\\n\\n    def __mul__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case float(): return __JS_OP__(self, \\\"*\\\", o)\\n            case int  (): return __JS_OP__(self, \\\"*\\\", __JS_AS_NUMBER__(o))\\n            case _      : return NotImplemented\\n\\n    def __rmul__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case float(): return __JS_OP__(o                  , \\\"*\\\", self)\\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), \\\"*\\\", self)\\n            case _      : return NotImplemented\\n\\n    def __truediv__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case float(): return __JS_OP__(self, \\\"/\\\", o)\\n            case int  (): return __JS_OP__(self, \\\"/\\\", __JS_AS_NUMBER__(o))\\n            case _      : return NotImplemented\\n\\n    def __rtruediv__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case float(): return __JS_OP__(o                  , \\\"/\\\", self)\\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), \\\"/\\\", self)\\n            case _      : return NotImplemented\\n\\n    ### unary operators ###\\n\\n    def __neg__(self, /) -> float:\\n        return __JS_OP__(\\\"-\\\", self)\\n    \\n    def __int__(self, /) -> int:\\n        return __JS_RUN__('(x) => Math.trunc(x)', self) # type: ignore\\n    \\n    def __abs__(self, /) -> int:\\n         return __JS_RUN__('(x) => Math.abs(x)', self) # type: ignore\";","export default \"from RBM import __JS_WRITE__, obj\\n\\nclass object(obj): # typecheck h4ck\\n\\n    def __new__(cls):\\n        return __JS_WRITE__(\\\"Object.create(this.prototype)\\\")\\n\\n    def __eq__(self, o: obj, /):\\n        if self is o: return True\\n        return NotImplemented\\n    \\n    def __ne__(self, o: obj, /):\\n        return not self == o\\n    \\n    def __lt__(self, o: obj, /):\\n        return NotImplemented\\n    def __le__(self, o: obj, /):\\n        return NotImplemented\\n    def __gt__(self, o: obj, /):\\n        return NotImplemented\\n    def __ge__(self, o: obj, /):\\n        return NotImplemented\\n    \\n    # print\\n    def __repr__(self):\\n        #TODO: __module__ not implemented\\n        #TODO: __qualname__ not implemented\\n        return \\\"<? object>\\\" # using f\\\"\\\" = infinite loop.\\n    \\n    def __str__(self):\\n        return type(self).__repr__(self)\\n    \\n    def __format__(self, f:str):\\n        return type(self).__str__(self)\";","export type PyModule = Record<string, any>;\n\nexport default abstract class Runner {\n    \n    abstract run(jscode: string): Promise<PyModule>;\n    abstract runSync(jscode: string): PyModule;\n\n    abstract registerBuiltins(symbols: PyModule): void;\n    abstract registerBuiltin(name: string, value: any): void;\n\n    abstract registerModule(name: string, symbols: PyModule): void;\n    abstract      getModule(name: string): PyModule;\n\n    // low level\n    abstract loadAsFunction(jscode: string): (runlib: any) => Promise<PyModule>;\n    abstract runFunction(fct: (runlib: any) => Promise<PyModule>): Promise<PyModule>;\n\n    abstract loadAsSyncFunction(jscode: string): (runlib: any) => PyModule;\n    abstract runSyncFunction(fct: (runlib: any) => PyModule): PyModule;\n}","export default \"def isinstance(o: object, t):\\n    ot = type(o)\\n    # TODO: better\\n    return ot is t\";","export default \"def len(o, /) -> float|int:\\n    return type(o).__len__(o) # pyright: ignore[reportArgumentType]\";","import { NamedExprNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function NamedExpr(node: NamedExprNode, ctx: EmitContext) {\n    return ctx.w`(${node.target} = ${node.value})`\n}","export default \"def format(o: object, f: str):\\n    return type(o).__format__(o, f)\";","import { GeneratorExpNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function GeneratorExp(node: GeneratorExpNode, ctx: EmitContext) {\n\n    ctx.w`(function*(){${ctx.hm.BB()}`;\n\n    for(let i = 0; i < node.generators.length; ++i) {\n        const gen = node.generators[i];\n        ctx.w`for(let ${gen.target} of ${gen.iter}){${ctx.hm.BB()}`;\n\n        for(let j = 0; j < gen.ifs.length; ++j) {\n            ctx.w`if(${gen.ifs[j]}){${ctx.hm.BB()}`;\n        }\n    }\n\n    ctx.w`yield ${node.elt}`;\n\n    for(let i = 0; i < node.generators.length; ++i) {\n        ctx.w`${ctx.hm.BE()}}`;\n\n        for(let j = 0; j < node.generators[i].ifs.length; ++j) {\n            ctx.w`${ctx.hm.BE()}}`;\n        }\n    }\n\n    ctx.w`${ctx.hm.BE()}})()`\n}","import { ConstantNode } from \"../../../ast/types\";\nimport { BoolType } from \"../../types\";\nimport { TypedEntry } from \"../../Walker\";\n\nexport default function Constant(entry: TypedEntry<ConstantNode>) {\n\n        const type = typeof entry.node.value;\n\n        /*\n        if( type === \"object\") {\n            // @ts-ignore\n            const qname = node.value.__class__.__qualname__\n            // @ts-ignore\n            const value: float|bigint = node.value.value;\n\n            if( qname === \"float\"   ) return ctx.w`${value}`;\n            if( qname === \"int\"     ) return ctx.w`${value}n`;\n            if( qname === \"NoneType\") return ctx.w`null`;\n            //if( qname === \"ellipsis\") return \"$RB.ellipsis\";\n        }\n        if( type === \"string\" ) return ctx.w`\"${node.value}\"`;\n        if( type === \"number\" ) return ctx.w`${node.value}n`; // bigint\n        */\n        if( type === \"boolean\") {\n            entry.node.result_type = { type: BoolType }\n        }\n\n        //console.warn(node, type);\n        //throw new Error(`Unknown Cste ${type}`);\n}","import { ASTNode } from \"../ast/types\";\nimport { EmitContext } from \"../emitter/EmitContext\";\n\nexport default function __JS_LOG__(ctx: EmitContext, ...args: ASTNode[]) {\n\n    ctx.w_str(\"console.log(\");\n\n    for(let i = 0; i < args.length; ++i)\n        ctx.w`${args[i]},`;\n\n    ctx.w_str(\");\");\n}","import { ASTNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../EmitContext\";\n\nexport default function withTmp(_: ASTNode) {\n    return function(ctx: EmitContext) {\n        ctx.w`$RB.withTmp`;\n    }\n}","export default \"from RBM import __JS_OP__, __JS_SHADOW__, __JS_WRITE__, Array\\n\\n@__JS_SHADOW__(\\\"Array\\\")\\nclass list(Array):\\n    def __getitem__(self, i: int):\\n        return __JS_OP__(self, \\\"[]\\\", i)\\n    \\n    def __len__(self):\\n        return __JS_WRITE__(\\\"this.length\\\")\";","import { EmitContext } from \"../EmitContext\";\n\nexport default function getTmp() {\n    return function(ctx: EmitContext) {\n        ctx.w`$RB.getTmp()`;\n    }\n}","import { ASTNode, StringNode } from \"../ast/types\";\nimport { EmitContext } from \"../emitter/EmitContext\";\n\nexport default function __JS_WRITE__(ctx: EmitContext, code: ASTNode) {\n    ctx.w_str((code as StringNode).value.replaceAll(\"\\\\n\\\\\\n\", \"\\n\"));\n}","import { FunctionDefNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function AsyncFunctionDef(node: FunctionDefNode, ctx: EmitContext) {\n\n    const isMethod = ctx.isMethod();\n\n    const name = node.name;\n    const body = node.body;\n\n    if( isMethod )\n        ctx.w`${ctx.getName(-1)}.prototype.${name} = `;\n\n    // open decorator\n    for( let i = 0; i < node.decorator_list.length ; ++i )\n        ctx.w`${node.decorator_list[i]}(`;\n\n    ctx.w`async function ${name} ${node.args}`;\n\n    // start of the function/lambda is included in the arguments...\n\n    ctx.w_body(body);\n    ctx.w`}`;\n\n    // close decorator\n    for( let i = 0; i < node.decorator_list.length ; ++i )\n        ctx.w`)`;\n}","import { ASTNode } from \"../ast/types\";\nimport { EmitContext } from \"../emitter/EmitContext\";\n\nexport default function __JS_AS_BIGINT__(ctx: EmitContext, node: ASTNode) {\n    ctx.w`BigInt(${node})`;\n}","export default \"from JS import console\\n\\ndef print(*a):\\n    s = \\\"\\\"\\n\\n    for i in range(len(a)):\\n        if i != 0:\\n            s += \\\" \\\"\\n        s += str(a[i])\\n\\n    console.log(s)\";","import { WithNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function With(node: WithNode, ctx: EmitContext) {\n    \n    ctx.w`{${ctx.hm.BB()}`;\n    for(let i = 0; i < node.items.length; ++i )\n        ctx.w`const _w${i}_ = ${node.items[i].context_expr};${ctx.hm.NL()}`\n\n    for(let i = 0; i < node.items.length; ++i) {\n        const r = node.items[i];\n        if( r.optional_vars !== undefined)\n            ctx.w`var ${r.optional_vars} = `;\n        ctx.w`$RB.mcall(_w${i}_, '__enter__');${ctx.hm.NL()}`\n    }\n\n    ctx.w`let _err_ = null;${ctx.hm.NL()}`\n\n    ctx.w`try{${node.body}} catch(_e_) { _err_ = _e_ }${ctx.hm.NL()}`;\n    ctx.w`finally {${ctx.hm.BB()}`\n\n        ctx.w`let _et_ = null; let _ee_ = null; let _ex_ = null;${ctx.hm.NL()}`;\n\n        ctx.w`if(_err_ !== null) {${ctx.hm.BB()}`;\n            ctx.w`_et_ = 'type';${ctx.hm.NL()}`;\n            ctx.w`_ee_ = 'exp';${ctx.hm.NL()}`;\n            ctx.w`_ex_ = 'trace';`;\n        ctx.w`${ctx.hm.BE()}}${ctx.hm.NL()}`;\n\n\n    ctx.w`let _ok_ = true;${ctx.hm.NL()}`\n    for(let i = node.items.length - 1; i >= 0; --i) {\n        const r = node.items[i];\n        ctx.w`_ok_ &&= $RB.mcall(_w${i}_, '__exit__', _et_, _ee_, _ex_);${ctx.hm.NL()}`\n    }\n    ctx.w`if( _err_ !== null && ! _ok_ ) throw _err_;`;\n\n    ctx.w`${ctx.hm.BE()}}${ctx.hm.BE()}}`;\n}","export default \"from RBM import __JS_OP__, __JS_SHADOW__, __JS_WRITE__, boolean\\n\\n@__JS_SHADOW__(\\\"boolean\\\")\\nclass bool(boolean, int): # type: ignore (bool is Final)\\n    def __new__(cls, arg: object, /) -> boolean:# -> Any | bool:\\n        # can't use Python \\\"if\\\", \\\"or\\\" as we'd have an infinite loop.\\n        __JS_WRITE__(\\\"if(arg === true || arg === false) { return arg; }\\\")\\n        return type(arg).__bool__(arg) # type: ignore\";","import { ASTNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../EmitContext\";\n\nexport default function saveTmp(node: ASTNode) {\n    return function(ctx: EmitContext) {\n        ctx.w`$RB.saveTmp(${node})`;\n    }\n}","import { EmitContext } from \"../EmitContext\";\n\nexport default function NL() {\n    return function(ctx: EmitContext) {\n        ctx.w_line();\n    }\n}","export default \"from RBM import __JS_WRITE__\\n\\n_marker = __JS_WRITE__(\\\"Symbol()\\\") #object()\\n\\ndef next(it, defaultVal: object = _marker):\\n    val = __JS_WRITE__(\\\"it.next()\\\") #TODO: we use JS iterator\\n    if __JS_WRITE__(\\\"val.done\\\") == True:\\n        if defaultVal is _marker:\\n            raise Exception(\\\"StopIteration\\\")\\n        return defaultVal\\n    \\n    return __JS_WRITE__(\\\"val.value\\\")\";","export default \"def abs(o: float|int, /) -> float|int:\\n    return type(o).__abs__(o) # pyright: ignore[reportArgumentType]\";","import { ListNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function List(node: ListNode, ctx: EmitContext) {\n    \n    ctx.w`[`;\n\n    for(let i = 0; i < node.elts.length; ++i) {\n        ctx.w_node(node.elts[i]);\n        ctx.w_str(', ');\n    }\n\n    ctx.w`]`;\n}","import { DictNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function List(node: DictNode, ctx: EmitContext) {\n    \n    ctx.w`dict([`;\n\n    for(let i = 0; i < node.keys.length; ++i) {\n        ctx.w`[${node.keys[i]}, ${node.values[i]}], `\n    }\n\n    ctx.w`])`;\n}","export default \"from RBM import __JS_OP__, __JS_WRITE__\\n\\nclass type:\\n    def __new__(cls, o: object, /) -> type:\\n        return __JS_WRITE__(\\\"$RB.getClass(o)\\\") # pyright: ignore[reportReturnType]\\n\\n    def __call__(self, *args):\\n        __JS_WRITE__(\\\"\\\"\\\"\\n                     let instance;\\n                     const factory = this.prototype.__new__;\\n                     if( factory !== undefined )\\n                        instance = factory.call(self, ...args)\\n                     else\\n                        instance = new self(...args) // JS\\n                     \\n                     const init = this.prototype.__init__;\\n                     if( init !== undefined)\\n                        init.call(instance, ...args)\\n                     \\\"\\\"\\\")\\n        return instance # type: ignore\";","import { AttributeNode, DeleteNode, SubscriptNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\nimport { nodeType } from \"@RBrython/rbry/ast\";\n\nexport default function Delete(node: DeleteNode, ctx: EmitContext) {\n\n    for(let i = 0; i < node.targets.length; ++i) {\n        const type = nodeType(node.targets[i]);\n        if( type === \"Subscript\") {\n            const snode = node.targets[i] as SubscriptNode;\n            ctx.w`$RB.delitem(${snode.value}, ${snode.slice});${ctx.hm.NL}`\n            continue;\n        }\n        if( type === \"Attribute\") {\n            const snode = node.targets[i] as AttributeNode;\n            ctx.w`$RB.delattr(${snode.value}, \"${snode.attr}\");${ctx.hm.NL}`\n            continue;\n        }\n        console.warn(type);\n        throw new Error(\"Not implemented\");\n    }\n}","import { FunctionDefNode } from \"@RBrython/rbry/ast/types\";\nimport { TypedEntry } from \"../../Walker\";\nimport { FunctionType } from \"../../types\";\n\nexport default function FunctionDef(entry: TypedEntry<FunctionDefNode>) {\n    (entry.symtab.typedSymbols ||= {})[entry.node.name] = {type: FunctionType};\n}","import { AwaitNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Await(node: AwaitNode, ctx: EmitContext) {\n    ctx.w`await ${node.value}`;\n}","export default \"from JS import Symbol\\n\\n__BUCKETS__ = Symbol(\\\"buckets\\\")\\n\\nclass dict:\\n    def __init__(self, args):\\n\\n        __JS_WRITE__(\\\"this[__BUCKETS__] = new Map()\\\")\\n\\n        # destructured arg not implemented in for\\n        # __eq__ influence not implemented...\\n        for i in range(len(args)):\\n            __JS_WRITE__(\\\"this[__BUCKETS__]\\\").set(args[i][0], args[i][1])\";","export default \"from types import NotImplementedType\\nfrom RBM import __JS_AS_NUMBER__, __JS_OP__, __JS_SHADOW__, bigint\\n\\n@__JS_SHADOW__(\\\"bigint\\\")\\nclass int(bigint):\\n\\n    def __new__(cls, o: object, base: int, /) -> int:\\n        if type(o) == str:\\n            return __JS_RUN__( # type: ignore\\n                '''\\n                    (x, base) => {\\n                        if( base !== 16)\\n                            return BigInt(x);\\n                        \\n                        let result = 0n;\\n                        for(let i = 2; i < x.length; ++i)\\n                            result = result << 4n + BigInt( parseInt(this.slice(i, i+8), 16) );\\n                        return result;\\n                    }\\n                ''', o, base) # type: ignore\\n        return type(o).__int__(o) # type: ignore\\n    \\n    def __str__(self):\\n        return __JS_WRITE__(\\\"`${this}`\\\")\\n    \\n    def __eq__(self, o: object, /) -> bool:\\n        return __JS_OP__(self, \\\"==\\\", o)\\n    \\n    def __ge__(self, o: object, /) -> bool:\\n        return __JS_OP__(self, \\\">=\\\", o)\\n\\n\\n    def __add__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"+\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __radd__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(o, \\\"+\\\", self)\\n            case _      : return NotImplemented\\n    \\n\\n    def __sub__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"-\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __rsub__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(o, \\\"-\\\", self)\\n            case _      : return NotImplemented\\n    \\n    def __mul__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"*\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __rmul__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(o, \\\"*\\\", self)\\n            case _      : return NotImplemented\\n\\n    def __pow__(self, o: object, mod: int|None = None, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"**\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __rpow__(self, o: object, mod: int|None = None, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(o, \\\"**\\\", self)\\n            case _      : return NotImplemented\\n\\n    def __truediv__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(self),\\n                                           \\\"/\\\",\\n                                           __JS_AS_NUMBER__(o))\\n            case _      : return NotImplemented\\n    \\n    def __rtruediv__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o),\\n                                           \\\"*\\\",\\n                                           __JS_AS_NUMBER__(self) )\\n            case _      : return NotImplemented\\n\\n    def __mod__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"%\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __rmod__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"%\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __or__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"|\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __ror__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"|\\\", o)\\n            case _      : return NotImplemented\\n\\n    def __and__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"&\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __rand__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"&\\\", o)\\n            case _      : return NotImplemented\\n        \\n    def __xor__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"^\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __rxor__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"^\\\", o)\\n            case _      : return NotImplemented\\n\\n    def __lshift__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  ():\\n                __JS_LOG__(\\\"INT\\\")\\n                return __JS_OP__(self, \\\"<<\\\", o)\\n            case _      :\\n                __JS_LOG__(\\\"OTHER\\\", o)\\n                return NotImplemented\\n    \\n    def __rlshift__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"<<\\\", o)\\n            case _      : return NotImplemented\\n\\n    def __rshift__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\">>\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __rrshift__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\">>\\\", o)\\n            case _      : return NotImplemented\\n    \\n    ### unary operators ###\\n    def __invert__(self, /) -> int:\\n        return __JS_OP__(\\\"~\\\", self)\\n\\n    def __neg__(self, /) -> int:\\n        return __JS_OP__(\\\"-\\\", self)\\n    \\n    def __abs__(self, /) -> int:\\n         return __JS_RUN__(\\\"x => x < 0n ? -x : x\\\", self) # type: ignore\";","import { nodeType } from \"../../../ast\";\nimport { AttributeNode, CallNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Call(node: CallNode, ctx: EmitContext) {\n    const f        = node.func;\n\n    // @ts-ignore\n    const fid: string = f.id;\n\n    if( fid in ctx.macros) {\n        ctx.macros[fid](ctx, ...node.args);\n        return;\n    }\n\n    if( nodeType(f) === \"Attribute\") {\n        const m = f as AttributeNode;\n        ctx.w`$RB.mcall(${m.value}, \"${m.attr}\", `;\n    } else {\n        ctx.w`$RB.call(${f}, `;\n    }\n\n    writeArgs(node, ctx);\n\n    ctx.w_str(\")\");\n}\n\nexport function writeArgs(node: CallNode, ctx: EmitContext) {\n\n    const args     = node.args;\n    const keywords = node.keywords;\n\n    //TODO: args parsing...\n    for(let i = 0; i < args.length; ++i)\n        ctx.w`${args[i]}, `;\n\n    if( keywords.length ) {\n        ctx.w`$RB.setKW({`;\n            for( let i = 0; i < keywords.length; ++i)\n                ctx.w`${keywords[i].arg}: ${keywords[i].value},`;\n        ctx.w`})`;\n    }\n}","import { ASTNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"@RBrython/rbry/emitter/EmitContext\";\nimport { HMacro } from \"../..\";\nimport { nodeType } from \"@RBrython/rbry/ast\";\n\nexport function isSimple(node: ASTNode) {\n\n    const type = nodeType(node);\n\n    return type === \"Constant\" || type === \"Name\";\n}\n\nexport default function saveTmp(fallback: HMacro, node: ASTNode) {\n\n    if( isSimple(node) )\n        return (ctx: EmitContext) => ctx.w_node(node);\n\n    return fallback(node);\n}","import { ASTNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../EmitContext\";\n\nexport default function bool(node: ASTNode) {\n    return function(ctx: EmitContext) {\n        ctx.w`bool(${node})`;\n    }\n}","export default \"def repr(o: object):\\n    return type(o).__repr__(o)\";","import { YieldNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function YieldFrom(node: YieldNode, ctx: EmitContext) {\n    ctx.w`yield * ${node.value}`;\n}","import { ListCompNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function ListComp(node: ListCompNode, ctx: EmitContext) {\n\n    ctx.w`(function(){${ctx.hm.BB()}`;\n\n    ctx.w`const _r_ = [];${ctx.hm.NL()}`\n\n    for(let i = 0; i < node.generators.length; ++i) {\n        const gen = node.generators[i];\n        ctx.w`for(let ${gen.target} of ${gen.iter}){${ctx.hm.BB()}`;\n\n        for(let j = 0; j < gen.ifs.length; ++j) {\n            ctx.w`if(${gen.ifs[j]}){${ctx.hm.BB()}`;\n        }\n    }\n\n    ctx.w`_r_.push(${node.elt})`;\n\n    for(let i = 0; i < node.generators.length; ++i) {\n        ctx.w`${ctx.hm.BE()}}`;\n\n        for(let j = 0; j < node.generators[i].ifs.length; ++j) {\n            ctx.w`${ctx.hm.BE()}}`;\n        }\n    }\n\n    ctx.w`${ctx.hm.NL()}return _r_;`;\n\n    ctx.w`${ctx.hm.BE()}})()`\n}","import { ASTNode } from \"../ast/types\";\nimport { EmitContext } from \"../emitter/EmitContext\";\n\nexport default function __JS_AWAIT__(ctx: EmitContext, node: ASTNode) {\n    ctx.w`await ${node}`;\n}\n\n","import { ASTNode } from \"../ast/types\";\nimport { EmitContext } from \"../emitter/EmitContext\";\n\nexport default function __JS_AS_STRING__(ctx: EmitContext, node: ASTNode) {\n    ctx.w`\\`\\${${node}}\\``;\n}","import { ASTNode } from \"../ast/types\";\nimport { EmitContext } from \"../emitter/EmitContext\";\n\nexport default function __JS_SHADOW__(ctx: EmitContext, jstype: ASTNode) {\n    ctx.w`$RB.shadowJS(${jstype})`;\n}","export type TypeDesc = {\n    // meta\n    const?: boolean\n    type  : object\n}\n\nexport const FunctionType = {};\nexport const BoolType = {};\n\nexport function isInstance(v: TypeDesc, t: object) {\n    return v !== undefined && v.type === t;\n}","import { UnaryOpNode } from \"@RBrython/rbry/ast/types\";\nimport { TypedEntry } from \"../../Walker\";\nimport { getOp } from \"@RBrython/rbry/ast\";\nimport { BoolType } from \"../../types\";\n\nexport default function UnaryOp(entry: TypedEntry<UnaryOpNode>) {\n\n    if( getOp(entry.node.op) === \"Not\")\n        entry.node.result_type = { type: BoolType }\n}","import { ASTNode } from \"../ast/types\";\nimport { EmitContext } from \"../emitter/EmitContext\";\n\nexport default function __JS_AS_NUMBER__(ctx: EmitContext, node: ASTNode) {\n    ctx.w`Number(${node})`;\n}","import \"@RBrython/rbry/runlib\";\n\nimport Runner, { PyModule } from \"./interface\";\nimport { $RB } from \"@RBrython/rbry/runlib\";\n\nexport const modules: Record<string, any> = {};\n\nexport default class RBrythonGlobalRunner extends Runner {\n\n    #module   = modules; // h4ck\n    #builtins: Record<string, any> = {};\n\n    override async run(jscode: string) {\n        return await this.runFunction( this.loadAsFunction(jscode) );\n    }\n    override runSync(jscode: string) {\n        return this.runSyncFunction( this.loadAsSyncFunction(jscode) );\n    }\n\n    override loadAsFunction(jscode: string): (runlib: any) => Promise<PyModule> {\n        return eval(jscode) as (runlib: any) => Promise<PyModule>;\n    }\n    override async runFunction( fct: (runlib: any) => Promise<PyModule> ) {\n        return await fct($RB);\n    }\n\n    override loadAsSyncFunction(jscode: string): (runlib: any) => PyModule {\n        return eval(jscode) as (runlib: any) => PyModule;\n    }\n    override runSyncFunction( fct: (runlib: any) => PyModule ) {\n        return fct($RB);\n    }\n\n    // modules\n    override registerModule(name: string, symbols: PyModule): void {\n        this.#module[name] = symbols;\n    }\n    override getModule(name: string): PyModule {\n        return this.#module[name];\n    } \n\n    // builtins\n    override registerBuiltins(symbols: PyModule): void {\n        for(let name in symbols)\n            this.registerBuiltin(name, symbols[name]);\n    }\n    override registerBuiltin(name: string, value: any): void {\n        this.#builtins[name] = value;\n\n        // @ts-ignore\n        globalThis[name] = value;\n    }\n}","import { nodeType } from \"@RBrython/rbry/ast\";\nimport { CallNode } from \"@RBrython/rbry/ast/types\";\nimport { FunctionType, isInstance } from \"@RBrython/rbry/checker/types\";\nimport { EmitContext } from \"@RBrython/rbry/emitter/EmitContext\";\nimport { Handler     } from \"@RBrython/rbry/emitter/handlers\";\nimport { writeArgs   } from \"@RBrython/rbry/emitter/handlers/operators/Call\";\n\nexport default function Call(node    : CallNode,\n                             ctx     : EmitContext,\n                             fallback: Handler) {\n\n    //TODO: better assert type...\n    if( nodeType(node.func) === \"Name\"\n        // @ts-ignore\n        && ctx.symtab.typedSymbols !== undefined) {\n        // @ts-ignore\n        const name: string = node.func.id;\n\n        // @ts-ignore\n        const type = ctx.symtab.typedSymbols[name];\n        if( isInstance(type, FunctionType) ) {\n            ctx.w`${name}(`;\n            writeArgs(node, ctx);\n            ctx.w`)`;\n\n            return;\n        }\n    }\n\n    fallback(node, ctx);\n}","export const SHADOW_JS: Record<string, any> = {}\n\nexport default function shadowJS(value: string, ro: boolean = false) {\n    const prefix = ro ? \"RO\" : \"\"\n    return (cls: any) => (SHADOW_JS[prefix + value] = cls);\n}","import { SHADOW_JS } from \"../interface/shadowJS\";\n\nexport function getClass(o: unknown) {\n\n    const typename = typeof o;\n\n    if( typename === \"function\" ) {\n        //TODO: is class ? is something else ?\n        // @ts-ignore\n        return type;\n    }\n\n    if( typename === \"object\" ) {\n\n        // @ts-ignore\n        const klassname = o.constructor.name;\n\n        if( klassname in SHADOW_JS)\n            return SHADOW_JS[klassname];\n\n        if( Object.isFrozen(o) && `RO${klassname}` in SHADOW_JS)\n            return SHADOW_JS[`RO${klassname}`];\n\n        // @ts-ignore;\n        if( o.constructor === Error )\n            // @ts-ignore\n            return Exception;\n\n        // @ts-ignore;\n        return o.constructor;\n    }\n\n    // @ts-ignore\n    //TODO: remove globalThis[]\n    const lit_class = SHADOW_JS[typename];\n    if( lit_class !== undefined)\n        return lit_class;\n\n    throw new Error(`JS type ${typename} not implemented yet`);\n}","import { getClass } from \"../helpers/getClass\";\n\n// @ts-ignore\nconst NotImplemented = globalThis.NotImplemented = Symbol();\n\nexport default function op(a: unknown, op: string, b: unknown) {\n\n    const ka = getClass(a);\n    if( ka === undefined ) {\n        console.warn(a, op);\n        throw new Error(\"?\")\n    }\n\n    let result = NotImplemented;\n\n    let fct = ka.prototype[`__${op}__`];\n    if( fct !== undefined )\n        result = fct.call(a, b);\n\n    if( result !== NotImplemented)\n        return result;\n    \n    // iop\n    if( op[0] === \"i\" ) {\n\n        op = op.slice(1);\n        fct = ka.prototype[`__${op}__`];\n        \n        if( fct !== undefined)\n            result = fct.call(a, b)\n\n        if( result !== NotImplemented)\n            return result;\n    }\n\n    // try to reverse\n    const kb = getClass(b);\n    if( kb === undefined ) {\n        console.warn(b, \"r\" + op);\n        throw new Error(\"?\");\n    }\n\n    let rop;\n    if( op.length == 2 && op !== \"or\" ) // cmp\n        rop = cmp_reversed[op as keyof typeof cmp_reversed];\n    else\n        rop = `r${op}`;\n    \n    fct = kb.prototype[`__${rop}__`];\n    if( fct !== undefined )\n        result = fct.call(b, a);\n\n    if( result !== NotImplemented)\n        return result;\n\n    // fallbacks\n    if( op === \"eq\" ) return a === b;\n    if( op === \"ne\" ) return a !== b;\n    \n    throw new Error(`Operation not implemented ${ka.name} ${op} ${kb.name}`);\n}\n\nconst cmp_reversed = {\n    \"lt\": \"gt\",\n    \"gt\": \"lt\",\n    \"le\": \"ge\",\n    \"ge\": \"le\",\n    \"ne\": \"ne\",\n    \"eq\": \"eq\"\n}","export let KW: Record<string, any>|null = null;\n\nexport const IGNORE_ARG = Symbol();\n\nexport function setKW(args: Record<string, any>) {\n    KW = args;\n    return IGNORE_ARG;\n}\n\nexport function getKW() {\n    if( KW === null )\n        return {};\n    const args = KW;\n    KW = null;\n    return args;\n}","let _tmp: any = null;\n\nexport function saveTmp(v: any): any {\n    return _tmp = v;\n}\n\nexport function tmp(): any { // may reuse many time ?\n    return _tmp;\n}\n\nexport function getTmp(): any {\n    const tmp = _tmp;\n    _tmp = null\n    return tmp;\n}\n\nexport function withTmp(value: any): any {\n    _tmp = null;\n    return value;\n}\n\n/*\nexport function saveTmp(v: any): any {\n    return tmp = v;\n}\nexport function releaseTmp(v: any) {\n    tmp = null;\n    return v;\n}*/\n\n","// interface\nimport op     from \"./interface/op\";\nimport uop    from \"./interface/uop\";\nimport call   from \"./interface/call\";\nimport mcall  from \"./interface/mcall\";\nimport assert from \"./interface/assert\";\nimport getModule from \"./interface/getModule\";\nimport getModuleSync from \"./interface/getModuleSync\";\nimport { getTmp, saveTmp, tmp, withTmp } from \"./interface/tmp\";\nimport { getKW, setKW } from \"./interface/KW\";\nimport { getClass } from \"./helpers/getClass\";\nimport _in from \"./interface/in\";\nimport getitem from \"./interface/getitem\";\nimport setitem from \"./interface/setitem\";\nimport delitem from \"./interface/delitem\";\nimport getattr from \"./interface/getattr\";\nimport delattr from \"./interface/delattr\";\nimport setattr from \"./interface/setattr\";\nimport shadowJS from \"./interface/shadowJS\";\nimport ro from \"./interface/ro\";\n\n// @ts-ignore\nconst $RB = globalThis.$RB = {\n    // interface\n    op,\n    uop,\n    call,\n    mcall,\n    assert,\n    getitem,\n    setitem,\n    delitem,\n    getattr,\n    setattr,\n    delattr,\n    getKW,\n    setKW,\n    tmp,\n    getTmp,\n    saveTmp,\n    withTmp,\n    getModule,\n    getModuleSync,\n    getClass,\n    in: _in,\n    shadowJS,\n    ro\n}\nexport {$RB};\n\n// =====================================================\n\n//TODO: as macro...\nexport const IVALUE = Symbol();\n\n// @ts-ignore\nglobalThis.__JS_SET_IVALUE__ = (self, v) => self[IVALUE] = v;\n// @ts-ignore\nglobalThis.__JS_GET_IVALUE__ = (self) => self[IVALUE];","import { getClass } from \"../helpers/getClass\";\n\nexport default function uop(op:string, a: unknown) {\n\n    const ka = getClass(a);\n\n    if( ka === undefined ) {\n        console.warn(a, op);\n        throw new Error(\"?\")\n    }\n\n    let fct = ka.prototype[`__${op}__`];\n    if( fct === undefined) {\n        console.warn(a, ka);\n        throw new Error(`__${op}__ not defined`);\n    }\n    return fct.call(a);\n}","import { getClass } from \"../helpers/getClass\";\nimport isClass from \"../helpers/isClass\";\nimport { IGNORE_ARG } from \"./KW\";\n\nexport default function call(a: (...args:unknown[]) => unknown, ...args: unknown[]) {\n\n    if( args[args.length-1] === IGNORE_ARG)\n        args = args.slice(0,-1);\n\n    // @ts-ignore\n    let fct = a.__call__\n\n    if( fct === undefined ) {\n        fct = a;\n\n        // h4cky\n        if( fct.prototype?.__new__ !== undefined ) {\n            const b = getClass(fct).prototype.__call__;\n            if( b !== undefined) {\n                return b.call(fct, ...args);\n            }\n        }\n\n        if( isClass(fct) ) // only for JS classes now...\n            return new fct(...args);\n    }\n\n    return fct(...args);\n}\n","export default function isClass(o: unknown) {\n\n    if( o === Symbol)\n        return false;\n    \n    // from https://stackoverflow.com/questions/526559/testing-if-something-is-a-class-in-javascript\n    return Object.getOwnPropertyDescriptors(o)?.prototype?.writable === false;\n\n}\n// + https://github.com/brython-dev/brython/issues/2513","import { IGNORE_ARG } from \"./KW\";\n\nexport default function mcall(o: unknown, name: string, ...args: unknown[]) {\n    \n    if( args[args.length-1] === IGNORE_ARG)\n        args = args.slice(0,-1);\n    \n    // @ts-ignore\n    let fct = o[name];\n    if( fct === undefined) {\n        // @ts-ignore\n        if( o.prototype[name] === undefined) {\n            // @ts-ignore\n            console.warn(o, o.name, name);\n        }\n        // @ts-ignore\n        return o.prototype[name].call(...args);\n    }\n\n    // @ts-ignore\n    return o[name](...args);\n}","export default function assert(cond: boolean, msg: string = \"\") {\n    if( ! cond )\n        throw new Error(`Assertion failed: ${msg}`);\n}","import { getClass } from \"../helpers/getClass\";\n\nexport default function getitem(o: any, key: any) {\n    return getClass(o).prototype.__getitem__.call(o, key);\n}","import { getClass } from \"../helpers/getClass\";\n\nexport default function getitem(o: any, key: any, v: any) {\n    return getClass(o).prototype.__setitem__.call(o, key, v);\n}","import { getClass } from \"../helpers/getClass\";\n\nexport default function delitem(o: any, key: any) {\n    return getClass(o).prototype.__delitem__.call(o, key);\n}","import { getClass } from \"../helpers/getClass\";\n\nexport default function getattr(o: any, key: any) {\n    /*\n    if( ! (attr in o) )\n        return o.constructor[attr];\n    return o[attr];\n    */\n    return getClass(o).prototype.__getattr__.call(o, key);\n}","import { getClass } from \"../helpers/getClass\";\n\nexport default function setattr(o: any, key: any, v: any) {\n    return getClass(o).prototype.__setattr__.call(o, key, v);\n}","import { getClass } from \"../helpers/getClass\";\n\nexport default function delattr(o: any, key: any) {\n    return getClass(o).prototype.__delattr__.call(o, key);\n}","import { modules } from \"@RBrython/rbry/runners/RBrythonGlobalRunner\";\n\nexport default async function getModule(name: string) {\n\n    // h4ck\n    const module = modules[name];\n    if( module !== undefined )\n        return module;\n\n    if( name in globalThis)\n        return modules[name] = globalThis[name as keyof typeof globalThis];\n\n    // TODO...\n    if( \"__BRYTHON__\" in globalThis) {\n        // @ts-ignore\n        if( name in __BRYTHON__.imported)\n            // @ts-ignore\n            return modules[name] = __BRYTHON__.pyobj2jsob(__BRYTHON__.imported[name]);\n    }\n    \n    throw new Error(`module ${name} not found`);\n}\n    ","import { modules } from \"@RBrython/rbry/runners/RBrythonGlobalRunner\";\n\nexport default function getModuleSync(name: string) {\n\n    // h4ck\n    const module = modules[name];\n    if( module !== undefined )\n        return module;\n\n    if( name in globalThis)\n        return modules[name] = globalThis[name as keyof typeof globalThis];\n\n    // TODO...\n    if( \"__BRYTHON__\" in globalThis) {\n        // @ts-ignore\n        if( name in __BRYTHON__.imported)\n            // @ts-ignore\n            return modules[name] = __BRYTHON__.pyobj2jsob(__BRYTHON__.imported[name]);\n    }\n    \n    throw new Error(`module ${name} not found`);\n}\n    ","import { getClass } from \"../helpers/getClass\";\n\nexport default function _in(e: any, c: any) {\n\n    const kc = getClass(c);\n    if( kc === undefined ) {\n        console.warn(c);\n        throw new Error(\"?\")\n    }\n\n    let fct = kc.prototype[\"__contains__\"];\n    if( fct !== undefined )\n        return fct.call(c, e);\n\n    fct = kc.prototype[Symbol.iterator] //kc.prototype[\"__iter__\"];\n    if( fct !== undefined ) {\n        for( let elem of fct.call(c) )\n            // @ts-ignore\n            if( $RB.op(elem, \"eq\", e) )\n                return true;\n        return false;\n    }\n\n    throw new Error(\"Not implemented\");\n    //TODO: getitem...\n\n}","export default function ro(o: any) {\n    return Object.freeze(o);\n}","import { EmitContext } from \"@RBrython/rbry/emitter/EmitContext\";\nimport { HMacro } from \"../..\";\nimport { ASTNode } from \"@RBrython/rbry/ast/types\";\nimport { isSimple } from \"./saveTmp\";\n\nexport default function tmp(fallback: HMacro, node: ASTNode) {\n\n    if( isSimple(node) )\n        return (ctx: EmitContext) => ctx.w_node(node);\n\n    return fallback(node);\n}","import { YieldNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Yield(node: YieldNode, ctx: EmitContext) {\n    ctx.w`yield ${node.value}`;\n}","import { ASTNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"@RBrython/rbry/emitter/EmitContext\";\nimport { HMacro } from \"../..\";\nimport { isSimple } from \"./saveTmp\";\n\nexport default function withTmp(fallback: HMacro, node: ASTNode) {\n\n    if( isSimple(node) )\n        return (_: EmitContext) => {};\n\n    return fallback(node);\n}","import { CompareNode } from \"@RBrython/rbry/ast/types\";\nimport { TypedEntry } from \"../../Walker\";\nimport { BoolType } from \"../../types\";\n\nexport default function Compare(entry: TypedEntry<CompareNode>) {\n    entry.node.result_type = { type: BoolType }\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { ParsedCode } from \"../ast/types\";\nimport { EmitterOptions } from \"../emitter\";\nimport { Macro } from \"../emitter/EmitContext\";\nimport { PyModule } from \"../runners/interface\";\n\nexport default abstract class Engine {\n    abstract run(pycode: string, opts?: Omit<EmitterOptions, \"target\">): Promise<PyModule>\n    abstract runSync(pycode: string, opts?: Omit<EmitterOptions, \"target\">): PyModule;\n\n    abstract registerModule(name: string, symbols: string|PyModule): Promise<void>;\n    abstract registerModuleSync(name: string, symbols: string|PyModule): void;\n    abstract      getModule(name: string): PyModule;\n\n    abstract registerBuiltins(symbols: string|PyModule): void;\n    abstract registerBuiltin(name: string, value: any): void;\n    \n    abstract registerMacros(macros: Record<string, Macro>):void;\n    abstract registerMacro(name: string, fct: Macro): void;\n\n    // low level\n    abstract parse(pycode: string): ParsedCode;\n    abstract emit (parsed: ParsedCode, opts?: Partial<EmitterOptions>): string;\n    \n    abstract loadAsFunction(jscode: string): (runlib: any) => Promise<PyModule>;\n    abstract runFunction(fct: (runlib: any) => Promise<PyModule>): Promise<PyModule>;\n\n    abstract loadAsSyncFunction(jscode: string): (runlib: any) => PyModule;\n    abstract runSyncFunction(fct: (runlib: any) => PyModule): PyModule;\n}","// list is filled in list.ts in order to prevent circular dependency.\n\nimport { ASTNode } from \"../../ast/types\";\nimport { EmitContext } from \"../EmitContext\";\n\nexport type Handler = (    node: ASTNode,\n                            ctx: EmitContext) => void;\n\nexport type Handlers = Record<string, Handler>;\n\nconst handlers: Handlers = {};\n\nexport default handlers;","import { ASTNode, ClassDefNode, SymTab } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nconst hacked = [\"number\", \"bigint\", \"boolean\", \"string\", \"obj\", \"ROArray\", \"Array\"]\n\nexport default function ClassDef(node: ClassDefNode, ctx: EmitContext) {\n\n    const name = node.name;\n    const body = node.body;\n\n    // JS cstr\n    ctx.w`var ${name} = `;\n\n    for(let i = 0; i < node.decorator_list.length; ++i) {\n        ctx.w_node(node.decorator_list[i]);\n        ctx.w_str(\"(\");\n    }\n    \n    ctx.w`(() =>{${ctx.hm.BB()}`\n        ctx.w`function ${name}(...args) {${ctx.hm.BB()}`\n            ctx.w`return type.prototype.__call__.call(${name}, ...args)`;\n            //ctx.w`return Object.create(${name}.prototype);`\n        ctx.w`${ctx.hm.BE()}}${ctx.hm.NL()}`\n\n    // inheritance\n    let bases: (ASTNode|string)[] = node.bases;\n\n    // @ts-ignore\n    const isH4ck = bases.length >= 1 && hacked.includes(bases[0].id);\n\n    if( isH4ck )\n        bases = bases.slice(1);\n\n    if( bases.length === 0 )\n        bases = [\"object\"];\n\n    // avoid auto-inheritance.\n    if( name !== \"object\" ) {\n        ctx.w`${name}.prototype = Object.create(${bases[0]}.prototype);${ctx.hm.NL()}`;\n\n        for(let i = 1; i < bases.length; ++i) {\n            ctx.w`Object.assign(${name}.prototype, ${bases[i]}.prototype);${ctx.hm.NL()}`;\n        }\n    \n        ctx.w`${name}.prototype.constructor = ${name};`;\n    }\n\n    ctx.w`${ctx.hm.BE()}`;\n\n    // body...\n    ctx.w_body(body);\n\n    ctx.w`${ctx.hm.BB()}return ${name};${ctx.hm.BE()}})()`;\n\n\n    for(let i = 0; i < node.decorator_list.length; ++i)\n        ctx.w_str(\")\");\n}","import { nodeType } from \"@RBrython/rbry/ast\";\nimport { ASTNode, BodyNode, FunctionDefNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nfunction hasYield(body: BodyNode) {\n\n    const stack: ASTNode[] = [...body];\n\n    let elem;\n    while( elem = stack.pop() ) {\n\n        if( nodeType(elem) === \"Expr\" )\n            // @ts-ignore\n            elem = elem.value;\n\n        if( nodeType(elem) === \"Yield\" || nodeType(elem) === \"YieldFrom\" )\n            return true;\n\n        // can only be in a body.\n        if( \"body\" in elem)\n            // @ts-ignore\n            stack.push(...elem.body);\n    }\n\n    return false;\n}\n\nexport default function FunctionDef(node: FunctionDefNode, ctx: EmitContext) {\n\n    const isMethod = ctx.isMethod();\n\n    const name = node.name;\n    const body = node.body;\n\n    const genSym = hasYield(body) ? \"*\" : \"\";\n\n    if( isMethod ) {\n        ctx.w`${ctx.getName(-1)}.prototype.${name} = `;\n        if( name === \"__iter__\")\n            ctx.w`${ctx.getName(-1)}.prototype[Symbol.iterator] = `;\n    }\n\n    // open decorator\n    for( let i = 0; i < node.decorator_list.length ; ++i )\n        ctx.w`${node.decorator_list[i]}(`;\n\n    ctx.w`function ${genSym}${name} ${node.args}`;\n\n    // start of the function/lambda is included in the arguments...\n\n    ctx.w_body(body);\n    ctx.w`}`;\n\n    // close decorator\n    for( let i = 0; i < node.decorator_list.length ; ++i )\n        ctx.w`)`;\n}","import { LambdaDefNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Lambda(node: LambdaDefNode, ctx: EmitContext){\n    ctx.w`function ${node.args} return ${node.body}}`; // shouldn't have many lines...\n}","import { ArgsDefNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\n//TODO: vararg + kw => dans le corps...\nexport default function Arguments(node: ArgsDefNode, ctx: EmitContext) {\n    \n    ctx.w`(`;\n\n    // if method => ignore first parameter...\n    let pos_offset = 0;\n    let arg_offset = 0;\n\n    const isMethod = ctx.isMethod();\n\n    if( isMethod ) {\n        if( node.posonlyargs.length)\n            ++pos_offset\n        else\n            ++arg_offset;\n    }\n\n    let d_idx = node.posonlyargs.length + node.args.length - node.defaults.length;\n\n    for(let i = pos_offset; i < node.posonlyargs.length; ++i) {\n        ctx.w`${node.posonlyargs[i].arg}`;\n        if( d_idx >= i)\n            ctx.w` = ${node.defaults[i - d_idx]}`;\n        ctx.w`,`;\n    }\n\n    d_idx -= node.posonlyargs.length;\n    for(let i = arg_offset; i < node.args.length; ++i) {\n        ctx.w`_${node.args[i].arg}`;\n        if( i >= d_idx)\n            ctx.w` = ${node.defaults[node.posonlyargs.length + i - d_idx]}`;\n        ctx.w`,`;\n    }\n\n    const hasVararg = node.vararg !== undefined\n\n    if( hasVararg )\n        ctx.w`...${node.vararg!.arg}`;\n\n    const hasKW = (node.args.length - arg_offset)\n                || node.kwarg !== undefined\n                || node.kwonlyargs.length;\n\n    if( hasKW && ! hasVararg)\n        writeKW(node, ctx, arg_offset);\n\n    // we also include the start of the function/lambda...\n\n    ctx.w`){`;\n\n    if( hasKW && hasVararg ) {\n        ctx.w`${ctx.hm.BB()}var `;\n        writeKW(node, ctx, arg_offset);\n        ctx.w`;${ctx.hm.BE()}`;\n    }\n\n    if( hasVararg ) {\n        ctx.w`${ctx.hm.BB()}${node.vararg!.arg} = $RB.ro(${node.vararg!.arg});${ctx.hm.BE()}`;\n    }\n\n    //TODO: prefer var renaming...\n    if( isMethod ) {\n        let selfname = \"\";\n        if( node.posonlyargs.length > 0)\n            selfname = node.posonlyargs[0].arg;\n        else\n            selfname = node.args[0].arg;\n        ctx.w`${ctx.hm.BB()}const ${selfname} = this;${ctx.hm.BE()}`;\n    }\n}\n\nfunction writeKW(node: ArgsDefNode, ctx: EmitContext, arg_offset: number) {\n\n    // kw...\n    ctx.w`{`;\n    \n    // pos\n    for( let i = arg_offset ; i < node.args.length; ++i)\n        ctx.w`${node.args[i].arg} = _${node.args[i].arg}, `;\n\n    // kw\n    for(let i = 0; i < node.kwonlyargs.length; ++i) {\n        ctx.w`${node.kwonlyargs[i].arg}`;\n        if( node.kw_defaults[i] !== undefined)\n            ctx.w` = ${node.kw_defaults[i]}`\n        ctx.w`, `\n    }\n\n    // **\n    if( node.kwarg !== undefined )\n        ctx.w`...${node.kwarg.arg}`;\n\n    ctx.w`} = $RB.getKW()`;\n}","export default function Global() {\n    ;\n}","export default function Nonlocal() {\n    ;\n}","import { SubscriptNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Subscript(node: SubscriptNode, ctx: EmitContext) {\n    ctx.w`$RB.getitem(${node.value}, ${node.slice})`;\n}","import { MODE } from \"../..\";\nimport { AssertNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Assert(node: AssertNode, ctx: EmitContext) {\n\n    if( ctx.mode === MODE.PROD )\n        return;\n\n    ctx.w`$RB.assert( ${ctx.hm.bool(node.test)}, ${node.msg ?? \"\"})`;\n}","import { PassNode } from \"../../../ast/types\";\n\nexport default function Pass(node: PassNode) {\n    return;\n}","import { ReturnNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Return(node: ReturnNode, ctx: EmitContext) {\n    ctx.w`return ${node.value}`;\n}","export const FUNCTION = 0;\nexport const CLASS    = 1;\nexport const BODY     = 1;\n\nexport type SymTab = {\n    name    : string;\n    children: SymTab[];\n    symbols : {\n        $strings: Record<string, number>\n    }\n    type: typeof FUNCTION|typeof CLASS|typeof BODY;\n};\n\nexport type ParsedCode = {\n    filename: string,\n    pycode  : string,\n    ast     : ModuleNode,\n    symtable: SymTab,\n};\n\nexport type ASTNode<T={}> = {\n    js_start?: number,\n    js_end  ?: number\n} & T;\n\nexport type BodyNode = ASTNode[];\n\nexport type ModuleNode = ASTNode<{\n    body: BodyNode\n}>;\n\nexport type ExprNode = ASTNode<{\n    value: ASTNode\n}>\n\nexport type ConstantNode = ASTNode<{\n    value: number|string|boolean|{value: number|bigint}\n}>\nexport type StringNode = ASTNode<{\n    value: string;\n}>\n\nexport type AssertNode = ASTNode<{\n    test : ASTNode\n    msg ?: string\n}>\n\nexport type OperatorNode = unknown; // better to shadow it...\n\nexport type UnaryOpNode = ASTNode<{\n    operand: ASTNode;\n    op     : OperatorNode; \n}>\n\nexport type BinaryOpNode = ASTNode<{\n    left : ASTNode;\n    right: ASTNode;\n    op   : OperatorNode;\n}>\nexport type BoolOpNode = ASTNode<{\n    op: OperatorNode;\n    values: [ASTNode, ASTNode]\n}>\n\nexport type CompareNode = ASTNode<{\n    left       : ASTNode;\n    ops        : OperatorNode[];\n    comparators: ASTNode[];\n}>\n\nexport type NameNode = ASTNode<{\n    id: string;\n}>\n\nexport type AssignNode = ASTNode<{\n    value  : ASTNode;\n    targets: ASTNode[];\n}>\n\nexport type AugAssignNode = ASTNode<{\n    target : ASTNode;\n    value  : ASTNode;\n    op     : OperatorNode;\n}>\n\n\nexport type ReturnNode = ASTNode<{\n    value  : ASTNode;\n}>\n\nexport type PassNode = ASTNode<{}>\n\nexport type AttributeNode = ASTNode<{\n    value: ASTNode;\n    attr : string;\n}>\n\nexport type CallNode = ASTNode<{\n    func    : ASTNode\n    args    : ASTNode[],\n    keywords: {arg: string, value: ASTNode}[]\n}>\n\ntype Generator = {\n    iter  : ASTNode,\n    target: ASTNode,\n    ifs   : ASTNode[]\n};\n\nexport type GeneratorExpNode = ASTNode<{\n    elt: ASTNode,\n    generators: Generator[]\n}>\n\nexport type ListCompNode = GeneratorExpNode;\n\nexport type DictCompNode = ASTNode<{\n    key  : ASTNode,\n    value: ASTNode,\n    generators: Generator[]\n}>;\n\nexport type TupleNode = ASTNode<{\n    elts: ASTNode[]\n}>\n\nexport type ListNode = TupleNode;\n\nexport type DictNode = ASTNode<{\n    keys  : ASTNode[],\n    values: ASTNode[]\n}>\n\n\nexport type ClassDefNode = ASTNode<{\n    name: string;\n    body: BodyNode;\n    bases: ASTNode[];\n    decorator_list: ASTNode[];\n}>\n\nexport type ArgsDefNode = ASTNode<{\n    posonlyargs: ArgDefNode[];\n    args       : ArgDefNode[];\n    vararg    ?: ArgDefNode;\n    kwonlyargs : ArgDefNode[];\n    kwarg     ?: ArgDefNode;\n\n    defaults   : ASTNode[];\n    kw_defaults: ASTNode[];\n}>\n\nexport type ArgDefNode = ASTNode<{\n    arg: string\n}>\n\nexport type LambdaDefNode = ASTNode<{\n    args: ArgsDefNode;\n    body: BodyNode;\n}>\n\nexport type FunctionDefNode = ASTNode<{\n    name: string;\n    posonlyargs: ASTNode[];\n    args: ArgsDefNode;\n    body: BodyNode;\n    decorator_list: ASTNode[]\n}>\n\nexport type IfNode = ASTNode<{\n    test: ASTNode;\n    body: BodyNode;\n    orelse: ASTNode[];\n}>\n\n\nexport type IfExpNode = ASTNode<{\n    test  : ASTNode;\n    body  : ASTNode;\n    orelse: ASTNode;\n}>\n\nexport type WhileNode = ASTNode<{\n    test: ASTNode;\n    body: BodyNode;\n    //TODO: orelse\n}>\n\nexport type ForNode = ASTNode<{\n    target: ASTNode;\n    iter  : ASTNode;\n    body  : BodyNode;\n    //TODO: orelse\n}>\n\nexport type YieldNode = ASTNode<{\n    value : ASTNode\n}>\n\nexport type NamedExprNode = ASTNode<{\n    target: ASTNode,\n    value : ASTNode\n}>\n\nexport type RaiseNode = ASTNode<{\n    exc: ASTNode;\n}>\n\nexport type TryNode = ASTNode<{\n    body: BodyNode;\n    finalbody: BodyNode;\n    handlers: {body: BodyNode, type?: ASTNode, name?:string}[];\n}>\n\nexport type DeleteNode = ASTNode<{\n    targets: ASTNode[];\n}>\n\nexport type WithNode = ASTNode<{\n    body: BodyNode,\n    items: {\n        context_expr  : ASTNode,\n        optional_vars?: ASTNode,\n    }[]\n}>\n\nexport type FormattedValueNode = ASTNode<{\n    value: ASTNode,\n    format_spec?: {\n        values: StringNode[]\n    }\n}>;\n\nexport type JoinedStrNode = ASTNode<{\n    values: (FormattedValueNode|StringNode)[]\n}>\n\nexport type MatchNode = ASTNode<{\n    subject: ASTNode,\n    cases  : {\n        pattern: {\n            cls: {\n                id: string\n            }\n        }\n        body: BodyNode\n    }[]\n}>\n\nexport type ImportNode = ASTNode<{\n    names: {name: string, asname?: string}[]\n}>\n\nexport type ImportFromNode = ASTNode<{\n    module: string\n    names: {name: string, asname?: string}[]\n}>\n\nexport type SubscriptNode = ASTNode<{\n    value: ASTNode,\n    slice: ASTNode\n}>\n\nexport type AwaitNode = ASTNode<{\n    value: ASTNode\n}>","import { MODE } from \".\";\nimport { isASTNode, nodeType } from \"../ast\";\nimport { ASTNode, CLASS, ClassDefNode, FUNCTION, FunctionDefNode, SymTab } from \"../ast/types\";\nimport { HMacros } from \"../optimizers\";\nimport { Handlers } from \"./handlers\";\nimport hmacros from \"./hmacros/list\";\n\nexport type Macro = (ctx: EmitContext, ...args: ASTNode[]) => void;\n\nexport const LOCAL_VAR = 0x1000;\n\ntype EmitContextOpts = {\n    opti: {\n        handlers: Handlers,\n        hmacros : HMacros\n    }\n    mode: MODE,\n    sync: boolean\n}\n\nexport class EmitContext {\n\n    readonly macros : Record<string, Macro> = {};\n    readonly hm     : typeof hmacros;\n    readonly mode;\n    readonly sync;\n\n    readonly handlers;\n\n    jscode: string = \"\";\n\n    #symtabs;\n    constructor({\n                    opti: {\n                        handlers,\n                        hmacros,\n                    },\n                    mode,\n                    sync,\n                }: EmitContextOpts,\n                \n                macros  : Record<string, Macro>,\n                symtab  : SymTab) {\n\n        this.handlers = handlers;\n        this.#symtabs = [symtab];\n        this.mode     = mode;\n        this.macros   = macros;\n        this.hm       = hmacros as any;\n        this.sync     = sync;\n    }\n\n    getScope(name: string) {\n        return this.symtab.symbols.$strings[name];\n    }\n\n    // a little h4cky\n    getName(idx = 0) {\n        return this.#symtabs[this.#symtabs.length-1+idx].name;\n    }\n    isTopLevel() {\n        return this.#symtabs.length === 1;\n    }\n    isMethod() {\n        const last = this.#symtabs.length-1;\n\n        if( this.#symtabs[last].type !== FUNCTION )\n            return false;\n\n        return this.#symtabs[last-1].type === CLASS;\n    }\n\n    get symtab() { return this.#symtabs[this.#symtabs.length-1]; }\n\n    w(strings: TemplateStringsArray, ...exprs: any[]) {\n\n        for(let i = 0; i < exprs.length; ++i) {\n            this.w_str(strings[i]);\n\n            const e = exprs[i];\n            if( typeof e === \"function\") // HMacro\n                e(this);\n            else if( isASTNode(e) )\n                this.w_node(e)\n            else if( Array.isArray(e) )\n                this.w_body(e);\n            else\n                this.jscode += `${e}`;\n        }\n\n        this.w_str(strings[strings.length-1]);\n    }\n\n    w_str(str: string) {\n        //if( str.includes(\"\\n\") )\n        //    throw new Error(\"Break line !\");\n        return this.jscode += str;\n    }\n\n    indent_level = 0;\n\n    w_line() {\n        const nl = \"\\n\" + \"  \".repeat(this.indent_level);\n        if( ! this.jscode.endsWith(nl) )\n            this.jscode += nl;\n    }\n\n    w_body(nodes: ASTNode[]) {\n\n        if( nodes.length === 0)\n            return;\n\n        if( nodes.length === 1 && nodeType(nodes[0]) === \"Pass\")\n            return;\n\n        ++this.indent_level;\n\n        for(let i = 0; i < nodes.length; ++i) {\n            this.w_line();\n            this.w_node(nodes[i]);\n            this.w_str(\";\");\n        }\n        --this.indent_level;\n        this.w_line();\n    }\n\n    w_node(node: ASTNode) {\n\n        const type = nodeType(node);\n\n        const handler = this.handlers[type];\n        if( handler === undefined) {\n            console.warn(node);\n            throw new Error(`Node type ${nodeType(node)} is unknown`);\n        }\n\n        const hasNewContext = type === \"FunctionDef\" || type === \"ClassDef\";\n\n        if( hasNewContext )\n            this.enter( (node as ClassDefNode|FunctionDefNode).name);\n\n        node.js_start = this.jscode.length;\n        handler(node, this);\n        node.js_end   = this.jscode.length;\n\n        if( hasNewContext )\n            this.leave();\n    }\n\n    // enter/leave.\n\n    protected enter(name: string): SymTab {\n        const symtab = this.symtab.children.find( (l) => l.name === name)!;\n        this.#symtabs.push(symtab)\n        return symtab;\n    }\n    protected leave() {\n        this.#symtabs.pop();\n    }\n}","import { nodeType } from \"@RBrython/rbry/ast\";\nimport { AssignNode, AttributeNode, SubscriptNode } from \"../../../ast/types\";\nimport { EmitContext, LOCAL_VAR } from \"../../EmitContext\";\n\nexport default function Assign(node: AssignNode, ctx: EmitContext) {\n\n    const type = nodeType(node.targets[0]);\n    if( type === \"Attribute\" ) {\n        const attr = node.targets[0] as AttributeNode;\n        ctx.w`$RB.setattr(${attr.value}, \"${attr.attr}\", ${node.value})`;\n        return;\n    }\n    if( type === \"Subscript\") {\n        const snode = node.targets[0] as SubscriptNode;\n        ctx.w`$RB.setitem(${snode.value}, ${snode.slice}, ${node.value})`;\n        return;\n    }\n\n    for(let i = 1; i < node.targets.length; ++i)\n        // @ts-ignore\n        if( ctx.getScope(node.targets[i].id) & LOCAL_VAR || ctx.isTopLevel() )\n            ctx.w`var ${node.targets[i]};`;\n\n    // @ts-ignore\n    if( ctx.getScope(node.targets[0].id) & LOCAL_VAR || ctx.isTopLevel() )\n        ctx.w`var `;\n\n    for(let i = 0; i < node.targets.length; ++i)\n        ctx.w`${node.targets[i]} = `;\n\n    return ctx.w_node(node.value);\n}","import { AttributeNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function (node: AttributeNode, ctx: EmitContext) {\n    ctx.w`$RB.getattr(${node.value}, \"${node.attr}\")`;\n}","import { getOp } from \"../../../ast/\";\nimport { BinaryOpNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function(node: BinaryOpNode, ctx: EmitContext) {\n    const a = node.left;\n    const b = node.right;\n    const op = getOp(node.op) as keyof typeof binops;\n\n    const opname = binops[op];\n    if( opname === undefined) \n        throw new Error(`BinOp ${op} not impl`);\n\n    ctx.w`$RB.op(${a}, \"${opname}\", ${b})`;\n}\n\nexport const binops = {\n    Add : \"add\",\n    Sub : \"sub\",\n    Mult: \"mul\",\n    Div : \"truediv\",\n    FloorDiv: \"floordiv\",\n    Pow : \"pow\",\n    Mod : \"mod\",\n    // bits\n    BitOr: \"or\",\n    BitAnd: \"and\",\n    BitXor: \"xor\",\n    LShift: \"lshift\",\n    RShift: \"rshift\"\n}","import { AugAssignNode } from \"../../../ast/types\";\nimport { binops } from \"./BinOp\";\nimport { getOp } from \"../../../ast/\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function AugAssign(node: AugAssignNode, ctx: EmitContext) {\n \n    const a  = node.target;\n    const op = getOp(node.op) as keyof typeof binops;\n    const b  = node.value;\n\n    const opname = binops[op];\n    if( opname === undefined) \n        throw new Error(`BinOp ${op} not impl`);\n\n    ctx.w`${a} = $RB.op(${a}, \"i${opname}\", ${b})`;   \n}","import { CompareNode } from \"../../../ast/types\";\nimport { getOp } from \"../../../ast/\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Compare(node: CompareNode, ctx: EmitContext) {\n\n    let prev = node.left;\n    for(let i = 0; i < node.ops.length; ++i) {\n\n        const isFirst = i === 0;\n        const isLast  = i === node.ops.length - 1\n\n        let op = getOp(node.ops[i]) as keyof typeof cmpops | \"Is\" | \"IsNot\" | \"NotIn\";\n\n        let a: any = prev;\n        if( ! isFirst )\n            a = ctx.hm.getTmp(prev);\n\n        let b: any = prev = node.comparators[i];\n        if( ! isLast )\n            b = ctx.hm.saveTmp(b);\n\n        if(! isFirst)\n            ctx.w` && `;\n\n        // TODO: if has next... (saveTmp())\n        // TODO: if has prev... (getTmp())\n\n        if( op === 'Is' ) {\n            ctx.w`${a} === ${b}`;\n            continue;\n        }\n        if( op === 'IsNot' ) {\n            ctx.w`${a} !== ${b}`;\n            continue;\n        }\n        if( op === \"NotIn\") {\n            ctx.w_str(\"!\");\n            op = \"In\";\n        }\n        if( op === \"In\") {\n            ctx.w`$RB.in(${a}, ${b})`\n            continue;\n        }\n        \n        const opname = cmpops[op];\n        if( opname === undefined) {\n            console.warn(op);\n            throw new Error(`CmpOp ${op} not impl`);\n        }\n\n        ctx.w`$RB.op(${a}, \"${opname}\", ${b})`;\n    }\n}\n\nconst cmpops = {\n    Eq   : \"eq\",\n    NotEq: \"ne\",\n    Gt   : \"gt\",\n    GtE  : \"ge\",\n    Lt   : \"lt\",\n    LtE  : \"le\",\n    In   : \"contains\"\n}\n","import { UnaryOpNode } from \"../../../ast/types\";\nimport { getOp } from \"../../../ast/\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function(node: UnaryOpNode, ctx: EmitContext) {\n\n    const a = node.operand;\n    const op = getOp(node.op) as keyof typeof uops | \"Not\";\n\n    if( op === \"Not\") {\n        ctx.w`! ${ctx.hm.bool(a)}`;\n        return;\n    }\n\n    const opname = uops[op];\n    if( opname === undefined) \n        throw new Error(`UnaryOp ${op} not impl`);\n\n    ctx.w`$RB.uop(\"${opname}\", ${a})`;\n}\n\nconst uops = {\n    Invert: \"invert\",\n    USub  : \"neg\",\n    UAdd  : \"pos\",\n}","import { ConstantNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Constant(node: ConstantNode, ctx: EmitContext) {\n\n        const type = typeof node.value;\n\n        if( type === \"object\") {\n            // @ts-ignore\n            const qname = node.value.__class__.__qualname__\n            // @ts-ignore\n            const value: float|bigint = node.value.value;\n\n            if( qname === \"float\"   ) return ctx.w`${value}`;\n            if( qname === \"int\"     ) return ctx.w`${value}n`;\n            if( qname === \"NoneType\") return ctx.w`null`;\n            //if( qname === \"ellipsis\") return \"$RB.ellipsis\";\n        }\n        if( type === \"string\" ) return ctx.w`\"${node.value}\"`;\n        if( type === \"number\" ) return ctx.w`${node.value}n`; // bigint\n        if( type === \"boolean\") return ctx.w`${node.value}`;\n\n        console.warn(node, type);\n        throw new Error(`Unknown Cste ${type}`);\n}","import { ExprNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Expr(node: ExprNode, ctx: EmitContext) {\n    ctx.w_node(node.value);\n}","import { MODE } from \"../..\";\nimport { NameNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Name(node: NameNode, ctx: EmitContext) {\n\n    // h4ck\n    if( node.id === \"__debug__\") {\n        ctx.w`${ctx.mode === MODE.DEBUG}`;\n        return;\n    }\n\n    ctx.w_str(node.id);\n}","import { nodeType } from \"../../../ast/\";\nimport { FormattedValueNode, JoinedStrNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function JoinedStr(node: JoinedStrNode, ctx: EmitContext) {\n\n    ctx.w_str(\"`\");\n    for(let i = 0; i < node.values.length; ++i) {\n        const value = node.values[i];\n        const type  = nodeType(value);\n\n        if( type === \"Constant\") {\n            ctx.w_str(value.value as string);\n            continue;\n        }\n\n        const val = value as FormattedValueNode;\n\n        if( val.format_spec === undefined ) {\n            ctx.w`\\${${value.value}}`;\n            continue;\n        }\n\n        ctx.w`\\${format(${value.value}, ${val.format_spec.values[0]})}`;\n    }\n    ctx.w_str(\"`\");\n}","import { IfNode } from \"../../../ast/types\";\nimport { nodeType } from \"../../../ast/\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function If(node: IfNode, ctx: EmitContext) {\n\n    ctx.w`if( ${ctx.hm.bool(node.test)} ){${node.body}}`;\n\n    for(let i = 0; i < node.orelse.length; ++i) {\n        const snode = node.orelse[i];\n        const type = nodeType(snode);\n\n        if( type === \"If\")\n            ctx.w`else ${snode}`;  // if node (else is prefix)\n        else\n            ctx.w`else{${snode}}`; // a body I guess ?\n    }\n}","import { WhileNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function While(node: WhileNode, ctx: EmitContext) {\n    ctx.w`while( ${ctx.hm.bool(node.test)} ){${node.body}}`;\n}","\nimport { ForNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function For(node: ForNode, ctx: EmitContext) {\n    ctx.w`for(var ${node.target} of ${node.iter}){${node.body}}`;\n}","import { TryNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Try(node: TryNode, ctx: EmitContext) {\n\n    ctx.w`try{${node.body}}`;\n\n    if( node.handlers.length > 0) {\n        ctx.w`catch(_e_){${ctx.hm.BB()}`\n\n        for(let i = 0; i < node.handlers.length; ++i) {\n\n            // TODO: as cond.\n            const except = node.handlers[i];\n\n            if( i !== 0)\n                ctx.w`else `;\n            if( except.type !== undefined)\n                ctx.w`if( isinstance(_e_, ${except.type}) )`;\n\n            ctx.w`{`;\n\n                if( except.name !== undefined)\n                    ctx.w`${ctx.hm.BB()}var ${except.name} = _e_;${ctx.hm.BE()}`\n                ctx.w_body(except.body);\n            \n            ctx.w`}`;\n\n\n        }\n    \n        ctx.w`${ctx.hm.BE()}}`;\n    }\n\n    if( node.finalbody.length > 0)\n        ctx.w`finally{${node.finalbody}}`;\n}","import { MatchNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Match(node: MatchNode, ctx: EmitContext) {\n\n    ctx.w`{${ctx.hm.BB()}`; // we want a special scope for the match.\n\n    //TODO: indent...\n\n    ctx.w`const _s_ = ${node.subject};${ctx.hm.NL()}`\n\n    for(let i = 0; i < node.cases.length -1; ++i) {\n        if( i !== 0)\n            ctx.w`else `;\n\n        const c = node.cases[i];\n\n        ctx.w`if( isinstance(_s_, ${c.pattern.cls.id}) ){${c.body}}`;\n    }\n    ctx.w`else {${node.cases[node.cases.length-1].body}}`;\n    ctx.w`${ctx.hm.BE()}}`;\n}","import { ASTNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Continue(node: ASTNode, ctx: EmitContext) {\n    ctx.w_str(\"continue;\");\n}","import { ASTNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Break(node: ASTNode, ctx: EmitContext) {\n    ctx.w_str(\"break;\");\n}","import { RaiseNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Raise(node: RaiseNode, ctx: EmitContext) {\n    ctx.w`throw ${node.exc};`;\n}","import { ImportFromNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function ImportFrom(node: ImportFromNode, ctx: EmitContext) {\n\n    const module = node.module;\n\n    if( module === \"RBM\" )\n        return; // Brython macros...\n\n    if( module === \"types\" || module === \"typing\")\n        return; // ignore for now\n    if( module === \"functools\") {\n        console.warn(\"Import not implemented yet\");\n        return;\n    }\n    ctx.w`const {`;\n\n    for(let i = 0; i < node.names.length; ++i) {\n        const imported = node.names[i];\n        let as = \"\";\n        if( imported.asname !== undefined)\n            as = `: ${imported.asname}`\n\n        ctx.w`${imported.name}${as},`;\n    }\n\n    const importfct = ctx.isTopLevel() && ! ctx.sync\n                            ? \"await $RB.getModule\"\n                            : \"$RB.getModuleSync\"\n\n    ctx.w`} = ${importfct}(\"${module}\")`;\n}\n","import { ImportNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Import(node: ImportNode, ctx: EmitContext) {\n\n    for(let i = 0; i < node.names.length; ++i) {\n        \n        const module = node.names[i];\n\n        const moduleName = module.name;\n\n        if( moduleName === \"RBM\" )\n            continue; // RBrython macros...\n\n        let asname = module.asname;\n        if( asname === undefined)\n            asname = moduleName;\n\n        const importfct = ctx.isTopLevel() && ! ctx.sync\n                            ? \"await $RB.getModule\"\n                            : \"$RB.getModuleSync\"\n        \n        ctx.w`const ${asname} = ${importfct}(\"${moduleName}\")`;\n    }\n}","import { getOp } from \"@RBrython/rbry/ast\";\nimport { BoolOpNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function BoolOp(node: BoolOpNode, ctx: EmitContext) {\n\n    const op = getOp(node.op);\n\n    const a = node.values[0];\n    const b = node.values[1];\n    \n    const cond  = ctx.hm.bool( ctx.hm.saveTmp(a) );\n    const saved = ctx.hm.tmp    (a);\n    const guard = ctx.hm.withTmp(a);\n\n    if( op === \"And\" )\n        return ctx.w`${guard}(${cond} ? ${b} : ${saved} )`;\n    if( op === \"Or\" )\n        return ctx.w`${guard}(${cond} ? ${saved} : ${b} )`;\n\n    throw new Error(`Unknown boolean operator ${op}`);\n}","export default function globalExport(name: string, exported: string[]) {\n    return `  globalThis.${name} = {${exported.join(\", \")}};\\n`;\n}","export default function returnExport(_: string, exported: string[]) {\n    return `  return {${exported.join(\", \")}};\\n`;\n}","export default function moduleExport(_: string, exported: string[]) {\n    return `  export {${exported.join(\", \")}};\\n`;\n}","export default function brythonExport(name: string, exported: string[]) {\n    return `  $B.imported[\"${name}\"] = $B.jsobj2pyobj({${exported.join(',')}});\\n`;\n}","import Handlers, { Handler } from \"./index\";\n\nimport {default as ClassDef} from \"./definitions/ClassDef\";\nHandlers[\"ClassDef\"] = ClassDef as Handler;\n\nimport {default as FunctionDef} from \"./definitions/FunctionDef\";\nHandlers[\"FunctionDef\"] = FunctionDef as Handler;\n\nHandlers[\"AsyncFunctionDef\"] = require(\"./definitions/AsyncFunctionDef\").default;\nHandlers[\"Await\"] = require(\"./keywords/Await\").default;\nHandlers[\"Yield\"] = require(\"./keywords/Yield\").default;\nHandlers[\"YieldFrom\"] = require(\"./keywords/YieldFrom\").default;\nHandlers[\"Delete\"] = require(\"./keywords/Delete\").default;\n\nHandlers[\"IfExp\"] = require(\"./controlflows/IfExp\").default;\nHandlers[\"With\"] = require(\"./controlflows/With\").default;\n\nHandlers[\"NamedExpr\"] = require(\"./operators/NamedExpr\").default;\n\nHandlers[\"Tuple\"] = require(\"./vars/Tuple\").default;\nHandlers[\"List\"] = require(\"./vars/List\").default;\nHandlers[\"Dict\"] = require(\"./vars/Dict\").default;\nHandlers[\"GeneratorExp\"] = require(\"./vars/GeneratorExp\").default;\nHandlers[\"ListComp\"] = require(\"./vars/ListComp\").default;\nHandlers[\"DictComp\"] = require(\"./vars/DictComp\").default;\n\nimport {default as Lambda} from \"./definitions/Lambda\";\nHandlers[\"Lambda\"] = Lambda as Handler;\n\nimport {default as Arguments} from \"./definitions/Arguments\";\nHandlers[\"arguments\"] = Arguments as Handler;\n\nimport {default as Global} from \"./vars/Global\";\nHandlers[\"Global\"] = Global as Handler;\n\nimport {default as Nonlocal} from \"./vars/Nonlocal\";\nHandlers[\"Nonlocal\"] = Nonlocal as Handler;\n\n\nimport {default as Subscript} from \"./operators/Subscript\";\nHandlers[\"Subscript\"] = Subscript as Handler;\n\nimport {default as Assert} from \"./keywords/Assert\";\nHandlers[\"Assert\"] = Assert as Handler;\n\nimport {default as Pass} from \"./keywords/Pass\";\nHandlers[\"Pass\"] = Pass as Handler;\n\nimport {default as Return} from \"./keywords/Return\";\nHandlers[\"Return\"] = Return as Handler;\n\n\nimport {default as Assign} from \"./operators/Assign\";\nHandlers[\"Assign\"] = Assign as Handler;\n\nimport {default as Attribute} from \"./operators/Attribute\";\nHandlers[\"Attribute\"] = Attribute as Handler;\n\nimport {default as AugAssign} from \"./operators/AugAssign\";\nHandlers[\"AugAssign\"] = AugAssign as Handler;\n\nimport {default as BinOp} from \"./operators/BinOp\";\nHandlers[\"BinOp\"] = BinOp as Handler;\n\nimport {default as Call} from \"./operators/Call\";\nHandlers[\"Call\"] = Call as Handler;\n\nimport {default as Compare} from \"./operators/Compare\";\nHandlers[\"Compare\"] = Compare as Handler;\n\nimport {default as UnaryOp} from \"./operators/UnaryOp\";\nHandlers[\"UnaryOp\"] = UnaryOp as Handler;\n\nimport {default as Constant} from \"./vars/Constant\";\nHandlers[\"Constant\"] = Constant as Handler;\n\nimport {default as Expr} from \"./vars/Expr\";\nHandlers[\"Expr\"] = Expr as Handler;\n\nimport {default as Name} from \"./vars/Name\";\nHandlers[\"Name\"] = Name as Handler;\n\nimport {default as JoinedStr} from \"./vars/JoinedStr\";\nHandlers[\"JoinedStr\"] = JoinedStr as Handler;\n\nimport {default as If} from \"./controlflows/If\";\nHandlers[\"If\"] = If as Handler;\n\nimport {default as While} from \"./controlflows/While\";\nHandlers[\"While\"] = While as Handler;\n\nimport {default as For} from \"./controlflows/For\";\nHandlers[\"For\"] = For as Handler;\n\nimport {default as Try} from \"./controlflows/Try\";\nHandlers[\"Try\"] = Try as Handler;\n\nimport {default as Match} from \"./controlflows/Match\";\nHandlers[\"Match\"] = Match as Handler;\n\nimport {default as Continue} from \"./keywords/Continue\";\nHandlers[\"Continue\"] = Continue as Handler;\n\nimport {default as Break} from \"./keywords/Break\";\nHandlers[\"Break\"] = Break as Handler;\n\nimport {default as Raise} from \"./keywords/Raise\";\nHandlers[\"Raise\"] = Raise as Handler;\n\nimport {default as ImportFrom} from \"./imports/ImportFrom\";\nHandlers[\"ImportFrom\"] = ImportFrom as Handler;\n\nimport {default as Import} from \"./imports/Import\";\nHandlers[\"Import\"] = Import as Handler;\n\nimport {default as BoolOp} from \"./operators/BoolOp\";\nHandlers[\"BoolOp\"] = BoolOp as Handler;\n\n","export default {\n    defaults: {},\n    transform: (e: string) => e\n}","const handlers = {\n    \"FunctionDef\": require(\"./definitions/FunctionDef\").default,\n\n    \"Constant\": require(\"./vars/Constant\").default,\n    \"UnaryOp\": require(\"./operators/UnaryOp\").default,\n    \"Compare\" : require(\"./operators/Compare\").default\n}\n\nexport default handlers","import { getChildren, nodeType } from \"../ast\";\nimport { ASTNode, ParsedCode, SymTab } from \"../ast/types\";\nimport handlers from \"./handlers\";\nimport { TypeDesc } from \"./types\";\n\nexport type TypedASTNode<T extends ASTNode = ASTNode> = T & {result_type: TypeDesc}\nexport type TypedSymTab     = SymTab & {typedSymbols: Record<string, TypeDesc>}\n\nexport type Entry<T extends ASTNode = ASTNode> = {\n    node  : T,\n    symtab: SymTab\n}\nexport type TypedEntry<T extends ASTNode = ASTNode> = Entry<TypedASTNode<T>>\n                                                    & {symtab: TypedSymTab};\n\nexport function walk(parsed: ParsedCode) {\n\n    const pending = new Array<Entry>();\n\n    for(let i = 0; i < parsed.ast.body.length; ++i)\n        pending.push({\n            symtab: parsed.symtable,\n            node  : parsed.ast.body[i]\n        })\n\n    const toProcess = new Array<TypedEntry>();\n    \n    let elem: Entry|undefined;\n    while( elem = pending.pop() ) {\n\n        toProcess.push(elem as any);\n\n        for( let node of getChildren(elem.node) )\n            pending.push({\n                node,\n                symtab: elem.symtab\n            });\n        \n        // @ts-ignore\n        if( elem.node.body) {\n\n            let symtab = elem.symtab;\n            const type = nodeType(elem.node);\n\n            if( type === \"FunctionDef\" || type === \"ClassDef\")\n                // @ts-ignore\n                symtab = symtab.children.find(e => e.name === elem.node.name)!;\n\n            // @ts-ignore\n            for(let i = 0; i < elem.node.body.length ; ++i ) {\n                pending.push({\n                    // @ts-ignore\n                    node  : elem.node.body[i],\n                    symtab\n                });\n            }\n        }\n    }\n\n    let entry: TypedEntry|undefined;\n    while( entry = toProcess.pop() ) {\n\n        const handler = handlers[nodeType(entry.node) as keyof typeof handlers];\n        if( handler === undefined) {\n            //\n            continue;\n        }\n        \n        handler(entry);\n    }\n}\n","import { HMacro } from \"@RBrython/rbry/optimizers\";\n\nconst hmacros = {\n    NL     : require(\"./NL\")  .default as HMacro,\n    BB     : require(\"./BB\")  .default as HMacro,\n    BE     : require(\"./BE\")  .default as HMacro,\n    bool   : require(\"./bool\").default as HMacro,\n    tmp    : require(\"./tmp\").default as HMacro,\n    getTmp : require(\"./getTmp\").default as HMacro,\n    saveTmp: require(\"./saveTmp\").default as HMacro,\n    withTmp: require(\"./withTmp\").default as HMacro\n}\n\nexport default hmacros;","const SafeOpti = [\n    require(\"./Call.ts\").default\n];\n\nexport default SafeOpti;","const SafeOpti = [\n    require(\"./bool.ts\").default,\n    require(\"./tmp.ts\" ).default,\n    require(\"./getTmp.ts\").default,\n    require(\"./saveTmp.ts\").default,\n    require(\"./withTmp.ts\").default\n];\n\nexport default SafeOpti;","import { ASTNode } from \"../ast/types\";\nimport { EmitContext, Macro } from \"../emitter/EmitContext\";\nimport handlers, { Handler, Handlers } from \"../emitter/handlers\"\nimport hmacros from \"../emitter/hmacros/list\";\nimport SafeOpti_handlers from \"./safe/handlers\";\nimport SafeOpti_hmacros from \"./safe/hmacros\";\n\n// delayed by default in order to be used with ctx.w``.\nexport type HMacro = (...args: any[]) => ( (ctx: EmitContext) => void);\n\nexport type HMacros = Record<string, HMacro>;\n\nexport type Optimizer = {\n    handlers           : Handlers,\n    hmacros            : HMacros,\n    require_typechecker: boolean\n}\n\ntype PatchHandler = (node: ASTNode, ctx: EmitContext, fallback: Handler) => void\n\nfunction patchHandlers(handlers: Handlers, patch: PatchHandler[]) {\n\n    const patchedHandlers = {...handlers};\n\n    for(let i = 0; i < patch.length; ++i ) {\n        const name = patch[i].name;\n\n        const fallback = handlers[name];\n        patchedHandlers[name] = (node: ASTNode, ctx: EmitContext) => {\n            patch[i](node, ctx, fallback);\n        }\n    }\n\n    return patchedHandlers;\n}\n\ntype PatchHMacros = (fallback: HMacro, ...args: any[]) => ((ctx: EmitContext) => void)\n\nfunction patchHMacros(hmacros: HMacros, patch: PatchHMacros[]) {\n\n    const patchedHMacros = {...hmacros};\n\n    for(let i = 0; i < patch.length; ++i ) {\n        const name = patch[i].name;\n\n        const fallback = hmacros[name];\n        patchedHMacros[name] = (...args: any[]) => {\n            return patch[i](fallback, ...args);\n        }\n    }\n\n    return patchedHMacros;\n}\n\nconst safeHandlers = patchHandlers(handlers, SafeOpti_handlers);\nconst safeHmacros  = patchHMacros(hmacros, SafeOpti_hmacros);\n\nconst Optimizers = {\n    disabled: {\n        handlers,\n        hmacros: hmacros,\n        require_typechecker: false\n    },\n    safe    : {\n        handlers: safeHandlers,\n        hmacros : safeHmacros,\n        require_typechecker: true\n    },\n    unsafe  : {\n        handlers: safeHandlers, //TODO...\n        hmacros : safeHmacros,  //TODO...\n        require_typechecker: true\n    }\n} satisfies Record<string, Optimizer>\n\nexport default Optimizers;","// quick h4ck (should move it).\nimport \"../runlib\";\nimport \"./handlers/list\"; // ensure Handlers are loaded.\n\nimport { ParsedCode } from \"../ast/types\";\nimport SourceMap from \"./SourceMap\";\nimport { EmitContext, Macro } from \"./EmitContext\";\nimport globalExport from \"./exports/global\";\nimport returnExport from \"./exports/return\";\nimport moduleExport from \"./exports/module\";\nimport brythonExport from \"./exports/brython\";\nimport RawTarget from \"./targets/raw\";\nimport { walk } from \"../checker/Walker\";\nimport Optimizers, { Optimizer } from \"../optimizers\";\n\nexport type Target = {\n    defaults : Partial<EmitterOptions>\n    transform: (jscode: string, sync: boolean) => string;\n}\n\nexport type JSCode = {\n    name    : string,\n    jscode  : string,\n    imported: string[],\n    exported: string[],\n}\n\nexport const enum MODE {\n  DEBUG,\n  TEST,\n  PROD,\n}\n\nexport const enum EXPORT {\n    NONE    = 0,\n    GLOBAL  = 1<<0,\n    MODULE  = 1<<1,\n    RETURN  = 1<<2,\n    BRYTHON = 1<<3,\n}\n\nexport type EmitterOptions = {\n    mode   : MODE,\n    target : Target,\n    opti   : Optimizer,\n    exports: EXPORT,\n    sync   : boolean\n}\n\nconst EmitterDefaults: EmitterOptions = {\n    mode   : MODE.DEBUG,\n    target : RawTarget,\n    opti   : Optimizers.safe,\n    exports: EXPORT.NONE,\n    sync   : false\n}\n\nexport abstract class Emitter {\n    abstract emit(parsed: ParsedCode, opts?: Partial<EmitterOptions>): string;\n\n    abstract registerMacros(macros: Record<string, Macro>):void;\n    abstract registerMacro(name: string, fct: Macro): void;\n}\n\nexport default class RBrythonEmitter extends Emitter {\n\n    protected readonly macros: Record<string, Macro> = {};\n\n    registerMacros(macros: Record<string, Macro>) {\n        for(let name in macros)\n            this.macros[name] = macros[name];\n    }\n    registerMacro(name: string, fct: Macro) {\n        this.macros[name] = fct;\n    }\n\n    emit(parsed: ParsedCode, options: Partial<EmitterOptions> = {}) {\n\n        const name = \"_\";\n\n        const opts: EmitterOptions = Object.assign({}, \n                                        EmitterDefaults,\n                                        options.target?.defaults,\n                                        options);\n\n        if( opts.opti.require_typechecker )\n            walk(parsed); //TODO\n        \n        const ctx = new EmitContext(opts,\n                                    this.macros,\n                                    parsed.symtable);\n\n        const exported = this.extractExportedSymbols(parsed);\n        ctx.w_body(parsed.ast.body);\n\n        let jscode = ctx.jscode;\n\n        if( opts.exports & EXPORT.GLOBAL)\n            jscode += globalExport(name, exported);\n        if( opts.exports & EXPORT.MODULE)\n            jscode += moduleExport(name, exported);\n        if( opts.exports & EXPORT.RETURN)\n            jscode += returnExport(name, exported);\n        if( opts.exports & EXPORT.BRYTHON) {\n            jscode += brythonExport(name, exported);\n        }\n\n        const output = {\n            name,\n            imported: [],\n            exported,\n            jscode,\n        }\n\n        return opts.target.transform(jscode, opts.sync!)\n    }\n\n    private extractExportedSymbols(parsed: ParsedCode) {\n        \n        const symbols = parsed.symtable.symbols.$strings\n        return Object.keys(symbols)\n                     .filter( k => symbols[k] === 4098); // magic value\n    }\n}\n\n/*\nTODO: filter...\nconst sm = new SourceMap(\"a\", \"b\", \"c\");\nsm.addMapping({line: 3, col: 4}, {line: 3, col: 5});\nsm.addMapping({line: 3, col: 5}, {line: 3, col: 5});\n\nconsole.warn(sm.toFile());\n*/","import { EXPORT } from \"..\";\n\nexport default {\n    defaults: {\n        exports: EXPORT.RETURN\n    },\n    transform: (jscode: string, sync: boolean) => {\n        return `(${sync ? \"\" : \"async \"}function($RB){\"use strict\";${jscode}})`;\n    }\n}","import Engine from \"../interface\";\nimport { ParsedCode } from \"@RBrython/rbry/ast/types\";\nimport Runner, { PyModule } from \"@RBrython/rbry/runners/interface\";\nimport parse from \"@RBrython/rbry/parser\";\nimport {Emitter, EmitterOptions} from \"@RBrython/rbry/emitter\";\nimport FunctionTarget from \"@RBrython/rbry/emitter/targets/function\";\nimport { Macro } from \"@RBrython/rbry/emitter/EmitContext\";\n\ntype Parser  = typeof parse;\n\nexport default class BaseEngine extends Engine {\n\n    protected readonly parser;\n    protected readonly emitter;\n    protected readonly runner;\n\n    constructor(parser: Parser, emitter: Emitter, runner: Runner) {\n        super();\n\n        this.parser  = parser;\n        this.emitter = emitter;\n        this.runner  = runner;\n    }\n\n    override async run(pycode: string, opts?: Omit<EmitterOptions, \"target\">): Promise<PyModule> {\n\n        return await this.runner.run(this.emit(this.parse(pycode), {\n            ...opts,\n            target: FunctionTarget\n        }));\n    }\n    override runSync(pycode: string, opts?: Omit<EmitterOptions, \"target\">): PyModule {\n\n        return this.runner.runSync(this.emit(this.parse(pycode), {\n            ...opts,\n            sync  : true,\n            target: FunctionTarget\n        }));\n    }\n\n    // modules\n    override async registerModule(name: string, symbols: string | PyModule) {\n        if( typeof symbols === \"string\")\n            symbols = await this.run(symbols);\n        this.runner.registerModule(name, symbols);\n    }\n    override registerModuleSync(name: string, symbols: string | PyModule): void {\n        if( typeof symbols === \"string\")\n            symbols = this.runSync(symbols);\n        this.runner.registerModule(name, symbols);\n    }\n    override getModule(name: string): PyModule {\n        return this.runner.getModule(name);\n    }\n\n    // builtins\n    override registerBuiltins(symbols: string | PyModule): void {\n        if( typeof symbols === \"string\")\n            symbols = this.runSync(symbols);\n        this.runner.registerBuiltins(symbols);\n    }\n    override registerBuiltin(name: string, value: any): void {\n        this.runner.registerBuiltin(name, value);\n    }\n\n    override registerMacros(macros: Record<string, Macro>):void {\n        this.emitter.registerMacros(macros);\n\n    }\n    override registerMacro(name: string, fct: Macro): void {\n        this.emitter.registerMacro(name, fct);\n    }\n\n    // steps\n    override parse(pycode: string): ParsedCode {\n        return this.parser(pycode, \"_\");\n    }\n    override emit(parsed: ParsedCode, opts?: Partial<EmitterOptions>): string {\n        return this.emitter.emit(parsed, opts);\n    }\n    override loadAsFunction(jscode: string): (runlib: any) => Promise<PyModule> {\n        return this.runner.loadAsFunction(jscode);\n    }\n    override runFunction(fct: (runlib: any) => Promise<PyModule>): Promise<PyModule> {\n        return this.runner.runFunction(fct);\n    }\n    override loadAsSyncFunction(jscode: string): (runlib: any) => PyModule {\n        return this.runner.loadAsSyncFunction(jscode);\n    }\n    override runSyncFunction(fct: (runlib: any) => PyModule): PyModule {\n        return this.runner.runSyncFunction(fct);\n    }\n}","import { ParsedCode } from \"../ast/types\";\n\nexport default function parse(pycode: string, filename: string): ParsedCode {\n    \n    const parser = new $B.Parser(pycode, filename, 'file');\n\n    const ast   = $B._PyPegen.run_parser(parser);\n    const future = $B.future_features(ast, filename)\n    var symtable = $B._PySymtable_Build(ast, filename, future);\n\n    return {\n        filename,\n        pycode,\n        ast,\n        symtable,\n    }\n}","import RBrythonGlobalRunner from \"@RBrython/rbry/runners/RBrythonGlobalRunner\";\nimport BaseEngine from \"../Base\";\nimport parse from \"@RBrython/rbry/parser\";\nimport RBrythonEmitter from \"@RBrython/rbry/emitter\";\n\nexport const builtins = {\n    object: require(\"!!raw-loader!../../corelib/primitives/object.py\"  ).default,\n    type  : require(\"!!raw-loader!../../corelib/primitives/type.py\"  ).default,\n    int   : require(\"!!raw-loader!../../corelib/primitives/int.py\"   ).default,\n    bool  : require(\"!!raw-loader!../../corelib/primitives/bool.py\"  ).default,\n    float : require(\"!!raw-loader!../../corelib/primitives/float.py\" ).default,\n    str   : require(\"!!raw-loader!../../corelib/primitives/str.py\"   ).default,\n    tuple : require(\"!!raw-loader!../../corelib/primitives/tuple.py\" ).default,\n    list  : require(\"!!raw-loader!../../corelib/primitives/list.py\"  ).default,\n    dict  : require(\"!!raw-loader!../../corelib/primitives/dict.py\"  ).default,\n\n    format: require(\"!!raw-loader!../../corelib/print/format.py\").default,\n    repr: require(\"!!raw-loader!../../corelib/print/repr.py\").default,\n    print: require(\"!!raw-loader!../../corelib/print/print.py\").default,\n\n    abs  : require(\"!!raw-loader!../../corelib/operators/abs.py\"  ).default,\n    len  : require(\"!!raw-loader!../../corelib/operators/len.py\"  ).default,\n\n    range     : require(\"!!raw-loader!../../corelib/iterators/range.py\"  ).default,\n    next: require(\"!!raw-loader!../../corelib/iterators/next.py\"  ).default,\n\n    Exception: require(\"!!raw-loader!../../corelib/Exception.py\"  ).default,\n    isinstance: require(\"!!raw-loader!../../corelib/isinstance.py\"  ).default,\n}\n\nexport default function RBrythonEngineFactory() {\n\n    const emitter = new RBrythonEmitter();\n    const runner  = new RBrythonGlobalRunner();\n    const engine = new BaseEngine(parse, emitter, runner);\n\n    engine.registerMacros({\n\n        __JS_OP__       : require(\"@RBrython/rbry/macros/__JS_OP__\").default,\n        __JS_AWAIT__    : require(\"@RBrython/rbry/macros/__JS_AWAIT__\").default,\n        __JS_RUN__      : require(\"@RBrython/rbry/macros/__JS_RUN__\").default,\n        __JS_WRITE__    : require(\"@RBrython/rbry/macros/__JS_WRITE__\").default,\n        __JS_LOG__      : require(\"@RBrython/rbry/macros/__JS_LOG__\").default,\n        __JS_AS_STRING__: require(\"@RBrython/rbry/macros/__JS_AS_STRING__\").default,\n        __JS_AS_NUMBER__: require(\"@RBrython/rbry/macros/__JS_AS_NUMBER__\").default,\n        __JS_AS_BIGINT__: require(\"@RBrython/rbry/macros/__JS_AS_BIGINT__\").default,\n        __JS_SHADOW__: require(\"@RBrython/rbry/macros/__JS_SHADOW__\").default,\n    })\n\n    engine.registerModule(\"JS\", globalThis);\n\n    for(let builtin of Object.values(builtins))\n        engine.registerBuiltins(builtin);\n\n    return engine;\n}","import EngineFactory from \"@RBrython/rbry/engines/RBrython\";\n\nexport default EngineFactory();"],"names":["BE","ctx","indent_level","w_line","__JS_OP__","args","length","op","value","w","tmp","Tuple","node","i","elts","w_node","w_str","__JS_RUN__","code","str","replaceAll","bool","fallback","isInstance","result_type","BoolType","isASTNode","o","constructor","nodeType","$name","getOp","getChildren","elem","Object","values","filter","e","undefined","BB","ListComp","console","warn","hm","NL","generators","gen","target","iter","j","ifs","key","If","test","body","orelse","getTmp","isSimple","Runner","NamedExpr","GeneratorExp","elt","Constant","entry","type","__JS_LOG__","withTmp","_","__JS_WRITE__","AsyncFunctionDef","isMethod","name","getName","decorator_list","w_body","__JS_AS_BIGINT__","With","items","context_expr","r","optional_vars","saveTmp","List","keys","Delete","targets","Error","snode","attr","slice","FunctionDef","symtab","typedSymbols","FunctionType","Await","Call","f","func","fid","id","macros","m","writeArgs","keywords","arg","YieldFrom","__JS_AWAIT__","__JS_AS_STRING__","__JS_SHADOW__","jstype","v","t","UnaryOp","__JS_AS_NUMBER__","modules","RBrythonGlobalRunner","run","jscode","this","runFunction","loadAsFunction","runSync","runSyncFunction","loadAsSyncFunction","eval","fct","$RB","registerModule","symbols","getModule","registerBuiltins","registerBuiltin","globalThis","SHADOW_JS","getClass","typename","klassname","isFrozen","Exception","lit_class","NotImplemented","Symbol","cmp_reversed","KW","IGNORE_ARG","_tmp","a","b","ka","result","prototype","call","kb","rop","uop","__call__","__new__","getOwnPropertyDescriptors","writable","mcall","assert","cond","msg","getitem","__getitem__","setitem","__setitem__","delitem","__delitem__","getattr","__getattr__","setattr","__setattr__","delattr","__delattr__","getKW","setKW","async","module","__BRYTHON__","imported","pyobj2jsob","getModuleSync","in","c","kc","iterator","shadowJS","ro","prefix","cls","freeze","IVALUE","__JS_SET_IVALUE__","self","__JS_GET_IVALUE__","Yield","Compare","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","__webpack_modules__","d","definition","defineProperty","enumerable","get","obj","prop","hasOwnProperty","Engine","handlers","hacked","ClassDef","bases","includes","hasYield","stack","pop","push","genSym","Lambda","Arguments","pos_offset","arg_offset","posonlyargs","d_idx","defaults","hasVararg","vararg","hasKW","kwarg","kwonlyargs","writeKW","selfname","kw_defaults","Global","Nonlocal","Subscript","Assert","mode","MODE","PROD","Pass","Return","FUNCTION","CLASS","BODY","LOCAL_VAR","EmitContext","sync","opti","hmacros","getScope","$strings","idx","isTopLevel","last","strings","exprs","Array","isArray","nl","repeat","endsWith","nodes","handler","hasNewContext","enter","js_start","js_end","leave","children","find","l","Assign","left","right","opname","binops","Add","Sub","Mult","Div","FloorDiv","Pow","Mod","BitOr","BitAnd","BitXor","LShift","RShift","AugAssign","prev","ops","isFirst","isLast","comparators","cmpops","Eq","NotEq","Gt","GtE","Lt","LtE","In","operand","uops","Invert","USub","UAdd","qname","__class__","__qualname__","Expr","Name","DEBUG","JoinedStr","val","format_spec","While","For","Try","except","finalbody","Match","subject","cases","pattern","Continue","Break","Raise","exc","ImportFrom","names","as","asname","importfct","Import","moduleName","BoolOp","saved","guard","globalExport","exported","join","returnExport","moduleExport","brythonExport","Handlers","require","Attribute","BinOp","transform","walk","parsed","pending","ast","symtable","toProcess","SafeOpti","patchHandlers","patch","patchedHandlers","patchHMacros","patchedHMacros","safeHandlers","SafeOpti_handlers","safeHmacros","SafeOpti_hmacros","Optimizers","disabled","require_typechecker","safe","unsafe","EXPORT","EmitterDefaults","RawTarget","Emitter","RBrythonEmitter","registerMacros","registerMacro","emit","options","opts","assign","extractExportedSymbols","k","RETURN","BaseEngine","parser","emitter","runner","super","pycode","parse","FunctionTarget","registerModuleSync","filename","$B","Parser","_PyPegen","run_parser","future","future_features","_PySymtable_Build","builtins","object","int","float","tuple","list","dict","format","repr","print","abs","len","range","next","isinstance","RBrythonEngineFactory","engine","builtin","EngineFactory"],"sourceRoot":""}