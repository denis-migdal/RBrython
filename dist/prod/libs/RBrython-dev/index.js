var e={116:(e,n,t)=>{t.d(n,{A:()=>o});const o='from RBM import __JS_OP__, boolean\n\nclass bool(boolean): # type: ignore (bool is Final)\n    def __eq__(self, o: object, /) -> bool:\n        return __JS_OP__(self, "==", o)'},180:(e,n,t)=>{t.d(n,{A:()=>o});const o='from types import NotImplementedType\nfrom RBM import __JS_OP__, __JS_AS_NUMBER__, number\n\nclass float(number):\n    def __new__(cls, o: object, /) -> float:\n        if type(o) is str:\n            return __JS_AS_NUMBER__(o)\n        return type(o).__float__(o) # type: ignore\n    \n    def __eq__(self, o: object, /) -> bool:\n        return __JS_OP__(self, "==", o)    \n\n    def __add__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(self, "+", o)\n            case int  (): return __JS_OP__(self, "+", __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n\n    def __radd__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(o                  , "+", self)\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), "+", self)\n            case _      : return NotImplemented\n\n    def __sub__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(self, "-", o)\n            case int  (): return __JS_OP__(self, "-", __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n\n    def __rsub__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(o                  , "-", self)\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), "-", self)\n            case _      : return NotImplemented\n\n    def __mul__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(self, "*", o)\n            case int  (): return __JS_OP__(self, "*", __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n\n    def __rmul__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(o                  , "*", self)\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), "*", self)\n            case _      : return NotImplemented\n\n    def __div__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(self, "/", o)\n            case int  (): return __JS_OP__(self, "/", __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n\n    def __rdiv__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(o                  , "/", self)\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), "/", self)\n            case _      : return NotImplemented\n\n    ### unary operators ###\n\n    def __neg__(self, /) -> float:\n        return __JS_OP__("-", self)\n    \n    def __int__(self, /) -> int:\n        return __JS_RUN__(\'(x) => Math.trunc(x)\', self) # type: ignore\n    \n    def __abs__(self, /) -> int:\n         return __JS_RUN__(\'(x) => Math.abs(x)\', self) # type: ignore'},541:(e,n,t)=>{t.d(n,{A:()=>o});const o='from types     import NotImplementedType\n\nfrom RBM import __JS_AS_NUMBER__, __JS_OP__, bigint\n\nclass int(bigint):\n\n    def __new__(cls, o: object, base: int, /) -> int:\n        if type(o) == str:\n            return __JS_RUN__( # type: ignore\n                \'\'\'\n                    (x, base) => {\n                        if( base !== 16)\n                            return BigInt(x);\n                        \n                        let result = 0n;\n                        for(let i = 2; i < x.length; ++i)\n                            result = result << 4n + BigInt( parseInt(this.slice(i, i+8), 16) );\n                        return result;\n                    }\n                \'\'\', o, base) # type: ignore\n        return type(o).__int__(o) # type: ignore\n    \n    def __eq__(self, o: object, /) -> bool:\n        return __JS_OP__(self, "==", o)\n\n\n    def __add__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "+", o)\n            case _      : return NotImplemented\n    \n    def __radd__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(o, "+", self)\n            case _      : return NotImplemented\n    \n\n    def __sub__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "-", o)\n            case _      : return NotImplemented\n    \n    def __rsub__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(o, "-", self)\n            case _      : return NotImplemented\n    \n    def __mul__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "*", o)\n            case _      : return NotImplemented\n    \n    def __rmul__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(o, "*", self)\n            case _      : return NotImplemented\n\n    def __pow__(self, o: object, mod: int|None = None, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "**", o)\n            case _      : return NotImplemented\n    \n    def __rpow__(self, o: object, mod: int|None = None, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(o, "**", self)\n            case _      : return NotImplemented\n\n    def __div__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(self),\n                                           "/",\n                                           __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n    \n    def __rdiv__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o),\n                                           "*",\n                                           __JS_AS_NUMBER__(self) )\n            case _      : return NotImplemented\n\n    def __mod__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "%", o)\n            case _      : return NotImplemented\n    \n    def __rmod__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "%", o)\n            case _      : return NotImplemented\n    \n    def __or__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "|", o)\n            case _      : return NotImplemented\n    \n    def __ror__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "|", o)\n            case _      : return NotImplemented\n\n    def __and__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "&", o)\n            case _      : return NotImplemented\n    \n    def __rand__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "&", o)\n            case _      : return NotImplemented\n        \n    def __xor__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "^", o)\n            case _      : return NotImplemented\n    \n    def __rxor__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "^", o)\n            case _      : return NotImplemented\n\n    def __lshift__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "<<", o)\n            case _      : return NotImplemented\n    \n    def __rlshift__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "<<", o)\n            case _      : return NotImplemented\n\n    def __rshift__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, ">>", o)\n            case _      : return NotImplemented\n    \n    def __rrshift__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, ">>", o)\n            case _      : return NotImplemented\n    \n    ### unary operators ###\n    def __invert__(self, /) -> int:\n        return __JS_OP__("~", self)\n\n    def __neg__(self, /) -> int:\n        return __JS_OP__("-", self)\n    \n    def __abs__(self, /) -> int:\n         return __JS_RUN__("x => x < 0n ? -x : x", self) # type: ignore'},711:(e,n,t)=>{t.d(n,{A:()=>o});const o='from types     import NotImplementedType\nfrom RBM import __JS_OP__, string\n\nclass str(string):\n    def __new__(cls, o: object, /) -> str:\n        return __JS_AS_STRING__(o) # type: ignore\n        #return type(o).__str__(o) # type: ignore\n    \n    def __eq__(self, o: object, /) -> bool:\n        return __JS_OP__(self, "==", o)\n\n    def __mul__(self, o: object, /) -> NotImplementedType|str:\n        match o:\n            case int  (): return __JS_WRITE__("self.repeat(Number(b))") # type: ignore\n            case _      : return NotImplemented\n    \n    def __rmul__(self, o: object, /) -> NotImplementedType|str:\n        match o:\n            case int  (): return __JS_WRITE__("self.repeat(Number(b))") # type: ignore\n            case _      : return NotImplemented'}},n={};function t(o){var _=n[o];if(void 0!==_)return _.exports;var r=n[o]={exports:{}};return e[o](r,r.exports,t),r.exports}t.d=(e,n)=>{for(var o in n)t.o(n,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:n[o]})},t.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n);var o={};function _(e,n){const t=new $B.Parser(e,n,"file"),o=$B._PyPegen.run_parser(t),_=$B.future_features(o,n);return{filename:n,pycode:e,ast:o,symtable:$B._PySymtable_Build(o,n,_)}}t.d(o,{A:()=>O});class r{}class s extends r{constructor(){super(),this.initialize()}run(e){this.loadAsFunction(this.emit(this.parse(e)))()}#e=!1;initialize(){$B.imported.JS=$B.jsobj2pyobj(globalThis),this.#e=!0}parse(e){return _(e,"_")}emit(e){return $B.js_from_root({ast:e.ast,symtable:e.symtable,filename:e.filename,src:e.pycode,imported:void 0}).js}loadAsFunction(e){return $B.imported._={},Function("'use strict';"+e)}}class l{__call__(...e){const n=this.prototype.__new__,t=void 0!==n?n.call(this,...e):new this(...e),o=this.prototype.__init__;return void 0!==o&&o.call(t,...e),t}__eq__(e){return this==e}}const i={bigint:"int",number:"float",string:"str",boolean:"bool"};function a(e){const n=typeof e;if("function"===n)return l;if("object"===n)return e.constructor;const t=globalThis[i[n]];if(void 0!==t)return t;throw new Error(`JS type ${n} not implemented yet`)}const c=Symbol(),u={eq:function(e){return this==e}};let f=null;const m=Symbol();globalThis.$RB={op:function(e,n,t){const o=a(e);if(void 0===o)throw console.warn(e,n),new Error("?");let _=o.prototype[`__${n}__`];if(void 0===_){if("ne"===n)return!o.prototype.__eq__.call(e,t);"i"===n[0]&&(_=o.prototype[`__${n.slice(1)}__`]),void 0===_&&(_=u[n])}let r=_.call(e,t);if(r===c){const o=a(t);if(void 0===o)throw console.warn(t,"r"+n),new Error("?");r=o.prototype[`__r${n}__`].call(t,e)}return r},uop:function(e,n){if("not"===e)return!n;const t=a(n);if(void 0===t)throw console.warn(n,e),new Error("?");return t.prototype[`__${e}__`].call(n)},call:function(e,...n){n[n.length-1]===m&&(n=n.slice(0,-1));let t=e.__call__;if(void 0===t){if(t=e,void 0!==t.prototype?.__new__){const e=a(t).prototype.__call__;if(void 0!==e)return e.call(t,...n)}if(o=t,!1===Object.getOwnPropertyDescriptors(o)?.prototype?.writable)return new t(...n)}var o;return t(...n)},mcall:function(e,n,...t){return t[t.length-1]===m&&(t=t.slice(0,-1)),void 0===e[n]?e.prototype[n].call(...t):e[n](...t)},assert:function(e){if(!e)throw new Error("Assertion failed")},attr:function(e,n){return n in e?e[n]:e.constructor[n]},getKW:function(){if(null===f)return{};const e=f;return f=null,e},setKW:function(e){return f=e,m},getModule:function(e){if("JS"===e)return globalThis;throw new Error(`module ${e} not found`)}},globalThis.abs=function(e){return a(e).prototype.__abs__.call(e)},globalThis.type=function(e){return a(e)},globalThis.NotImplemented=c,globalThis.range=function*(e){for(let n=0;n<e;++n)yield n},globalThis.Exception=function(e){throw new Error(e)},globalThis.__JS_LOG__=(...e)=>console.log(...e);const p=Symbol();globalThis.__JS_SET_IVALUE__=(e,n)=>e[p]=n,globalThis.__JS_GET_IVALUE__=e=>e[p],globalThis.__JS_AS_NUMBER__=e=>"infinity"===e||"inf"===e?Number.POSITIVE_INFINITY:"-infinity"===e||"-inf"===e?Number.NEGATIVE_INFINITY:Number(e),globalThis.__JS_AS_STRING__=e=>`${e}`;const d={};function b(e){return e.constructor.$name}function g(e){return e.constructor.$name}function h(e){const n=d[b(e)];if(void 0===n)throw console.warn(e),new Error(`Node type ${b(e)} is unknown`);return n(e)}function y(e,n=!1){const t=globalThis.inClass;globalThis.inClass=n;let o="";for(let n=0;n<e.length;++n)o+=h(e[n])+";\n";return globalThis.inClass=t,o}globalThis.inCstrFct=!1;const $={Add:"add",Sub:"sub",Mult:"mul",Div:"div",Pow:"pow",Mod:"mod",BitOr:"or",BitAnd:"and",LShift:"lshift",RShift:"rshift"},S={},N={Eq:"eq",NotEq:"ne"},I={Invert:"invert",USub:"neg",Not:"not"};d.ClassDef=function(e){const n=e.name,t=e.body;let o=`globalThis.${n} = (() =>{\n        function ${n}() {\n            return Object.create(${n}.prototype);\n        }\n        const classname = ${n};\n    `;if((1!==e.bases.length||!["number","bigint","boolean","string"].includes(e.bases[0].id))&&e.bases.length>=1){o+=`${n}.prototype = Object.create(${h(e.bases[0])}.prototype);\n`;for(let t=1;t<e.bases.length;++t)o+=`Object.assign(${n}.prototype, ${h(e.bases[t])}.prototype);`;o+=`${n}.prototype.constructor = ${n};\n`}for(let e=0;e<t.length;++e)"FunctionDef"===b(t[e])&&(globalThis.inCstrFct=!0,o+=`${"_"===t[e].name?"":`${n}.prototype.${t[e].name} = `}${h(t[e])}\n            `,globalThis.inCstrFct=!1);return o+=`\n        return ${n};\n    })();\n    `,o},d.FunctionDef=function(e){const n=e.name,t=e.body;let o=globalThis.inClass?"":"function ",_="",r=0,s=0,l="";if(globalThis.inClass||globalThis.inCstrFct){let n="";e.args.posonlyargs.length?n=e.args.posonlyargs[0].arg:(n=e.args.args[0].arg,++s),l=`const ${n} = this;`,++r}for(;r<e.args.posonlyargs.length;++r)_+=`${e.args.posonlyargs[r].arg}, `;for(r=s;r<e.args.args.length;++r)_+=`_${e.args.args[r].arg}, `;if(e.args.args.length){_+="{";for(let n=s;n<e.args.args.length;++n)_+=`${e.args.args[n].arg} = _${e.args.args[n].arg}, `;_+="} = $RB.getKW()"}let i=`${o}${n}(${_}) {\n        ${l}\n        ${y(t)}\n    }`;if(0===e.decorator_list.length)return i;const a=e.decorator_list[0];return globalThis.inClass?`static {\n            this.prototype.${n} = ${h(a)}(function ${i});\n        }`:`${h(a)}(${i})`},d.Lambda=function(e){let n="";for(let t=0;t<e.args.posonlyargs.length;++t)n+=e.args.posonlyargs[t].arg+", ";return`(${n}) => { return ${h(e.body)}}`},d.Assert=function(e){return`$RB.assert(${h(e.test)})`},d.Pass=function(e){return""},d.Return=function(e){return`return ${h(e.value)}`},d.Assign=function(e){let n="";const t=globalThis.inClass?"static ":"var ";for(let o=1;o<e.targets.length;++o)n+=`${t}${h(e.targets[o])};`;n+=t+h(e.targets[0])+" = ";for(let t=1;t<e.targets.length;++t)n+=h(e.targets[t])+" = ";return n+h(e.value)},d.Attribute=function(e){return`$RB.attr(${h(e.value)}, "${e.attr}")`},d.AugAssign=function(e){const n=e.target,t=g(e.op),o=e.value,_=$[t];if(void 0===_)throw new Error(`BinOp ${t} not impl`);return`${h(n)} = $RB.op(${h(n)}, "i${_}", ${h(o)})`},d.BinOp=function(e){const n=e.left,t=e.right,o=g(e.op),_=$[o];if(void 0===_)throw new Error(`BinOp ${o} not impl`);return`$RB.op(${h(n)}, "${_}", ${h(t)})`},d.Call=function(e){const n=e.func,t=e.args,o=e.keywords;if(n.id in S)return S[n.id](...e.args);let _="";for(let e=0;e<t.length;++e)_+=h(t[e])+", ";if(o.length){_+="$RB.setKW({";for(let e=0;e<o.length;++e)_+=`${o[e].arg}: ${h(o[e].value)},`;_+="})"}if("Attribute"===b(n)){const e=n;return`$RB.mcall(${h(e.value)}, "${e.attr}", ${_} )`}return`$RB.call(${h(n)}, ${_})`},d.Compare=function(e){const n=e.left,t=g(e.ops[0]),o=e.comparators[0];if("Is"===t)return`${h(n)} === ${h(o)}`;const _=N[t];if(void 0===_)throw console.warn(t),new Error(`CmpOp ${t} not impl`);return`$RB.op(${h(n)}, "${_}", ${h(o)})`},d.UnaryOp=function(e){const n=e.operand,t=g(e.op),o=I[t];if(void 0===o)throw new Error(`UnaryOp ${t} not impl`);return`$RB.uop("${o}", ${h(n)})`},d.Constant=function(e){const n=typeof e.value;if("object"===n){const n=e.value.__class__.__qualname__,t=e.value.value;if("float"===n)return`${t}`;if("int"===n)return`${t}n`;if("NoneType"===n)return"null"}if("string"===n)return`"${e.value}"`;if("number"===n)return`${e.value}n`;if("boolean"===n)return`${e.value}`;throw console.warn(e,n),new Error(`Unknown Cste ${n}`)},d.Expr=function(e){return h(e.value)},d.Name=function(e){return e.id},d.JoinedStr=function(e){console.warn(e);let n="`";for(let t=0;t<e.values.length;++t){const o=e.values[t];n+="Constant"===b(o)?o.value:`\${${h(o.value)}}`}return n+="`",n},d.If=function(e){let n=`if( ${h(e.test)} ) {\n        ${y(e.body)}\n    }`;for(let t=0;t<e.orelse.length;++t){const o=e.orelse[t];n+="If"===b(o)?"else "+h(o):`else { ${h(o)} }`}return n},d.While=function(e){return`while( ${h(e.test)} ) {\n        ${y(e.body)}\n    }`},d.For=function(e){return`for(${h(e.target)} of ${h(e.iter)}){\n        ${y(e.body)}\n    }`},d.Try=function(e){return`try {\n        ${y(e.body)}\n    } catch {\n        ${y(e.handlers[0].body)}\n    }`},d.Match=function(e){let n="{";n+=`const tname = type(${h(e.subject)}).name;`;for(let t=0;t<e.cases.length-1;++t)0!==t&&(n+="else "),n+=`if( tname === "${e.cases[t].pattern.cls.id}") {\n            ${y(e.cases[t].body)}\n        }`;return n+=`else {\n            ${y(e.cases[e.cases.length-1].body)}\n    }`,n+="}",n},d.Continue=function(e){return"continue;"},d.Break=function(e){return"break;"},d.Raise=function(e){return`throw ${h(e.exc)};`},d.ImportFrom=function(e){const n=e.module;if("RBM"===n)return"";if("types"===n||"typing"===n)return"";if("functools"===n)return console.warn("Import not implemented yet"),"";let t="const {";for(let n=0;n<e.names.length;++n)t+=`${e.names[n].name},`;return t+`} = $RB.getModule("${n}")`},d.Import=function(e){const n=e.names[0].name;return"RBM"===n?"":`const ${n} = $RB.getModule("${n}")`},S.__DISPATCH__=(...e)=>{let n="((fct) => {\n\n        const registered = {";for(let t=0;t<e[0].keys.length;++t)n+=`${h(e[0].keys[t])}: ${h(e[0].values[t])},`;return n+='};\n    \n        function _(...args) {\n            let f = registered[type(args[0]).name];\n            if( f === undefined )\n                f = fct;\n            return f.call(null, this, ...args);\n        }\n\n        Object.defineProperty(_, "name", {value: fct.name});\n    \n        return _;\n    })',n},S.__JS_WRITE__=e=>e.value,S.__JS_OP__=(...e)=>2===e.length?`${e[0].value}${h(e[1])}`:`${h(e[0])} ${e[1].value} ${h(e[2])}`,S.__JS_RUN__=(...e)=>{return`(${n=e[0].value,n.replaceAll("\\n\\","\n")})(${e.slice(1).map((e=>h(e))).join(",")})`;var n};const J={int:t(541).A,float:t(180).A,bool:t(116).A,str:t(711).A};class T extends r{constructor(){super(),this.initialize()}run(e){this.loadAsFunction(this.emit(this.parse(e)))()}#e=!1;initialize(){for(let e in J)this.run(J[e]);this.#e=!0}parse(e){return _(e,"_")}emit(e){return function(e){return y(e.ast.body)}(e)}loadAsFunction(e){return Function("'use strict';"+e)}}const O=class{static getBrythonEngine(){return new s}static getRBrythonEngine(){return new T}};var P=o.A;export{P as default};
//# sourceMappingURL=index.js.map