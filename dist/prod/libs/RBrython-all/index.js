var e={116:(e,t,n)=>{n.d(t,{A:()=>r});const r='from RBM import __JS_OP__, boolean\n\nclass bool(boolean): # type: ignore (bool is Final)\n    def __eq__(self, o: object, /) -> bool:\n        return __JS_OP__(self, "==", o)'},180:(e,t,n)=>{n.d(t,{A:()=>r});const r='from types import NotImplementedType\nfrom RBM import __JS_OP__, __JS_AS_NUMBER__, __JS_WRITE__, number\n\nclass float(number):\n    def __new__(cls, o: object, /) -> float:\n        if type(o) is str:\n            if o == "infinity" or o == "inf":\n                return __JS_WRITE__("Number.POSITIVE_INFINITY") # pyright: ignore[reportReturnType]\n            if o == "-infinity" or o == "-inf":\n                return __JS_WRITE__("Number.NEGATIVE_INFINITY") # pyright: ignore[reportReturnType]\n            return __JS_AS_NUMBER__(o)\n        return type(o).__float__(o) # type: ignore\n    \n    def __eq__(self, o: object, /) -> bool:\n        return __JS_OP__(self, "==", o)    \n\n    def __add__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(self, "+", o)\n            case int  (): return __JS_OP__(self, "+", __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n\n    def __radd__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(o                  , "+", self)\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), "+", self)\n            case _      : return NotImplemented\n\n    def __sub__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(self, "-", o)\n            case int  (): return __JS_OP__(self, "-", __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n\n    def __rsub__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(o                  , "-", self)\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), "-", self)\n            case _      : return NotImplemented\n\n    def __mul__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(self, "*", o)\n            case int  (): return __JS_OP__(self, "*", __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n\n    def __rmul__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(o                  , "*", self)\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), "*", self)\n            case _      : return NotImplemented\n\n    def __div__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(self, "/", o)\n            case int  (): return __JS_OP__(self, "/", __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n\n    def __rdiv__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(o                  , "/", self)\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), "/", self)\n            case _      : return NotImplemented\n\n    ### unary operators ###\n\n    def __neg__(self, /) -> float:\n        return __JS_OP__("-", self)\n    \n    def __int__(self, /) -> int:\n        return __JS_RUN__(\'(x) => Math.trunc(x)\', self) # type: ignore\n    \n    def __abs__(self, /) -> int:\n         return __JS_RUN__(\'(x) => Math.abs(x)\', self) # type: ignore'},541:(e,t,n)=>{n.d(t,{A:()=>r});const r='from types     import NotImplementedType\n\nfrom RBM import __JS_AS_NUMBER__, __JS_OP__, bigint\n\nclass int(bigint):\n\n    def __new__(cls, o: object, base: int, /) -> int:\n        if type(o) == str:\n            return __JS_RUN__( # type: ignore\n                \'\'\'\n                    (x, base) => {\n                        if( base !== 16)\n                            return BigInt(x);\n                        \n                        let result = 0n;\n                        for(let i = 2; i < x.length; ++i)\n                            result = result << 4n + BigInt( parseInt(this.slice(i, i+8), 16) );\n                        return result;\n                    }\n                \'\'\', o, base) # type: ignore\n        return type(o).__int__(o) # type: ignore\n    \n    def __eq__(self, o: object, /) -> bool:\n        return __JS_OP__(self, "==", o)\n\n\n    def __add__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "+", o)\n            case _      : return NotImplemented\n    \n    def __radd__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(o, "+", self)\n            case _      : return NotImplemented\n    \n\n    def __sub__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "-", o)\n            case _      : return NotImplemented\n    \n    def __rsub__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(o, "-", self)\n            case _      : return NotImplemented\n    \n    def __mul__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "*", o)\n            case _      : return NotImplemented\n    \n    def __rmul__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(o, "*", self)\n            case _      : return NotImplemented\n\n    def __pow__(self, o: object, mod: int|None = None, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "**", o)\n            case _      : return NotImplemented\n    \n    def __rpow__(self, o: object, mod: int|None = None, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(o, "**", self)\n            case _      : return NotImplemented\n\n    def __div__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(self),\n                                           "/",\n                                           __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n    \n    def __rdiv__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o),\n                                           "*",\n                                           __JS_AS_NUMBER__(self) )\n            case _      : return NotImplemented\n\n    def __mod__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "%", o)\n            case _      : return NotImplemented\n    \n    def __rmod__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "%", o)\n            case _      : return NotImplemented\n    \n    def __or__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "|", o)\n            case _      : return NotImplemented\n    \n    def __ror__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "|", o)\n            case _      : return NotImplemented\n\n    def __and__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "&", o)\n            case _      : return NotImplemented\n    \n    def __rand__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "&", o)\n            case _      : return NotImplemented\n        \n    def __xor__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "^", o)\n            case _      : return NotImplemented\n    \n    def __rxor__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "^", o)\n            case _      : return NotImplemented\n\n    def __lshift__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "<<", o)\n            case _      : return NotImplemented\n    \n    def __rlshift__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "<<", o)\n            case _      : return NotImplemented\n\n    def __rshift__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, ">>", o)\n            case _      : return NotImplemented\n    \n    def __rrshift__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, ">>", o)\n            case _      : return NotImplemented\n    \n    ### unary operators ###\n    def __invert__(self, /) -> int:\n        return __JS_OP__("~", self)\n\n    def __neg__(self, /) -> int:\n        return __JS_OP__("-", self)\n    \n    def __abs__(self, /) -> int:\n         return __JS_RUN__("x => x < 0n ? -x : x", self) # type: ignore'},711:(e,t,n)=>{n.d(t,{A:()=>r});const r='from types     import NotImplementedType\nfrom RBM import __JS_OP__, string\n\nclass str(string):\n    def __new__(cls, o: object, /) -> str:\n        return __JS_AS_STRING__(o) # type: ignore\n        #return type(o).__str__(o) # type: ignore\n    \n    def __eq__(self, o: object, /) -> bool:\n        return __JS_OP__(self, "==", o)\n\n    def __mul__(self, o: object, /) -> NotImplementedType|str:\n        match o:\n            case int  (): return __JS_WRITE__("self.repeat(Number(b))") # type: ignore\n            case _      : return NotImplemented\n    \n    def __rmul__(self, o: object, /) -> NotImplementedType|str:\n        match o:\n            case int  (): return __JS_WRITE__("self.repeat(Number(b))") # type: ignore\n            case _      : return NotImplemented'}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var _=t[r]={exports:{}};return e[r](_,_.exports,n),_.exports}n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var r={};function o(e,t){const n=new $B.Parser(e,t,"file"),r=$B._PyPegen.run_parser(n),o=$B.future_features(r,t);return{filename:t,pycode:e,ast:r,symtable:$B._PySymtable_Build(r,t,o)}}n.d(r,{A:()=>U});class _{}class s extends _{registerBuiltins(e){for(let t in e)this.registerBuiltin(t,e[t])}registerBuiltin(e,t){$B.builtins[e]=$B.jsobj2pyobj(t)}registerModule(e,t){$B.imported[e]=$B.jsobj2pyobj(t)}getModule(e){return $B.imported[e]}loadAsFunction(e){return $B.imported._={},Function("'use strict';"+e)}}class l{}class i extends l{parser;emitter;runner;constructor(e,t,n){super(),this.parser=e,this.emitter=t,this.runner=n}run(e){return this.loadAsFunction(this.emit(this.parse(e)))()}registerModule(e,t){"string"==typeof t&&(t=this.run(t)),this.runner.registerModule(e,t)}getModule(e){return this.runner.getModule(e)}registerBuiltins(e){"string"==typeof e&&(e=this.run(e)),this.runner.registerBuiltins(e)}registerBuiltin(e,t){this.runner.registerBuiltin(e,t)}registerMacros(e){this.emitter.registerMacros(e)}registerMacro(e,t){this.emitter.registerMacro(e,t)}parse(e){return this.parser(e,"_")}emit(e){return this.emitter.emit(e)}loadAsFunction(e){return this.runner.loadAsFunction(e)}}class a{__call__(...e){const t=this.prototype.__new__,n=void 0!==t?t.call(this,...e):new this(...e),r=this.prototype.__init__;return void 0!==r&&r.call(n,...e),n}__eq__(e){return this==e}}const u={bigint:"int",number:"float",string:"str",boolean:"bool"};function c(e){const t=typeof e;if("function"===t)return a;if("object"===t)return e.constructor;const n=globalThis[u[t]];if(void 0!==n)return n;throw new Error(`JS type ${t} not implemented yet`)}const f=Symbol(),m={eq:function(e){return this==e}};let p=null;const d=Symbol(),g={};class b extends _{#e=g;#t={};loadAsFunction(e){return Function("'use strict';"+e+"; return __exported__;")}registerModule(e,t){this.#e[e]=t}getModule(e){return this.#e[e]}registerBuiltins(e){for(let t in e)this.registerBuiltin(t,e[t])}registerBuiltin(e,t){this.#t[e]=t,globalThis[e]=t}}globalThis.$RB={op:function(e,t,n){const r=c(e);if(void 0===r)throw console.warn(e,t),new Error("?");let o=r.prototype[`__${t}__`];if(void 0===o){if("ne"===t)return!r.prototype.__eq__.call(e,n);"i"===t[0]&&(o=r.prototype[`__${t.slice(1)}__`]),void 0===o&&(o=m[t])}let _=o.call(e,n);if(_===f){const r=c(n);if(void 0===r)throw console.warn(n,"r"+t),new Error("?");_=r.prototype[`__r${t}__`].call(n,e)}return _},uop:function(e,t){if("not"===e)return!t;const n=c(t);if(void 0===n)throw console.warn(t,e),new Error("?");return n.prototype[`__${e}__`].call(t)},call:function(e,...t){t[t.length-1]===d&&(t=t.slice(0,-1));let n=e.__call__;if(void 0===n){if(n=e,void 0!==n.prototype?.__new__){const e=c(n).prototype.__call__;if(void 0!==e)return e.call(n,...t)}if(r=n,!1===Object.getOwnPropertyDescriptors(r)?.prototype?.writable)return new n(...t)}var r;return n(...t)},mcall:function(e,t,...n){return n[n.length-1]===d&&(n=n.slice(0,-1)),void 0===e[t]?e.prototype[t].call(...n):e[t](...n)},assert:function(e){if(!e)throw new Error("Assertion failed")},attr:function(e,t){return t in e?e[t]:e.constructor[t]},setattr:function(e,t,n){return e[t]=n},getKW:function(){if(null===p)return{};const e=p;return p=null,e},setKW:function(e){return p=e,d},getModule:function(e){const t=g[e];if(void 0===t)throw new Error(`module ${e} not found`);return t}},globalThis.abs=function(e){return c(e).prototype.__abs__.call(e)},globalThis.type=function(e){return c(e)},globalThis.NotImplemented=f,globalThis.range=function*(e){for(let t=0;t<e;++t)yield t},globalThis.Exception=function(e){throw new Error(e)};const y=Symbol();globalThis.__JS_SET_IVALUE__=(e,t)=>e[y]=t,globalThis.__JS_GET_IVALUE__=e=>e[y];const h={};function $(e){return e.constructor.$name}function S(e){return e.constructor.$name}function N(e,t,...n){const r=h[$(e)];if(void 0===r)throw console.warn(e),new Error(`Node type ${$(e)} is unknown`);return r(e,t,...n)}function I(e,t){let n="";for(let r=0;r<e.length;++r)n+=N(e[r],t)+";\n";return n}const J={Add:"add",Sub:"sub",Mult:"mul",Div:"div",Pow:"pow",Mod:"mod",BitOr:"or",BitAnd:"and",LShift:"lshift",RShift:"rshift"},B={},O={Eq:"eq",NotEq:"ne"},v={Invert:"invert",USub:"neg",Not:"not"};h.ClassDef=function(e,t){const n=e.name,r=e.body,o=t.children.find((e=>e.name===n));let _=`var ${n} = (() =>{\n        function ${n}() {\n            return Object.create(${n}.prototype);\n        }\n    `;if((1!==e.bases.length||!["number","bigint","boolean","string"].includes(e.bases[0].id))&&e.bases.length>=1){_+=`${n}.prototype = Object.create(${N(e.bases[0])}.prototype);\n`;for(let t=1;t<e.bases.length;++t)_+=`Object.assign(${n}.prototype, ${N(e.bases[t])}.prototype);`;_+=`${n}.prototype.constructor = ${n};\n`}return _+=I(r,o),_+=`\n        return ${n};\n    })();\n    `,_},h.FunctionDef=function(e,t){const n=1===t.type,r=e.name,o=e.body,_=t.children.find((e=>e.name===r));let s="";1===t.type&&(s+=`${t.name}.prototype.${r} = `);for(let t=0;t<e.decorator_list.length;++t)s+=`${N(e.decorator_list[t])}(`;if(s+=`function ${r}(`,s+=N(e.args,t,n),s+="){",n){let t="";t=e.args.posonlyargs.length>0?e.args.posonlyargs[0].arg:e.args.args[0].arg,s+=`const ${t} = this;`}s+=`\n        ${I(o,_)}\n    }`;for(let t=0;t<e.decorator_list.length;++t)s+=")";return s},h.Lambda=function(e,t){return`(${N(e.args,t)}) => { return ${N(e.body)}}`},h.arguments=function(e,t,n=!1){let r="",o=0,_=0;n&&(e.posonlyargs.length?++o:++_);for(let t=o;t<e.posonlyargs.length;++t)r+=`${e.posonlyargs[t].arg}, `;for(let t=_;t<e.args.length;++t)r+=`_${e.args[t].arg}, `;if(e.args.length){r+="{";for(let t=_;t<e.args.length;++t)r+=`${e.args[t].arg} = _${e.args[t].arg}, `;r+="} = $RB.getKW()"}return r},h.Assert=function(e){return`$RB.assert(${N(e.test)})`},h.Pass=function(e){return""},h.Return=function(e){return`return ${N(e.value)}`},h.Assign=function(e,t){let n="",r="var ";if("Attribute"===$(e.targets[0]))return`$RB.setattr(${N(e.targets[0].value)}, "${e.targets[0].attr}", ${N(e.value)})`;for(let t=1;t<e.targets.length;++t)n+=`${r}${N(e.targets[t])};`;n+=r+N(e.targets[0])+" = ";for(let t=1;t<e.targets.length;++t)n+=N(e.targets[t])+" = ";return n+N(e.value)},h.Attribute=function(e){return`$RB.attr(${N(e.value)}, "${e.attr}")`},h.AugAssign=function(e){const t=e.target,n=S(e.op),r=e.value,o=J[n];if(void 0===o)throw new Error(`BinOp ${n} not impl`);return`${N(t)} = $RB.op(${N(t)}, "i${o}", ${N(r)})`},h.BinOp=function(e){const t=e.left,n=e.right,r=S(e.op),o=J[r];if(void 0===o)throw new Error(`BinOp ${r} not impl`);return`$RB.op(${N(t)}, "${o}", ${N(n)})`},h.Call=function(e){const t=e.func,n=e.args,r=e.keywords;if(t.id in B)return B[t.id](...e.args);let o="";for(let e=0;e<n.length;++e)o+=N(n[e])+", ";if(r.length){o+="$RB.setKW({";for(let e=0;e<r.length;++e)o+=`${r[e].arg}: ${N(r[e].value)},`;o+="})"}if("Attribute"===$(t)){const e=t;return`$RB.mcall(${N(e.value)}, "${e.attr}", ${o} )`}return`$RB.call(${N(t)}, ${o})`},h.Compare=function(e){const t=e.left,n=S(e.ops[0]),r=e.comparators[0];if("Is"===n)return`${N(t)} === ${N(r)}`;const o=O[n];if(void 0===o)throw console.warn(n),new Error(`CmpOp ${n} not impl`);return`$RB.op(${N(t)}, "${o}", ${N(r)})`},h.UnaryOp=function(e){const t=e.operand,n=S(e.op),r=v[n];if(void 0===r)throw new Error(`UnaryOp ${n} not impl`);return`$RB.uop("${r}", ${N(t)})`},h.Constant=function(e){const t=typeof e.value;if("object"===t){const t=e.value.__class__.__qualname__,n=e.value.value;if("float"===t)return`${n}`;if("int"===t)return`${n}n`;if("NoneType"===t)return"null"}if("string"===t)return`"${e.value}"`;if("number"===t)return`${e.value}n`;if("boolean"===t)return`${e.value}`;throw console.warn(e,t),new Error(`Unknown Cste ${t}`)},h.Expr=function(e){return N(e.value)},h.Name=function(e){return e.id},h.JoinedStr=function(e){console.warn(e);let t="`";for(let n=0;n<e.values.length;++n){const r=e.values[n];t+="Constant"===$(r)?r.value:`\${${N(r.value)}}`}return t+="`",t},h.If=function(e,t){let n=`if( ${N(e.test)} ) {\n        ${I(e.body,t)}\n    }`;for(let t=0;t<e.orelse.length;++t){const r=e.orelse[t];n+="If"===$(r)?"else "+N(r):`else { ${N(r)} }`}return n},h.While=function(e,t){return`while( ${N(e.test)} ) {\n        ${I(e.body,t)}\n    }`},h.For=function(e,t){return`for(${N(e.target)} of ${N(e.iter)}){\n        ${I(e.body,t)}\n    }`},h.Try=function(e,t){return`try {\n        ${I(e.body,t)}\n    } catch {\n        ${I(e.handlers[0].body,t)}\n    }`},h.Match=function(e,t){let n="{";n+=`const tname = type(${N(e.subject)}).name;`;for(let r=0;r<e.cases.length-1;++r)0!==r&&(n+="else "),n+=`if( tname === "${e.cases[r].pattern.cls.id}") {\n            ${I(e.cases[r].body,t)}\n        }`;return n+=`else {\n            ${I(e.cases[e.cases.length-1].body,t)}\n    }`,n+="}",n},h.Continue=function(e){return"continue;"},h.Break=function(e){return"break;"},h.Raise=function(e){return`throw ${N(e.exc)};`},h.ImportFrom=function(e){const t=e.module;if("RBM"===t)return"";if("types"===t||"typing"===t)return"";if("functools"===t)return console.warn("Import not implemented yet"),"";let n="const {";for(let t=0;t<e.names.length;++t)n+=`${e.names[t].name},`;return n+`} = $RB.getModule("${t}")`},h.Import=function(e){const t=e.names[0].name;return"RBM"===t?"":`const ${t} = $RB.getModule("${t}")`},h.BoolOp=function(e){const t=S(e.op);let n="";return"Or"===t&&(n="||"),"And"===t&&(n="&&"),`${N(e.values[0])}${n}${N(e.values[1])}`};class T{}class w extends T{macros=B;registerMacros(e){for(let t in e)this.macros[t]=e[t]}registerMacro(e,t){this.macros[e]=t}emit(e){return`${I(e.ast.body,e.symtable)}\nconst __exported__ = {${this.extractExportedSymbols(e).join(",")}}`}extractExportedSymbols(e){const t=e.symtable.symbols.$strings;return Object.keys(t).filter((e=>4098===t[e]))}}class P extends T{emit(e){return $B.js_from_root({ast:e.ast,symtable:e.symtable,filename:e.filename,src:e.pycode,imported:void 0}).js}registerMacros(e){throw new Error("Not implemented")}registerMacro(e,t){throw new Error("Not implemented")}}function j(...e){return 2===e.length?`${e[0].value}${N(e[1])}`:`${N(e[0])} ${e[1].value} ${N(e[2])}`}function R(...e){return`(${t=e[0].value,t=t.replaceAll("\\n\\","\n")})(${e.slice(1).map((e=>N(e))).join(",")})`;var t}function E(e){return e.value}function M(...e){let t="console.log(";for(let n=0;n<e.length;++n)t+=N(e[n])+",";return t+=");",t}function A(e){return"`${"+N(e)+"}`"}function x(e){return`Number(${N(e)})`}const U=class{static getBrythonEngine(){return function(){const e=new P,t=new s,n=new i(o,e,t);return n.registerModule("JS",globalThis),n}()}static getRBrythonEngine(){return function(){const e=new w,t=new b,r=new i(o,e,t);r.registerMacros({__JS_OP__:j,__JS_AS_STRING__:A,__JS_AS_NUMBER__:x,__JS_LOG__:M,__JS_RUN__:R,__JS_WRITE__:E}),r.registerModule("JS",globalThis);const _=[n(541).A,n(180).A,n(116).A,n(711).A];for(let e of _)r.registerBuiltins(e);return r}()}};var F=r.A;export{F as default};
//# sourceMappingURL=index.js.map