{"version":3,"file":"libs/RBrython-all/index.js","mappings":"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","sources":["webpack://rbrython/./src/rbry/emitter/hmacros/BE.ts","webpack://rbrython/./src/rbry/macros/__JS_OP__.ts","webpack://rbrython/./src/rbry/engines/Brython/index.ts","webpack://rbrython/./src/rbry/engines/index.ts","webpack://rbrython/./src/rbry/emitter/hmacros/list.ts","webpack://rbrython/./src/rbry/corelib/primitives/str.py","webpack://rbrython/./src/rbry/emitter/handlers/vars/JoinedStr.ts","webpack://rbrython/./src/rbry/emitter/hmacros/tmp.ts","webpack://rbrython/./src/rbry/emitter/handlers/operators/UnaryOp.ts","webpack://rbrython/./src/rbry/emitter/handlers/vars/Nonlocal.ts","webpack://rbrython/./src/rbry/emitter/handlers/operators/Attribute.ts","webpack://rbrython/./src/rbry/emitter/handlers/definitions/ClassDef.ts","webpack://rbrython/./src/rbry/emitter/handlers/vars/Expr.ts","webpack://rbrython/./src/rbry/corelib/iterators/range.py","webpack://rbrython/./src/rbry/emitter/handlers/controlflows/For.ts","webpack://rbrython/./src/rbry/emitter/handlers/vars/Tuple.ts","webpack://rbrython/./src/rbry/macros/__JS_RUN__.ts","webpack://rbrython/./src/rbry/corelib/primitives/tuple.py","webpack://rbrython/./src/rbry/optimizers/safe/hmacros/bool.ts","webpack://rbrython/./src/rbry/ast/index.ts","webpack://rbrython/./src/rbry/emitter/hmacros/BB.ts","webpack://rbrython/./src/rbry/emitter/exports/return.ts","webpack://rbrython/./src/rbry/corelib/Exception.py","webpack://rbrython/./src/rbry/emitter/handlers/vars/DictComp.ts","webpack://rbrython/./src/rbry/emitter/EmitContext.ts","webpack://rbrython/./src/rbry/emitter/handlers/controlflows/IfExp.ts","webpack://rbrython/./src/rbry/optimizers/safe/hmacros/getTmp.ts","webpack://rbrython/./src/rbry/corelib/primitives/float.py","webpack://rbrython/./src/rbry/corelib/primitives/object.py","webpack://rbrython/./src/rbry/emitter/handlers/keywords/Return.ts","webpack://rbrython/./src/rbry/runners/interface.ts","webpack://rbrython/./src/rbry/corelib/isinstance.py","webpack://rbrython/./src/rbry/emitter/handlers/operators/BoolOp.ts","webpack://rbrython/./src/rbry/corelib/operators/len.py","webpack://rbrython/./src/rbry/emitter/handlers/operators/NamedExpr.ts","webpack://rbrython/./src/rbry/corelib/print/format.py","webpack://rbrython/./src/rbry/emitter/handlers/vars/GeneratorExp.ts","webpack://rbrython/./src/rbry/optimizers/index.ts","webpack://rbrython/./src/rbry/checker/handlers/vars/Constant.ts","webpack://rbrython/./src/rbry/macros/__JS_LOG__.ts","webpack://rbrython/./src/rbry/emitter/handlers/operators/Compare.ts","webpack://rbrython/./src/rbry/emitter/hmacros/withTmp.ts","webpack://rbrython/./src/rbry/emitter/handlers/vars/Name.ts","webpack://rbrython/./src/rbry/corelib/primitives/list.py","webpack://rbrython/./src/rbry/emitter/hmacros/getTmp.ts","webpack://rbrython/./src/rbry/emitter/handlers/operators/BinOp.ts","webpack://rbrython/./src/rbry/emitter/handlers/index.ts","webpack://rbrython/./src/rbry/emitter/handlers/operators/AugAssign.ts","webpack://rbrython/./src/rbry/macros/__JS_WRITE__.ts","webpack://rbrython/./src/rbry/emitter/handlers/definitions/AsyncFunctionDef.ts","webpack://rbrython/./src/rbry/macros/__JS_AS_BIGINT__.ts","webpack://rbrython/./src/rbry/corelib/print/print.py","webpack://rbrython/./src/rbry/emitter/targets/function.ts","webpack://rbrython/./src/rbry/emitter/exports/brython.ts","webpack://rbrython/./src/rbry/engines/Base/index.ts","webpack://rbrython/./src/rbry/engines/RBrython/index.ts","webpack://rbrython/./src/rbry/emitter/handlers/controlflows/With.ts","webpack://rbrython/./src/rbry/corelib/primitives/bool.py","webpack://rbrython/./src/rbry/emitter/hmacros/saveTmp.ts","webpack://rbrython/./src/rbry/emitter/hmacros/NL.ts","webpack://rbrython/./src/rbry/emitter/handlers/operators/Subscript.ts","webpack://rbrython/./src/rbry/checker/handlers/index.ts","webpack://rbrython/./src/rbry/corelib/iterators/next.py","webpack://rbrython/./src/rbry/corelib/operators/abs.py","webpack://rbrython/./src/rbry/parser/index.ts","webpack://rbrython/./src/rbry/emitter/handlers/vars/List.ts","webpack://rbrython/./src/rbry/emitter/handlers/vars/Dict.ts","webpack://rbrython/./src/rbry/corelib/primitives/type.py","webpack://rbrython/./src/rbry/emitter/targets/raw.ts","webpack://rbrython/./src/rbry/emitter/handlers/keywords/Assert.ts","webpack://rbrython/./src/rbry/emitter/handlers/imports/ImportFrom.ts","webpack://rbrython/./src/rbry/emitter/handlers/keywords/Delete.ts","webpack://rbrython/./src/rbry/emitter/handlers/list.ts","webpack://rbrython/./src/rbry/emitter/handlers/keywords/Pass.ts","webpack://rbrython/./src/rbry/checker/handlers/definitions/FunctionDef.ts","webpack://rbrython/./src/rbry/emitter/handlers/keywords/Await.ts","webpack://rbrython/./src/rbry/corelib/primitives/dict.py","webpack://rbrython/./src/rbry/emitter/handlers/definitions/Arguments.ts","webpack://rbrython/./src/rbry/corelib/primitives/int.py","webpack://rbrython/./src/rbry/emitter/handlers/keywords/Raise.ts","webpack://rbrython/./src/rbry/emitter/handlers/operators/Call.ts","webpack://rbrython/./src/rbry/optimizers/safe/hmacros/saveTmp.ts","webpack://rbrython/./src/rbry/emitter/handlers/controlflows/If.ts","webpack://rbrython/./src/rbry/emitter/handlers/definitions/FunctionDef.ts","webpack://rbrython/./src/rbry/emitter/handlers/operators/Assign.ts","webpack://rbrython/./src/rbry/emitter/hmacros/bool.ts","webpack://rbrython/./src/rbry/emitter/handlers/vars/Constant.ts","webpack://rbrython/./src/rbry/corelib/print/repr.py","webpack://rbrython/./src/rbry/runners/BrythonGlobalRunner.ts","webpack://rbrython/./src/rbry/emitter/exports/global.ts","webpack://rbrython/./src/rbry/emitter/handlers/keywords/YieldFrom.ts","webpack://rbrython/./src/rbry/optimizers/safe/hmacros/index.ts","webpack://rbrython/./src/rbry/emitter/handlers/definitions/Lambda.ts","webpack://rbrython/./src/rbry/emitter/handlers/vars/ListComp.ts","webpack://rbrython/./src/rbry/macros/__JS_AWAIT__.ts","webpack://rbrython/./src/rbry/macros/__JS_AS_STRING__.ts","webpack://rbrython/./src/rbry/macros/__JS_SHADOW__.ts","webpack://rbrython/./src/rbry/checker/Walker.ts","webpack://rbrython/./src/rbry/checker/types/index.ts","webpack://rbrython/./src/rbry/checker/handlers/operators/UnaryOp.ts","webpack://rbrython/./src/rbry/optimizers/safe/handlers/index.ts","webpack://rbrython/./src/rbry/emitter/handlers/controlflows/Try.ts","webpack://rbrython/./src/rbry/emitter/index.ts","webpack://rbrython/./src/rbry/emitter/handlers/keywords/Continue.ts","webpack://rbrython/./src/rbry/emitter/handlers/controlflows/While.ts","webpack://rbrython/./src/rbry/macros/__JS_AS_NUMBER__.ts","webpack://rbrython/./src/rbry/ast/types/index.ts","webpack://rbrython/./src/rbry/runners/RBrythonGlobalRunner.ts","webpack://rbrython/./src/rbry/engines/interface.ts","webpack://rbrython/./src/rbry/optimizers/safe/handlers/Call.ts","webpack://rbrython/./src/rbry/emitter/handlers/vars/Global.ts","webpack://rbrython/./src/rbry/runlib/interface/shadowJS.ts","webpack://rbrython/./src/rbry/runlib/helpers/getClass.ts","webpack://rbrython/./src/rbry/runlib/interface/op.ts","webpack://rbrython/./src/rbry/runlib/interface/KW.ts","webpack://rbrython/./src/rbry/runlib/interface/tmp.ts","webpack://rbrython/./src/rbry/runlib/index.ts","webpack://rbrython/./src/rbry/runlib/interface/uop.ts","webpack://rbrython/./src/rbry/runlib/interface/call.ts","webpack://rbrython/./src/rbry/runlib/helpers/isClass.ts","webpack://rbrython/./src/rbry/runlib/interface/mcall.ts","webpack://rbrython/./src/rbry/runlib/interface/assert.ts","webpack://rbrython/./src/rbry/runlib/interface/getitem.ts","webpack://rbrython/./src/rbry/runlib/interface/setitem.ts","webpack://rbrython/./src/rbry/runlib/interface/delitem.ts","webpack://rbrython/./src/rbry/runlib/interface/getattr.ts","webpack://rbrython/./src/rbry/runlib/interface/setattr.ts","webpack://rbrython/./src/rbry/runlib/interface/delattr.ts","webpack://rbrython/./src/rbry/runlib/interface/getModule.ts","webpack://rbrython/./src/rbry/runlib/interface/getModuleSync.ts","webpack://rbrython/./src/rbry/runlib/interface/in.ts","webpack://rbrython/./src/rbry/runlib/interface/ro.ts","webpack://rbrython/./src/rbry/emitter/handlers/imports/Import.ts","webpack://rbrython/./src/rbry/optimizers/safe/hmacros/tmp.ts","webpack://rbrython/./src/rbry/emitter/handlers/keywords/Break.ts","webpack://rbrython/./src/rbry/emitter/handlers/keywords/Yield.ts","webpack://rbrython/./src/rbry/optimizers/safe/hmacros/withTmp.ts","webpack://rbrython/./src/rbry/checker/handlers/operators/Compare.ts","webpack://rbrython/./src/rbry/emitter/exports/module.ts","webpack://rbrython/./src/rbry/emitter/handlers/controlflows/Match.ts","webpack://rbrython/webpack/bootstrap","webpack://rbrython/webpack/runtime/define property getters","webpack://rbrython/webpack/runtime/hasOwnProperty shorthand","webpack://rbrython/./src/rbry/emitter/targets/brython.ts","webpack://rbrython/./src/rbry/emitter/targets/module.ts","webpack://rbrython/./src/rbry/emitter/targets/index.ts","webpack://rbrython/./src/libs/RBrython-all/index.ts"],"sourcesContent":["import { EmitContext } from \"../EmitContext\";\n\nexport default function BE() {\n    return function(ctx: EmitContext) {\n        --ctx.indent_level;\n        ctx.w_line();\n    }\n}","import { ASTNode } from \"../ast/types\";\nimport { EmitContext } from \"../emitter/EmitContext\";\n\nexport default function __JS_OP__(ctx: EmitContext, ...args: ASTNode[]) {\n    \n    if(args.length === 2) {// unary op\n        // @ts-ignore\n        const op = args[0].value;\n        ctx.w`${op}${args[1]}`;\n        return;\n    }\n    \n    // binary op\n    // @ts-ignore\n    const op = args[1].value;\n\n    if( op === \"[]\")\n        return ctx.w`${args[0]}[${args[2]}]`;\n\n    ctx.w`${args[0]} ${op} ${args[2]}`;\n}","import { ParsedCode } from \"../../ast/types\";\nimport parse from \"../../parser\";\nimport BrythonGlobalRunner from \"@RBrython/rbry/runners/BrythonGlobalRunner\";\nimport BaseEngine from \"../Base\";\nimport { Emitter } from \"@RBrython/rbry/emitter\";\nimport { Macro } from \"@RBrython/rbry/emitter/EmitContext\";\n\nfunction asFct(jscode: string) {\n    return `(function($RB){\"use strict\";${jscode}})`;\n}\n\nclass BrythonEmitter extends Emitter {\n    emit(parsed: ParsedCode) {\n\n        let imported:any;\n        return asFct($B.js_from_root({ast     : parsed.ast,\n                                symtable: parsed.symtable,\n                                filename: parsed.filename,\n                                src     : parsed.pycode,\n                                imported}).js);\n    }\n\n    override registerMacros(macros: Record<string, Macro>) {\n        throw new Error(\"Not implemented\");\n    }\n    override registerMacro(name: string, fct: Macro) {\n        throw new Error(\"Not implemented\");\n    }\n}\n\nexport default function BrythonEngineFactory() {\n\n    const emitter = new BrythonEmitter();\n    const runner  = new BrythonGlobalRunner();\n    const engine  = new BaseEngine(parse, emitter, runner);\n\n    engine.registerModule(\"JS\", globalThis);\n    \n    // builtins are already included in Brython.\n\n    return engine;\n}","import  BrythonEngineFactory from \"./Brython\";\nimport RBrythonEngineFactory from \"./RBrython\";\n\nexport default class Engines {\n    static getBrythonEngine() {\n        return  BrythonEngineFactory();\n    }\n    static getRBrythonEngine() {\n        return RBrythonEngineFactory();\n    }\n}","import { HMacro } from \"@RBrython/rbry/optimizers\";\n\nconst hmacros = {\n    NL     : require(\"./NL\")  .default as HMacro,\n    BB     : require(\"./BB\")  .default as HMacro,\n    BE     : require(\"./BE\")  .default as HMacro,\n    bool   : require(\"./bool\").default as HMacro,\n    tmp    : require(\"./tmp\").default as HMacro,\n    getTmp : require(\"./getTmp\").default as HMacro,\n    saveTmp: require(\"./saveTmp\").default as HMacro,\n    withTmp: require(\"./withTmp\").default as HMacro\n}\n\nexport default hmacros;","export default \"from types import NotImplementedType\\nfrom RBM import __JS_OP__, __JS_SHADOW__, string\\n\\n@__JS_SHADOW__(\\\"string\\\")\\nclass str(string):\\n    def __new__(cls, o: object, /) -> str:\\n        #return __JS_AS_STRING__(o) # type: ignore\\n        return type(o).__str__(o) # type: ignore\\n    \\n    def __eq__(self, o: object, /) -> bool:\\n        return __JS_OP__(self, \\\"==\\\", o)\\n    \\n    def __add__(self, o: object, /) -> NotImplementedType|str:\\n        match o:\\n            case str  (): return __JS_OP__(self, \\\"+\\\", o) # type: ignore\\n            case _      : return NotImplemented\\n\\n    def __mul__(self, o: object, /) -> NotImplementedType|str:\\n        match o:\\n            case int  (): return __JS_WRITE__(\\\"self.repeat(Number(b))\\\") # type: ignore\\n            case _      : return NotImplemented\\n    \\n    def __rmul__(self, o: object, /) -> NotImplementedType|str:\\n        match o:\\n            case int  (): return __JS_WRITE__(\\\"self.repeat(Number(b))\\\") # type: ignore\\n            case _      : return NotImplemented\";","import { nodeType } from \"../../../ast/\";\nimport { FormattedValueNode, JoinedStrNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function JoinedStr(node: JoinedStrNode, ctx: EmitContext) {\n\n    ctx.w_str(\"`\");\n    for(let i = 0; i < node.values.length; ++i) {\n        const value = node.values[i];\n        const type  = nodeType(value);\n\n        if( type === \"Constant\") {\n            ctx.w_str(value.value as string);\n            continue;\n        }\n\n        const val = value as FormattedValueNode;\n\n        if( val.format_spec === undefined ) {\n            ctx.w`\\${${value.value}}`;\n            continue;\n        }\n\n        ctx.w`\\${format(${value.value}, ${val.format_spec.values[0]})}`;\n    }\n    ctx.w_str(\"`\");\n}","import { EmitContext } from \"../EmitContext\";\n\nexport default function tmp() {\n    return function(ctx: EmitContext) {\n        ctx.w`$RB.tmp()`;\n    }\n}","import { UnaryOpNode } from \"../../../ast/types\";\nimport { getOp } from \"../../../ast/\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function(node: UnaryOpNode, ctx: EmitContext) {\n\n    const a = node.operand;\n    const op = getOp(node.op) as keyof typeof uops | \"Not\";\n\n    if( op === \"Not\") {\n        ctx.w`! ${ctx.hm.bool(a)}`;\n        return;\n    }\n\n    const opname = uops[op];\n    if( opname === undefined) \n        throw new Error(`UnaryOp ${op} not impl`);\n\n    ctx.w`$RB.uop(\"${opname}\", ${a})`;\n}\n\nconst uops = {\n    Invert: \"invert\",\n    USub  : \"neg\",\n    UAdd  : \"pos\",\n}","export default function Nonlocal() {\n    ;\n}","import { AttributeNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function (node: AttributeNode, ctx: EmitContext) {\n    ctx.w`$RB.getattr(${node.value}, \"${node.attr}\")`;\n}","import { ASTNode, ClassDefNode, SymTab } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nconst hacked = [\"number\", \"bigint\", \"boolean\", \"string\", \"obj\", \"ROArray\", \"Array\"]\n\nexport default function ClassDef(node: ClassDefNode, ctx: EmitContext) {\n\n    const name = node.name;\n    const body = node.body;\n\n    // JS cstr\n    ctx.w`var ${name} = `;\n\n    for(let i = 0; i < node.decorator_list.length; ++i) {\n        ctx.w_node(node.decorator_list[i]);\n        ctx.w_str(\"(\");\n    }\n    \n    ctx.w`(() =>{${ctx.hm.BB()}`\n        ctx.w`function ${name}(...args) {${ctx.hm.BB()}`\n            ctx.w`return type.prototype.__call__.call(${name}, ...args)`;\n            //ctx.w`return Object.create(${name}.prototype);`\n        ctx.w`${ctx.hm.BE()}}${ctx.hm.NL()}`\n\n    // inheritance\n    let bases: (ASTNode|string)[] = node.bases;\n\n    // @ts-ignore\n    const isH4ck = bases.length >= 1 && hacked.includes(bases[0].id);\n\n    if( isH4ck )\n        bases = bases.slice(1);\n\n    if( bases.length === 0 )\n        bases = [\"object\"];\n\n    // avoid auto-inheritance.\n    if( name !== \"object\" ) {\n        ctx.w`${name}.prototype = Object.create(${bases[0]}.prototype);${ctx.hm.NL()}`;\n\n        for(let i = 1; i < bases.length; ++i) {\n            ctx.w`Object.assign(${name}.prototype, ${bases[i]}.prototype);${ctx.hm.NL()}`;\n        }\n    \n        ctx.w`${name}.prototype.constructor = ${name};`;\n    }\n\n    ctx.w`${ctx.hm.BE()}`;\n\n    // body...\n    ctx.w_body(body);\n\n    ctx.w`${ctx.hm.BB()}return ${name};${ctx.hm.BE()}})()`;\n\n\n    for(let i = 0; i < node.decorator_list.length; ++i)\n        ctx.w_str(\")\");\n}","import { ExprNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Expr(node: ExprNode, ctx: EmitContext) {\n    ctx.w_node(node.value);\n}","export default \"def range(a1: int, a2: int|None = None, a3: int|None = None):\\n    beg = 0\\n    end = a1\\n    inc = 1\\n\\n    if a2 is not None:\\n        beg = a1\\n        end = a2\\n\\n        if a3 is not None:\\n            inc = a3\\n\\n    i = beg\\n    while i != end:\\n        yield i\\n        i += inc\";","\nimport { ForNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function For(node: ForNode, ctx: EmitContext) {\n    ctx.w`for(var ${node.target} of ${node.iter}){${node.body}}`;\n}","import { TupleNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Tuple(node: TupleNode, ctx: EmitContext) {\n    ctx.w`$RB.ro([`;\n\n    for(let i = 0; i < node.elts.length; ++i) {\n        ctx.w_node(node.elts[i]);\n        ctx.w_str(', ');\n    }\n\n    ctx.w`])`;\n}","import { ASTNode, StringNode } from \"../ast/types\";\nimport { EmitContext } from \"../emitter/EmitContext\";\n\nexport default function __JS_RUN__(ctx: EmitContext, code: ASTNode, ...args: ASTNode[]) {\n    \n    ctx.w`(${unescape((code as StringNode).value)})(`;\n    for(let i = 0; i < args.length; ++i)\n        ctx.w`${args[i]},`;    \n    ctx.w`)`;\n}\n\nfunction unescape(str: string) {\n    str = str.replaceAll(\"\\\\n\\\\\", \"\\n\");\n    return str;\n}","export default \"from RBM import __JS_OP__, __JS_SHADOW__, __JS_WRITE__, ROArray\\n\\n@__JS_SHADOW__(\\\"Array\\\", True)\\nclass tuple(ROArray):\\n    def __getitem__(self, i: int):\\n        return __JS_OP__(self, \\\"[]\\\", i)\\n    \\n    def __len__(self):\\n        return __JS_WRITE__(\\\"this.length\\\")\";","import { TypedASTNode } from \"@RBrython/rbry/checker/Walker\";\nimport { EmitContext } from \"@RBrython/rbry/emitter/EmitContext\";\nimport { HMacro } from \"../..\";\nimport { BoolType, isInstance } from \"@RBrython/rbry/checker/types\";\n\nexport default function bool(fallback: HMacro, node: TypedASTNode) {\n\n    if( isInstance(node.result_type, BoolType ) )\n        return (ctx: EmitContext) => ctx.w`(${node})`;\n\n    return fallback(node);\n\n    /* \n        return function(ctx: EmitContext) {\n            console.warn(node);\n            ctx.w`bool(${node})`;\n        }\n    */\n}","import { ASTNode, OperatorNode } from \"./types\";\n\nexport function isASTNode(o: unknown): o is ASTNode {\n    if( o == null)\n        return false;\n    return \"$name\" in (o as object).constructor;\n}\n\nexport function nodeType(node: ASTNode): string {\n    // @ts-ignore\n    return node.constructor.$name;\n}\n\nexport function getOp(op: OperatorNode): string {\n    // @ts-ignore\n    return op.constructor.$name\n}\n\nexport function getChildren(elem: ASTNode): ASTNode[] {\n    return [...Object.values(elem)].filter(e => typeof e === \"object\"\n                                            // @ts-ignore\n                                        && e.constructor.$name !== undefined);\n}","import { EmitContext } from \"../EmitContext\";\n\nexport default function BB() {\n    return function(ctx: EmitContext) {\n        ++ctx.indent_level;\n        ctx.w_line();\n    }\n}\n\n","export default function returnExport(_: string, exported: string[]) {\n    return `  return {${exported.join(\", \")}};\\n`;\n}","export default \"\\nfrom RBM import __JS_WRITE__\\n\\nclass Exception():\\n\\n    def __new__(cls, arg: str|None):\\n        return __JS_WRITE__(\\\"new Error(arg)\\\")\\n\\n    def __str__(self):\\n        return __JS_WRITE__(\\\"this.message\\\")\";","import { DictCompNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function ListComp(node: DictCompNode, ctx: EmitContext) {\n\n    console.warn(node);\n\n    ctx.w`(function(){${ctx.hm.BB()}`;\n\n    ctx.w`const _r_ = [];${ctx.hm.NL()}`\n\n    for(let i = 0; i < node.generators.length; ++i) {\n        const gen = node.generators[i];\n        ctx.w`for(let ${gen.target} of ${gen.iter}){${ctx.hm.BB()}`;\n\n        for(let j = 0; j < gen.ifs.length; ++j) {\n            ctx.w`if(${gen.ifs[j]}){${ctx.hm.BB()}`;\n        }\n    }\n\n    ctx.w`_r_.push([${node.key}, ${node.value}])`;\n\n    for(let i = 0; i < node.generators.length; ++i) {\n        ctx.w`${ctx.hm.BE()}}`;\n\n        for(let j = 0; j < node.generators[i].ifs.length; ++j) {\n            ctx.w`${ctx.hm.BE()}}`;\n        }\n    }\n\n    ctx.w`${ctx.hm.NL()}return dict(_r_);`;\n\n    ctx.w`${ctx.hm.BE()}})()`\n}","import { MODE } from \".\";\nimport { isASTNode, nodeType } from \"../ast\";\nimport { ASTNode, CLASS, ClassDefNode, FUNCTION, FunctionDefNode, SymTab } from \"../ast/types\";\nimport { HMacros } from \"../optimizers\";\nimport { Handlers } from \"./handlers\";\nimport hmacros from \"./hmacros/list\";\n\nexport type Macro = (ctx: EmitContext, ...args: ASTNode[]) => void;\n\nexport const LOCAL_VAR = 0x1000;\n\ntype EmitContextOpts = {\n    opti: {\n        handlers: Handlers,\n        hmacros : HMacros\n    }\n    mode: MODE,\n    sync: boolean\n}\n\nexport class EmitContext {\n\n    readonly macros : Record<string, Macro> = {};\n    readonly hm     : typeof hmacros;\n    readonly mode;\n    readonly sync;\n\n    readonly handlers;\n\n    jscode: string = \"\";\n\n    #symtabs;\n    constructor({\n                    opti: {\n                        handlers,\n                        hmacros,\n                    },\n                    mode,\n                    sync,\n                }: EmitContextOpts,\n                \n                macros  : Record<string, Macro>,\n                symtab  : SymTab) {\n\n        this.handlers = handlers;\n        this.#symtabs = [symtab];\n        this.mode     = mode;\n        this.macros   = macros;\n        this.hm       = hmacros as any;\n        this.sync     = sync;\n    }\n\n    getScope(name: string) {\n        return this.symtab.symbols.$strings[name];\n    }\n\n    // a little h4cky\n    getName(idx = 0) {\n        return this.#symtabs[this.#symtabs.length-1+idx].name;\n    }\n    isTopLevel() {\n        return this.#symtabs.length === 1;\n    }\n    isMethod() {\n        const last = this.#symtabs.length-1;\n\n        if( this.#symtabs[last].type !== FUNCTION )\n            return false;\n\n        return this.#symtabs[last-1].type === CLASS;\n    }\n\n    get symtab() { return this.#symtabs[this.#symtabs.length-1]; }\n\n    w(strings: TemplateStringsArray, ...exprs: any[]) {\n\n        for(let i = 0; i < exprs.length; ++i) {\n            this.w_str(strings[i]);\n\n            const e = exprs[i];\n            if( typeof e === \"function\") // HMacro\n                e(this);\n            else if( isASTNode(e) )\n                this.w_node(e)\n            else if( Array.isArray(e) )\n                this.w_body(e);\n            else\n                this.jscode += `${e}`;\n        }\n\n        this.w_str(strings[strings.length-1]);\n    }\n\n    w_str(str: string) {\n        //if( str.includes(\"\\n\") )\n        //    throw new Error(\"Break line !\");\n        return this.jscode += str;\n    }\n\n    indent_level = 0;\n\n    w_line() {\n        const nl = \"\\n\" + \"  \".repeat(this.indent_level);\n        if( ! this.jscode.endsWith(nl) )\n            this.jscode += nl;\n    }\n\n    w_body(nodes: ASTNode[]) {\n\n        if( nodes.length === 0)\n            return;\n\n        if( nodes.length === 1 && nodeType(nodes[0]) === \"Pass\")\n            return;\n\n        ++this.indent_level;\n\n        for(let i = 0; i < nodes.length; ++i) {\n            this.w_line();\n            this.w_node(nodes[i]);\n            this.w_str(\";\");\n        }\n        --this.indent_level;\n        this.w_line();\n    }\n\n    w_node(node: ASTNode) {\n\n        const type = nodeType(node);\n\n        const handler = this.handlers[type];\n        if( handler === undefined) {\n            console.warn(node);\n            throw new Error(`Node type ${nodeType(node)} is unknown`);\n        }\n\n        const hasNewContext = type === \"FunctionDef\" || type === \"ClassDef\";\n\n        if( hasNewContext )\n            this.enter( (node as ClassDefNode|FunctionDefNode).name);\n\n        node.js_start = this.jscode.length;\n        handler(node, this);\n        node.js_end   = this.jscode.length;\n\n        if( hasNewContext )\n            this.leave();\n    }\n\n    // enter/leave.\n\n    protected enter(name: string): SymTab {\n        const symtab = this.symtab.children.find( (l) => l.name === name)!;\n        this.#symtabs.push(symtab)\n        return symtab;\n    }\n    protected leave() {\n        this.#symtabs.pop();\n    }\n}","import { IfExpNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function If(node: IfExpNode, ctx: EmitContext) {\n    ctx.w`( ${ctx.hm.bool(node.test)} ? ${node.body} : ${node.orelse} )`;\n}","import { EmitContext } from \"@RBrython/rbry/emitter/EmitContext\";\nimport { HMacro } from \"../..\";\nimport { ASTNode } from \"@RBrython/rbry/ast/types\";\nimport { isSimple } from \"./saveTmp\";\n\nexport default function getTmp(fallback: HMacro, node: ASTNode) {\n\n    if( isSimple(node) )\n        return (ctx: EmitContext) => ctx.w_node(node);\n\n    return fallback(node);\n}","export default \"from types import NotImplementedType\\nfrom RBM import __JS_OP__, __JS_AS_NUMBER__, __JS_SHADOW__, __JS_WRITE__, number\\n\\n@__JS_SHADOW__(\\\"number\\\")\\nclass float(number):\\n    def __new__(cls, o: object, /) -> float:\\n        if type(o) is str:\\n            if o == \\\"infinity\\\" or o == \\\"inf\\\":\\n                return __JS_WRITE__(\\\"Number.POSITIVE_INFINITY\\\") # pyright: ignore[reportReturnType]\\n            if o == \\\"-infinity\\\" or o == \\\"-inf\\\":\\n                return __JS_WRITE__(\\\"Number.NEGATIVE_INFINITY\\\") # pyright: ignore[reportReturnType]\\n            return __JS_AS_NUMBER__(o)\\n        return type(o).__float__(o) # type: ignore\\n    \\n    def __str__(self):\\n        return __JS_WRITE__(\\\"`${this}`\\\")\\n    \\n    def __eq__(self, o: object, /) -> bool:\\n        return __JS_OP__(self, \\\"==\\\", o)    \\n\\n    def __add__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case float(): return __JS_OP__(self, \\\"+\\\", o)\\n            case int  (): return __JS_OP__(self, \\\"+\\\", __JS_AS_NUMBER__(o))\\n            case _      : return NotImplemented\\n\\n    def __radd__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case float(): return __JS_OP__(o                  , \\\"+\\\", self)\\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), \\\"+\\\", self)\\n            case _      : return NotImplemented\\n\\n    def __sub__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case float(): return __JS_OP__(self, \\\"-\\\", o)\\n            case int  (): return __JS_OP__(self, \\\"-\\\", __JS_AS_NUMBER__(o))\\n            case _      : return NotImplemented\\n\\n    def __rsub__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case float(): return __JS_OP__(o                  , \\\"-\\\", self)\\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), \\\"-\\\", self)\\n            case _      : return NotImplemented\\n\\n    def __mul__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case float(): return __JS_OP__(self, \\\"*\\\", o)\\n            case int  (): return __JS_OP__(self, \\\"*\\\", __JS_AS_NUMBER__(o))\\n            case _      : return NotImplemented\\n\\n    def __rmul__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case float(): return __JS_OP__(o                  , \\\"*\\\", self)\\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), \\\"*\\\", self)\\n            case _      : return NotImplemented\\n\\n    def __truediv__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case float(): return __JS_OP__(self, \\\"/\\\", o)\\n            case int  (): return __JS_OP__(self, \\\"/\\\", __JS_AS_NUMBER__(o))\\n            case _      : return NotImplemented\\n\\n    def __rtruediv__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case float(): return __JS_OP__(o                  , \\\"/\\\", self)\\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), \\\"/\\\", self)\\n            case _      : return NotImplemented\\n\\n    ### unary operators ###\\n\\n    def __neg__(self, /) -> float:\\n        return __JS_OP__(\\\"-\\\", self)\\n    \\n    def __int__(self, /) -> int:\\n        return __JS_RUN__('(x) => Math.trunc(x)', self) # type: ignore\\n    \\n    def __abs__(self, /) -> int:\\n         return __JS_RUN__('(x) => Math.abs(x)', self) # type: ignore\";","export default \"from RBM import __JS_WRITE__, obj\\n\\nclass object(obj): # typecheck h4ck\\n\\n    def __new__(cls):\\n        return __JS_WRITE__(\\\"Object.create(this.prototype)\\\")\\n\\n    def __eq__(self, o: obj, /):\\n        if self is o: return True\\n        return NotImplemented\\n    \\n    def __ne__(self, o: obj, /):\\n        return not self == o\\n    \\n    def __lt__(self, o: obj, /):\\n        return NotImplemented\\n    def __le__(self, o: obj, /):\\n        return NotImplemented\\n    def __gt__(self, o: obj, /):\\n        return NotImplemented\\n    def __ge__(self, o: obj, /):\\n        return NotImplemented\\n    \\n    # print\\n    def __repr__(self):\\n        #TODO: __module__ not implemented\\n        #TODO: __qualname__ not implemented\\n        return \\\"<? object>\\\" # using f\\\"\\\" = infinite loop.\\n    \\n    def __str__(self):\\n        return type(self).__repr__(self)\\n    \\n    def __format__(self, f:str):\\n        return type(self).__str__(self)\";","import { ReturnNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Return(node: ReturnNode, ctx: EmitContext) {\n    ctx.w`return ${node.value}`;\n}","export type PyModule = Record<string, any>;\n\nexport default abstract class Runner {\n    \n    abstract run(jscode: string): Promise<PyModule>;\n    abstract runSync(jscode: string): PyModule;\n\n    abstract registerBuiltins(symbols: PyModule): void;\n    abstract registerBuiltin(name: string, value: any): void;\n\n    abstract registerModule(name: string, symbols: PyModule): void;\n    abstract      getModule(name: string): PyModule;\n\n    // low level\n    abstract loadAsFunction(jscode: string): (runlib: any) => Promise<PyModule>;\n    abstract runFunction(fct: (runlib: any) => Promise<PyModule>): Promise<PyModule>;\n\n    abstract loadAsSyncFunction(jscode: string): (runlib: any) => PyModule;\n    abstract runSyncFunction(fct: (runlib: any) => PyModule): PyModule;\n}","export default \"def isinstance(o: object, t):\\n    ot = type(o)\\n    # TODO: better\\n    return ot is t\";","import { getOp } from \"@RBrython/rbry/ast\";\nimport { BoolOpNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function BoolOp(node: BoolOpNode, ctx: EmitContext) {\n\n    const op = getOp(node.op);\n\n    const a = node.values[0];\n    const b = node.values[1];\n    \n    const cond  = ctx.hm.bool( ctx.hm.saveTmp(a) );\n    const saved = ctx.hm.tmp    (a);\n    const guard = ctx.hm.withTmp(a);\n\n    if( op === \"And\" )\n        return ctx.w`${guard}(${cond} ? ${b} : ${saved} )`;\n    if( op === \"Or\" )\n        return ctx.w`${guard}(${cond} ? ${saved} : ${b} )`;\n\n    throw new Error(`Unknown boolean operator ${op}`);\n}","export default \"def len(o, /) -> float|int:\\n    return type(o).__len__(o) # pyright: ignore[reportArgumentType]\";","import { NamedExprNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function NamedExpr(node: NamedExprNode, ctx: EmitContext) {\n    return ctx.w`(${node.target} = ${node.value})`\n}","export default \"def format(o: object, f: str):\\n    return type(o).__format__(o, f)\";","import { GeneratorExpNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function GeneratorExp(node: GeneratorExpNode, ctx: EmitContext) {\n\n    ctx.w`(function*(){${ctx.hm.BB()}`;\n\n    for(let i = 0; i < node.generators.length; ++i) {\n        const gen = node.generators[i];\n        ctx.w`for(let ${gen.target} of ${gen.iter}){${ctx.hm.BB()}`;\n\n        for(let j = 0; j < gen.ifs.length; ++j) {\n            ctx.w`if(${gen.ifs[j]}){${ctx.hm.BB()}`;\n        }\n    }\n\n    ctx.w`yield ${node.elt}`;\n\n    for(let i = 0; i < node.generators.length; ++i) {\n        ctx.w`${ctx.hm.BE()}}`;\n\n        for(let j = 0; j < node.generators[i].ifs.length; ++j) {\n            ctx.w`${ctx.hm.BE()}}`;\n        }\n    }\n\n    ctx.w`${ctx.hm.BE()}})()`\n}","import { ASTNode } from \"../ast/types\";\nimport { EmitContext, Macro } from \"../emitter/EmitContext\";\nimport handlers, { Handler, Handlers } from \"../emitter/handlers\"\nimport hmacros from \"../emitter/hmacros/list\";\nimport SafeOpti_handlers from \"./safe/handlers\";\nimport SafeOpti_hmacros from \"./safe/hmacros\";\n\n// delayed by default in order to be used with ctx.w``.\nexport type HMacro = (...args: any[]) => ( (ctx: EmitContext) => void);\n\nexport type HMacros = Record<string, HMacro>;\n\nexport type Optimizer = {\n    handlers           : Handlers,\n    hmacros            : HMacros,\n    require_typechecker: boolean\n}\n\ntype PatchHandler = (node: ASTNode, ctx: EmitContext, fallback: Handler) => void\n\nfunction patchHandlers(handlers: Handlers, patch: PatchHandler[]) {\n\n    const patchedHandlers = {...handlers};\n\n    for(let i = 0; i < patch.length; ++i ) {\n        const name = patch[i].name;\n\n        const fallback = handlers[name];\n        patchedHandlers[name] = (node: ASTNode, ctx: EmitContext) => {\n            patch[i](node, ctx, fallback);\n        }\n    }\n\n    return patchedHandlers;\n}\n\ntype PatchHMacros = (fallback: HMacro, ...args: any[]) => ((ctx: EmitContext) => void)\n\nfunction patchHMacros(hmacros: HMacros, patch: PatchHMacros[]) {\n\n    const patchedHMacros = {...hmacros};\n\n    for(let i = 0; i < patch.length; ++i ) {\n        const name = patch[i].name;\n\n        const fallback = hmacros[name];\n        patchedHMacros[name] = (...args: any[]) => {\n            return patch[i](fallback, ...args);\n        }\n    }\n\n    return patchedHMacros;\n}\n\nconst safeHandlers = patchHandlers(handlers, SafeOpti_handlers);\nconst safeHmacros  = patchHMacros(hmacros, SafeOpti_hmacros);\n\nconst Optimizers = {\n    disabled: {\n        handlers,\n        hmacros: hmacros,\n        require_typechecker: false\n    },\n    safe    : {\n        handlers: safeHandlers,\n        hmacros : safeHmacros,\n        require_typechecker: true\n    },\n    unsafe  : {\n        handlers: safeHandlers, //TODO...\n        hmacros : safeHmacros,  //TODO...\n        require_typechecker: true\n    }\n} satisfies Record<string, Optimizer>\n\nexport default Optimizers;","import { ConstantNode } from \"../../../ast/types\";\nimport { BoolType } from \"../../types\";\nimport { TypedEntry } from \"../../Walker\";\n\nexport default function Constant(entry: TypedEntry<ConstantNode>) {\n\n        const type = typeof entry.node.value;\n\n        /*\n        if( type === \"object\") {\n            // @ts-ignore\n            const qname = node.value.__class__.__qualname__\n            // @ts-ignore\n            const value: float|bigint = node.value.value;\n\n            if( qname === \"float\"   ) return ctx.w`${value}`;\n            if( qname === \"int\"     ) return ctx.w`${value}n`;\n            if( qname === \"NoneType\") return ctx.w`null`;\n            //if( qname === \"ellipsis\") return \"$RB.ellipsis\";\n        }\n        if( type === \"string\" ) return ctx.w`\"${node.value}\"`;\n        if( type === \"number\" ) return ctx.w`${node.value}n`; // bigint\n        */\n        if( type === \"boolean\") {\n            entry.node.result_type = { type: BoolType }\n        }\n\n        //console.warn(node, type);\n        //throw new Error(`Unknown Cste ${type}`);\n}","import { ASTNode } from \"../ast/types\";\nimport { EmitContext } from \"../emitter/EmitContext\";\n\nexport default function __JS_LOG__(ctx: EmitContext, ...args: ASTNode[]) {\n\n    ctx.w_str(\"console.log(\");\n\n    for(let i = 0; i < args.length; ++i)\n        ctx.w`${args[i]},`;\n\n    ctx.w_str(\");\");\n}","import { CompareNode } from \"../../../ast/types\";\nimport { getOp } from \"../../../ast/\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Compare(node: CompareNode, ctx: EmitContext) {\n\n    let prev = node.left;\n    for(let i = 0; i < node.ops.length; ++i) {\n\n        const isFirst = i === 0;\n        const isLast  = i === node.ops.length - 1\n\n        let op = getOp(node.ops[i]) as keyof typeof cmpops | \"Is\" | \"IsNot\" | \"NotIn\";\n\n        let a: any = prev;\n        if( ! isFirst )\n            a = ctx.hm.getTmp(prev);\n\n        let b: any = prev = node.comparators[i];\n        if( ! isLast )\n            b = ctx.hm.saveTmp(b);\n\n        if(! isFirst)\n            ctx.w` && `;\n\n        // TODO: if has next... (saveTmp())\n        // TODO: if has prev... (getTmp())\n\n        if( op === 'Is' ) {\n            ctx.w`${a} === ${b}`;\n            continue;\n        }\n        if( op === 'IsNot' ) {\n            ctx.w`${a} !== ${b}`;\n            continue;\n        }\n        if( op === \"NotIn\") {\n            ctx.w_str(\"!\");\n            op = \"In\";\n        }\n        if( op === \"In\") {\n            ctx.w`$RB.in(${a}, ${b})`\n            continue;\n        }\n        \n        const opname = cmpops[op];\n        if( opname === undefined) {\n            console.warn(op);\n            throw new Error(`CmpOp ${op} not impl`);\n        }\n\n        ctx.w`$RB.op(${a}, \"${opname}\", ${b})`;\n    }\n}\n\nconst cmpops = {\n    Eq   : \"eq\",\n    NotEq: \"ne\",\n    Gt   : \"gt\",\n    GtE  : \"ge\",\n    Lt   : \"lt\",\n    LtE  : \"le\",\n    In   : \"contains\"\n}\n","import { ASTNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../EmitContext\";\n\nexport default function withTmp(_: ASTNode) {\n    return function(ctx: EmitContext) {\n        ctx.w`$RB.withTmp`;\n    }\n}","import { MODE } from \"../..\";\nimport { NameNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Name(node: NameNode, ctx: EmitContext) {\n\n    // h4ck\n    if( node.id === \"__debug__\") {\n        ctx.w`${ctx.mode === MODE.DEBUG}`;\n        return;\n    }\n\n    ctx.w_str(node.id);\n}","export default \"from RBM import __JS_OP__, __JS_SHADOW__, __JS_WRITE__, Array\\n\\n@__JS_SHADOW__(\\\"Array\\\")\\nclass list(Array):\\n    def __getitem__(self, i: int):\\n        return __JS_OP__(self, \\\"[]\\\", i)\\n    \\n    def __len__(self):\\n        return __JS_WRITE__(\\\"this.length\\\")\";","import { EmitContext } from \"../EmitContext\";\n\nexport default function getTmp() {\n    return function(ctx: EmitContext) {\n        ctx.w`$RB.getTmp()`;\n    }\n}","import { getOp } from \"../../../ast/\";\nimport { BinaryOpNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function(node: BinaryOpNode, ctx: EmitContext) {\n    const a = node.left;\n    const b = node.right;\n    const op = getOp(node.op) as keyof typeof binops;\n\n    const opname = binops[op];\n    if( opname === undefined) \n        throw new Error(`BinOp ${op} not impl`);\n\n    ctx.w`$RB.op(${a}, \"${opname}\", ${b})`;\n}\n\nexport const binops = {\n    Add : \"add\",\n    Sub : \"sub\",\n    Mult: \"mul\",\n    Div : \"truediv\",\n    FloorDiv: \"floordiv\",\n    Pow : \"pow\",\n    Mod : \"mod\",\n    // bits\n    BitOr: \"or\",\n    BitAnd: \"and\",\n    BitXor: \"xor\",\n    LShift: \"lshift\",\n    RShift: \"rshift\"\n}","// list is filled in list.ts in order to prevent circular dependency.\n\nimport { ASTNode } from \"../../ast/types\";\nimport { EmitContext } from \"../EmitContext\";\n\nexport type Handler = (    node: ASTNode,\n                            ctx: EmitContext) => void;\n\nexport type Handlers = Record<string, Handler>;\n\nconst handlers: Handlers = {};\n\nexport default handlers;","import { AugAssignNode } from \"../../../ast/types\";\nimport { binops } from \"./BinOp\";\nimport { getOp } from \"../../../ast/\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function AugAssign(node: AugAssignNode, ctx: EmitContext) {\n \n    const a  = node.target;\n    const op = getOp(node.op) as keyof typeof binops;\n    const b  = node.value;\n\n    const opname = binops[op];\n    if( opname === undefined) \n        throw new Error(`BinOp ${op} not impl`);\n\n    ctx.w`${a} = $RB.op(${a}, \"i${opname}\", ${b})`;   \n}","import { ASTNode, StringNode } from \"../ast/types\";\nimport { EmitContext } from \"../emitter/EmitContext\";\n\nexport default function __JS_WRITE__(ctx: EmitContext, code: ASTNode) {\n    ctx.w_str((code as StringNode).value.replaceAll(\"\\\\n\\\\\\n\", \"\\n\"));\n}","import { FunctionDefNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function AsyncFunctionDef(node: FunctionDefNode, ctx: EmitContext) {\n\n    const isMethod = ctx.isMethod();\n\n    const name = node.name;\n    const body = node.body;\n\n    if( isMethod )\n        ctx.w`${ctx.getName(-1)}.prototype.${name} = `;\n\n    // open decorator\n    for( let i = 0; i < node.decorator_list.length ; ++i )\n        ctx.w`${node.decorator_list[i]}(`;\n\n    ctx.w`async function ${name} ${node.args}`;\n\n    // start of the function/lambda is included in the arguments...\n\n    ctx.w_body(body);\n    ctx.w`}`;\n\n    // close decorator\n    for( let i = 0; i < node.decorator_list.length ; ++i )\n        ctx.w`)`;\n}","import { ASTNode } from \"../ast/types\";\nimport { EmitContext } from \"../emitter/EmitContext\";\n\nexport default function __JS_AS_BIGINT__(ctx: EmitContext, node: ASTNode) {\n    ctx.w`BigInt(${node})`;\n}","export default \"from JS import console\\n\\ndef print(*a):\\n    s = \\\"\\\"\\n\\n    for i in range(len(a)):\\n        if i != 0:\\n            s += \\\" \\\"\\n        s += str(a[i])\\n\\n    console.log(s)\";","import { EXPORT } from \"..\";\n\nexport default {\n    defaults: {\n        exports: EXPORT.RETURN\n    },\n    transform: (jscode: string, sync: boolean) => {\n        return `(${sync ? \"\" : \"async \"}function($RB){\"use strict\";${jscode}})`;\n    }\n}","export default function brythonExport(name: string, exported: string[]) {\n    return `  $B.imported[\"${name}\"] = $B.jsobj2pyobj({${exported.join(',')}});\\n`;\n}","import Engine from \"../interface\";\nimport { ParsedCode } from \"@RBrython/rbry/ast/types\";\nimport Runner, { PyModule } from \"@RBrython/rbry/runners/interface\";\nimport parse from \"@RBrython/rbry/parser\";\nimport {Emitter, EmitterOptions} from \"@RBrython/rbry/emitter\";\nimport FunctionTarget from \"@RBrython/rbry/emitter/targets/function\";\nimport { Macro } from \"@RBrython/rbry/emitter/EmitContext\";\n\ntype Parser  = typeof parse;\n\nexport default class BaseEngine extends Engine {\n\n    protected readonly parser;\n    protected readonly emitter;\n    protected readonly runner;\n\n    constructor(parser: Parser, emitter: Emitter, runner: Runner) {\n        super();\n\n        this.parser  = parser;\n        this.emitter = emitter;\n        this.runner  = runner;\n    }\n\n    override async run(pycode: string, opts?: Omit<EmitterOptions, \"target\">): Promise<PyModule> {\n\n        return await this.runner.run(this.emit(this.parse(pycode), {\n            ...opts,\n            target: FunctionTarget\n        }));\n    }\n    override runSync(pycode: string, opts?: Omit<EmitterOptions, \"target\">): PyModule {\n\n        return this.runner.runSync(this.emit(this.parse(pycode), {\n            ...opts,\n            sync  : true,\n            target: FunctionTarget\n        }));\n    }\n\n    // modules\n    override async registerModule(name: string, symbols: string | PyModule) {\n        if( typeof symbols === \"string\")\n            symbols = await this.run(symbols);\n        this.runner.registerModule(name, symbols);\n    }\n    override registerModuleSync(name: string, symbols: string | PyModule): void {\n        if( typeof symbols === \"string\")\n            symbols = this.runSync(symbols);\n        this.runner.registerModule(name, symbols);\n    }\n    override getModule(name: string): PyModule {\n        return this.runner.getModule(name);\n    }\n\n    // builtins\n    override registerBuiltins(symbols: string | PyModule): void {\n        if( typeof symbols === \"string\")\n            symbols = this.runSync(symbols);\n        this.runner.registerBuiltins(symbols);\n    }\n    override registerBuiltin(name: string, value: any): void {\n        this.runner.registerBuiltin(name, value);\n    }\n\n    override registerMacros(macros: Record<string, Macro>):void {\n        this.emitter.registerMacros(macros);\n\n    }\n    override registerMacro(name: string, fct: Macro): void {\n        this.emitter.registerMacro(name, fct);\n    }\n\n    // steps\n    override parse(pycode: string): ParsedCode {\n        return this.parser(pycode, \"_\");\n    }\n    override emit(parsed: ParsedCode, opts?: Partial<EmitterOptions>): string {\n        return this.emitter.emit(parsed, opts);\n    }\n    override loadAsFunction(jscode: string): (runlib: any) => Promise<PyModule> {\n        return this.runner.loadAsFunction(jscode);\n    }\n    override runFunction(fct: (runlib: any) => Promise<PyModule>): Promise<PyModule> {\n        return this.runner.runFunction(fct);\n    }\n    override loadAsSyncFunction(jscode: string): (runlib: any) => PyModule {\n        return this.runner.loadAsSyncFunction(jscode);\n    }\n    override runSyncFunction(fct: (runlib: any) => PyModule): PyModule {\n        return this.runner.runSyncFunction(fct);\n    }\n}","import RBrythonGlobalRunner from \"@RBrython/rbry/runners/RBrythonGlobalRunner\";\nimport BaseEngine from \"../Base\";\nimport parse from \"@RBrython/rbry/parser\";\nimport RBrythonEmitter from \"@RBrython/rbry/emitter\";\n\nexport const builtins = {\n    object: require(\"!!raw-loader!../../corelib/primitives/object.py\"  ).default,\n    type  : require(\"!!raw-loader!../../corelib/primitives/type.py\"  ).default,\n    int   : require(\"!!raw-loader!../../corelib/primitives/int.py\"   ).default,\n    bool  : require(\"!!raw-loader!../../corelib/primitives/bool.py\"  ).default,\n    float : require(\"!!raw-loader!../../corelib/primitives/float.py\" ).default,\n    str   : require(\"!!raw-loader!../../corelib/primitives/str.py\"   ).default,\n    tuple : require(\"!!raw-loader!../../corelib/primitives/tuple.py\" ).default,\n    list  : require(\"!!raw-loader!../../corelib/primitives/list.py\"  ).default,\n    dict  : require(\"!!raw-loader!../../corelib/primitives/dict.py\"  ).default,\n\n    format: require(\"!!raw-loader!../../corelib/print/format.py\").default,\n    repr: require(\"!!raw-loader!../../corelib/print/repr.py\").default,\n    print: require(\"!!raw-loader!../../corelib/print/print.py\").default,\n\n    abs  : require(\"!!raw-loader!../../corelib/operators/abs.py\"  ).default,\n    len  : require(\"!!raw-loader!../../corelib/operators/len.py\"  ).default,\n\n    range     : require(\"!!raw-loader!../../corelib/iterators/range.py\"  ).default,\n    next: require(\"!!raw-loader!../../corelib/iterators/next.py\"  ).default,\n\n    Exception: require(\"!!raw-loader!../../corelib/Exception.py\"  ).default,\n    isinstance: require(\"!!raw-loader!../../corelib/isinstance.py\"  ).default,\n}\n\nexport default function RBrythonEngineFactory() {\n\n    const emitter = new RBrythonEmitter();\n    const runner  = new RBrythonGlobalRunner();\n    const engine = new BaseEngine(parse, emitter, runner);\n\n    engine.registerMacros({\n\n        __JS_OP__       : require(\"@RBrython/rbry/macros/__JS_OP__\").default,\n        __JS_AWAIT__    : require(\"@RBrython/rbry/macros/__JS_AWAIT__\").default,\n        __JS_RUN__      : require(\"@RBrython/rbry/macros/__JS_RUN__\").default,\n        __JS_WRITE__    : require(\"@RBrython/rbry/macros/__JS_WRITE__\").default,\n        __JS_LOG__      : require(\"@RBrython/rbry/macros/__JS_LOG__\").default,\n        __JS_AS_STRING__: require(\"@RBrython/rbry/macros/__JS_AS_STRING__\").default,\n        __JS_AS_NUMBER__: require(\"@RBrython/rbry/macros/__JS_AS_NUMBER__\").default,\n        __JS_AS_BIGINT__: require(\"@RBrython/rbry/macros/__JS_AS_BIGINT__\").default,\n        __JS_SHADOW__: require(\"@RBrython/rbry/macros/__JS_SHADOW__\").default,\n    })\n\n    engine.registerModule(\"JS\", globalThis);\n\n    for(let builtin of Object.values(builtins))\n        engine.registerBuiltins(builtin);\n\n    return engine;\n}","import { WithNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function With(node: WithNode, ctx: EmitContext) {\n    \n    ctx.w`{${ctx.hm.BB()}`;\n    for(let i = 0; i < node.items.length; ++i )\n        ctx.w`const _w${i}_ = ${node.items[i].context_expr};${ctx.hm.NL()}`\n\n    for(let i = 0; i < node.items.length; ++i) {\n        const r = node.items[i];\n        if( r.optional_vars !== undefined)\n            ctx.w`var ${r.optional_vars} = `;\n        ctx.w`$RB.mcall(_w${i}_, '__enter__');${ctx.hm.NL()}`\n    }\n\n    ctx.w`let _err_ = null;${ctx.hm.NL()}`\n\n    ctx.w`try{${node.body}} catch(_e_) { _err_ = _e_ }${ctx.hm.NL()}`;\n    ctx.w`finally {${ctx.hm.BB()}`\n\n        ctx.w`let _et_ = null; let _ee_ = null; let _ex_ = null;${ctx.hm.NL()}`;\n\n        ctx.w`if(_err_ !== null) {${ctx.hm.BB()}`;\n            ctx.w`_et_ = 'type';${ctx.hm.NL()}`;\n            ctx.w`_ee_ = 'exp';${ctx.hm.NL()}`;\n            ctx.w`_ex_ = 'trace';`;\n        ctx.w`${ctx.hm.BE()}}${ctx.hm.NL()}`;\n\n\n    ctx.w`let _ok_ = true;${ctx.hm.NL()}`\n    for(let i = node.items.length - 1; i >= 0; --i) {\n        const r = node.items[i];\n        ctx.w`_ok_ &&= $RB.mcall(_w${i}_, '__exit__', _et_, _ee_, _ex_);${ctx.hm.NL()}`\n    }\n    ctx.w`if( _err_ !== null && ! _ok_ ) throw _err_;`;\n\n    ctx.w`${ctx.hm.BE()}}${ctx.hm.BE()}}`;\n}","export default \"from RBM import __JS_OP__, __JS_SHADOW__, __JS_WRITE__, boolean\\n\\n@__JS_SHADOW__(\\\"boolean\\\")\\nclass bool(boolean, int): # type: ignore (bool is Final)\\n    def __new__(cls, arg: object, /) -> boolean:# -> Any | bool:\\n        # can't use Python \\\"if\\\", \\\"or\\\" as we'd have an infinite loop.\\n        __JS_WRITE__(\\\"if(arg === true || arg === false) { return arg; }\\\")\\n        return type(arg).__bool__(arg) # type: ignore\";","import { ASTNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../EmitContext\";\n\nexport default function saveTmp(node: ASTNode) {\n    return function(ctx: EmitContext) {\n        ctx.w`$RB.saveTmp(${node})`;\n    }\n}","import { EmitContext } from \"../EmitContext\";\n\nexport default function NL() {\n    return function(ctx: EmitContext) {\n        ctx.w_line();\n    }\n}","import { SubscriptNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Subscript(node: SubscriptNode, ctx: EmitContext) {\n    ctx.w`$RB.getitem(${node.value}, ${node.slice})`;\n}","const handlers = {\n    \"FunctionDef\": require(\"./definitions/FunctionDef\").default,\n\n    \"Constant\": require(\"./vars/Constant\").default,\n    \"UnaryOp\": require(\"./operators/UnaryOp\").default,\n    \"Compare\" : require(\"./operators/Compare\").default\n}\n\nexport default handlers","export default \"from RBM import __JS_WRITE__\\n\\n_marker = __JS_WRITE__(\\\"Symbol()\\\") #object()\\n\\ndef next(it, defaultVal: object = _marker):\\n    val = __JS_WRITE__(\\\"it.next()\\\") #TODO: we use JS iterator\\n    if __JS_WRITE__(\\\"val.done\\\") == True:\\n        if defaultVal is _marker:\\n            raise Exception(\\\"StopIteration\\\")\\n        return defaultVal\\n    \\n    return __JS_WRITE__(\\\"val.value\\\")\";","export default \"def abs(o: float|int, /) -> float|int:\\n    return type(o).__abs__(o) # pyright: ignore[reportArgumentType]\";","import { ParsedCode } from \"../ast/types\";\n\nexport default function parse(pycode: string, filename: string): ParsedCode {\n    \n    const parser = new $B.Parser(pycode, filename, 'file');\n\n    const ast   = $B._PyPegen.run_parser(parser);\n    const future = $B.future_features(ast, filename)\n    var symtable = $B._PySymtable_Build(ast, filename, future);\n\n    return {\n        filename,\n        pycode,\n        ast,\n        symtable,\n    }\n}","import { ListNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function List(node: ListNode, ctx: EmitContext) {\n    \n    ctx.w`[`;\n\n    for(let i = 0; i < node.elts.length; ++i) {\n        ctx.w_node(node.elts[i]);\n        ctx.w_str(', ');\n    }\n\n    ctx.w`]`;\n}","import { DictNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function List(node: DictNode, ctx: EmitContext) {\n    \n    ctx.w`dict([`;\n\n    for(let i = 0; i < node.keys.length; ++i) {\n        ctx.w`[${node.keys[i]}, ${node.values[i]}], `\n    }\n\n    ctx.w`])`;\n}","export default \"from RBM import __JS_OP__, __JS_WRITE__\\n\\nclass type:\\n    def __new__(cls, o: object, /) -> type:\\n        return __JS_WRITE__(\\\"$RB.getClass(o)\\\") # pyright: ignore[reportReturnType]\\n\\n    def __call__(self, *args):\\n        __JS_WRITE__(\\\"\\\"\\\"\\n                     let instance;\\n                     const factory = this.prototype.__new__;\\n                     if( factory !== undefined )\\n                        instance = factory.call(self, ...args)\\n                     else\\n                        instance = new self(...args) // JS\\n                     \\n                     const init = this.prototype.__init__;\\n                     if( init !== undefined)\\n                        init.call(instance, ...args)\\n                     \\\"\\\"\\\")\\n        return instance # type: ignore\";","export default {\n    defaults: {},\n    transform: (e: string) => e\n}","import { MODE } from \"../..\";\nimport { AssertNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Assert(node: AssertNode, ctx: EmitContext) {\n\n    if( ctx.mode === MODE.PROD )\n        return;\n\n    ctx.w`$RB.assert( ${ctx.hm.bool(node.test)}, ${node.msg ?? \"\"})`;\n}","import { ImportFromNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function ImportFrom(node: ImportFromNode, ctx: EmitContext) {\n\n    const module = node.module;\n\n    if( module === \"RBM\" )\n        return; // Brython macros...\n\n    if( module === \"types\" || module === \"typing\")\n        return; // ignore for now\n    if( module === \"functools\") {\n        console.warn(\"Import not implemented yet\");\n        return;\n    }\n    ctx.w`const {`;\n\n    for(let i = 0; i < node.names.length; ++i) {\n        const imported = node.names[i];\n        let as = \"\";\n        if( imported.asname !== undefined)\n            as = `: ${imported.asname}`\n\n        ctx.w`${imported.name}${as},`;\n    }\n\n    const importfct = ctx.isTopLevel() && ! ctx.sync\n                            ? \"await $RB.getModule\"\n                            : \"$RB.getModuleSync\"\n\n    ctx.w`} = ${importfct}(\"${module}\")`;\n}\n","import { AttributeNode, DeleteNode, SubscriptNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\nimport { nodeType } from \"@RBrython/rbry/ast\";\n\nexport default function Delete(node: DeleteNode, ctx: EmitContext) {\n\n    for(let i = 0; i < node.targets.length; ++i) {\n        const type = nodeType(node.targets[i]);\n        if( type === \"Subscript\") {\n            const snode = node.targets[i] as SubscriptNode;\n            ctx.w`$RB.delitem(${snode.value}, ${snode.slice});${ctx.hm.NL}`\n            continue;\n        }\n        if( type === \"Attribute\") {\n            const snode = node.targets[i] as AttributeNode;\n            ctx.w`$RB.delattr(${snode.value}, \"${snode.attr}\");${ctx.hm.NL}`\n            continue;\n        }\n        console.warn(type);\n        throw new Error(\"Not implemented\");\n    }\n}","import Handlers, { Handler } from \"./index\";\n\nimport {default as ClassDef} from \"./definitions/ClassDef\";\nHandlers[\"ClassDef\"] = ClassDef as Handler;\n\nimport {default as FunctionDef} from \"./definitions/FunctionDef\";\nHandlers[\"FunctionDef\"] = FunctionDef as Handler;\n\nHandlers[\"AsyncFunctionDef\"] = require(\"./definitions/AsyncFunctionDef\").default;\nHandlers[\"Await\"] = require(\"./keywords/Await\").default;\nHandlers[\"Yield\"] = require(\"./keywords/Yield\").default;\nHandlers[\"YieldFrom\"] = require(\"./keywords/YieldFrom\").default;\nHandlers[\"Delete\"] = require(\"./keywords/Delete\").default;\n\nHandlers[\"IfExp\"] = require(\"./controlflows/IfExp\").default;\nHandlers[\"With\"] = require(\"./controlflows/With\").default;\n\nHandlers[\"NamedExpr\"] = require(\"./operators/NamedExpr\").default;\n\nHandlers[\"Tuple\"] = require(\"./vars/Tuple\").default;\nHandlers[\"List\"] = require(\"./vars/List\").default;\nHandlers[\"Dict\"] = require(\"./vars/Dict\").default;\nHandlers[\"GeneratorExp\"] = require(\"./vars/GeneratorExp\").default;\nHandlers[\"ListComp\"] = require(\"./vars/ListComp\").default;\nHandlers[\"DictComp\"] = require(\"./vars/DictComp\").default;\n\nimport {default as Lambda} from \"./definitions/Lambda\";\nHandlers[\"Lambda\"] = Lambda as Handler;\n\nimport {default as Arguments} from \"./definitions/Arguments\";\nHandlers[\"arguments\"] = Arguments as Handler;\n\nimport {default as Global} from \"./vars/Global\";\nHandlers[\"Global\"] = Global as Handler;\n\nimport {default as Nonlocal} from \"./vars/Nonlocal\";\nHandlers[\"Nonlocal\"] = Nonlocal as Handler;\n\n\nimport {default as Subscript} from \"./operators/Subscript\";\nHandlers[\"Subscript\"] = Subscript as Handler;\n\nimport {default as Assert} from \"./keywords/Assert\";\nHandlers[\"Assert\"] = Assert as Handler;\n\nimport {default as Pass} from \"./keywords/Pass\";\nHandlers[\"Pass\"] = Pass as Handler;\n\nimport {default as Return} from \"./keywords/Return\";\nHandlers[\"Return\"] = Return as Handler;\n\n\nimport {default as Assign} from \"./operators/Assign\";\nHandlers[\"Assign\"] = Assign as Handler;\n\nimport {default as Attribute} from \"./operators/Attribute\";\nHandlers[\"Attribute\"] = Attribute as Handler;\n\nimport {default as AugAssign} from \"./operators/AugAssign\";\nHandlers[\"AugAssign\"] = AugAssign as Handler;\n\nimport {default as BinOp} from \"./operators/BinOp\";\nHandlers[\"BinOp\"] = BinOp as Handler;\n\nimport {default as Call} from \"./operators/Call\";\nHandlers[\"Call\"] = Call as Handler;\n\nimport {default as Compare} from \"./operators/Compare\";\nHandlers[\"Compare\"] = Compare as Handler;\n\nimport {default as UnaryOp} from \"./operators/UnaryOp\";\nHandlers[\"UnaryOp\"] = UnaryOp as Handler;\n\nimport {default as Constant} from \"./vars/Constant\";\nHandlers[\"Constant\"] = Constant as Handler;\n\nimport {default as Expr} from \"./vars/Expr\";\nHandlers[\"Expr\"] = Expr as Handler;\n\nimport {default as Name} from \"./vars/Name\";\nHandlers[\"Name\"] = Name as Handler;\n\nimport {default as JoinedStr} from \"./vars/JoinedStr\";\nHandlers[\"JoinedStr\"] = JoinedStr as Handler;\n\nimport {default as If} from \"./controlflows/If\";\nHandlers[\"If\"] = If as Handler;\n\nimport {default as While} from \"./controlflows/While\";\nHandlers[\"While\"] = While as Handler;\n\nimport {default as For} from \"./controlflows/For\";\nHandlers[\"For\"] = For as Handler;\n\nimport {default as Try} from \"./controlflows/Try\";\nHandlers[\"Try\"] = Try as Handler;\n\nimport {default as Match} from \"./controlflows/Match\";\nHandlers[\"Match\"] = Match as Handler;\n\nimport {default as Continue} from \"./keywords/Continue\";\nHandlers[\"Continue\"] = Continue as Handler;\n\nimport {default as Break} from \"./keywords/Break\";\nHandlers[\"Break\"] = Break as Handler;\n\nimport {default as Raise} from \"./keywords/Raise\";\nHandlers[\"Raise\"] = Raise as Handler;\n\nimport {default as ImportFrom} from \"./imports/ImportFrom\";\nHandlers[\"ImportFrom\"] = ImportFrom as Handler;\n\nimport {default as Import} from \"./imports/Import\";\nHandlers[\"Import\"] = Import as Handler;\n\nimport {default as BoolOp} from \"./operators/BoolOp\";\nHandlers[\"BoolOp\"] = BoolOp as Handler;\n\n","import { PassNode } from \"../../../ast/types\";\n\nexport default function Pass(node: PassNode) {\n    return;\n}","import { FunctionDefNode } from \"@RBrython/rbry/ast/types\";\nimport { TypedEntry } from \"../../Walker\";\nimport { FunctionType } from \"../../types\";\n\nexport default function FunctionDef(entry: TypedEntry<FunctionDefNode>) {\n    (entry.symtab.typedSymbols ||= {})[entry.node.name] = {type: FunctionType};\n}","import { AwaitNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Await(node: AwaitNode, ctx: EmitContext) {\n    ctx.w`await ${node.value}`;\n}","export default \"from JS import Symbol\\n\\n__BUCKETS__ = Symbol(\\\"buckets\\\")\\n\\nclass dict:\\n    def __init__(self, args):\\n\\n        __JS_WRITE__(\\\"this[__BUCKETS__] = new Map()\\\")\\n\\n        # destructured arg not implemented in for\\n        # __eq__ influence not implemented...\\n        for i in range(len(args)):\\n            __JS_WRITE__(\\\"this[__BUCKETS__]\\\").set(args[i][0], args[i][1])\";","import { ArgsDefNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\n//TODO: vararg + kw => dans le corps...\nexport default function Arguments(node: ArgsDefNode, ctx: EmitContext) {\n    \n    ctx.w`(`;\n\n    // if method => ignore first parameter...\n    let pos_offset = 0;\n    let arg_offset = 0;\n\n    const isMethod = ctx.isMethod();\n\n    if( isMethod ) {\n        if( node.posonlyargs.length)\n            ++pos_offset\n        else\n            ++arg_offset;\n    }\n\n    let d_idx = node.posonlyargs.length + node.args.length - node.defaults.length;\n\n    for(let i = pos_offset; i < node.posonlyargs.length; ++i) {\n        ctx.w`${node.posonlyargs[i].arg}`;\n        if( d_idx >= i)\n            ctx.w` = ${node.defaults[i - d_idx]}`;\n        ctx.w`,`;\n    }\n\n    d_idx -= node.posonlyargs.length;\n    for(let i = arg_offset; i < node.args.length; ++i) {\n        ctx.w`_${node.args[i].arg}`;\n        if( i >= d_idx)\n            ctx.w` = ${node.defaults[node.posonlyargs.length + i - d_idx]}`;\n        ctx.w`,`;\n    }\n\n    const hasVararg = node.vararg !== undefined\n\n    if( hasVararg )\n        ctx.w`...${node.vararg!.arg}`;\n\n    const hasKW = (node.args.length - arg_offset)\n                || node.kwarg !== undefined\n                || node.kwonlyargs.length;\n\n    if( hasKW && ! hasVararg)\n        writeKW(node, ctx, arg_offset);\n\n    // we also include the start of the function/lambda...\n\n    ctx.w`){`;\n\n    if( hasKW && hasVararg ) {\n        ctx.w`${ctx.hm.BB()}var `;\n        writeKW(node, ctx, arg_offset);\n        ctx.w`;${ctx.hm.BE()}`;\n    }\n\n    if( hasVararg ) {\n        ctx.w`${ctx.hm.BB()}${node.vararg!.arg} = $RB.ro(${node.vararg!.arg});${ctx.hm.BE()}`;\n    }\n\n    //TODO: prefer var renaming...\n    if( isMethod ) {\n        let selfname = \"\";\n        if( node.posonlyargs.length > 0)\n            selfname = node.posonlyargs[0].arg;\n        else\n            selfname = node.args[0].arg;\n        ctx.w`${ctx.hm.BB()}const ${selfname} = this;${ctx.hm.BE()}`;\n    }\n}\n\nfunction writeKW(node: ArgsDefNode, ctx: EmitContext, arg_offset: number) {\n\n    // kw...\n    ctx.w`{`;\n    \n    // pos\n    for( let i = arg_offset ; i < node.args.length; ++i)\n        ctx.w`${node.args[i].arg} = _${node.args[i].arg}, `;\n\n    // kw\n    for(let i = 0; i < node.kwonlyargs.length; ++i) {\n        ctx.w`${node.kwonlyargs[i].arg}`;\n        if( node.kw_defaults[i] !== undefined)\n            ctx.w` = ${node.kw_defaults[i]}`\n        ctx.w`, `\n    }\n\n    // **\n    if( node.kwarg !== undefined )\n        ctx.w`...${node.kwarg.arg}`;\n\n    ctx.w`} = $RB.getKW()`;\n}","export default \"from types import NotImplementedType\\nfrom RBM import __JS_AS_NUMBER__, __JS_OP__, __JS_SHADOW__, bigint\\n\\n@__JS_SHADOW__(\\\"bigint\\\")\\nclass int(bigint):\\n\\n    def __new__(cls, o: object, base: int, /) -> int:\\n        if type(o) == str:\\n            return __JS_RUN__( # type: ignore\\n                '''\\n                    (x, base) => {\\n                        if( base !== 16)\\n                            return BigInt(x);\\n                        \\n                        let result = 0n;\\n                        for(let i = 2; i < x.length; ++i)\\n                            result = result << 4n + BigInt( parseInt(this.slice(i, i+8), 16) );\\n                        return result;\\n                    }\\n                ''', o, base) # type: ignore\\n        return type(o).__int__(o) # type: ignore\\n    \\n    def __str__(self):\\n        return __JS_WRITE__(\\\"`${this}`\\\")\\n    \\n    def __eq__(self, o: object, /) -> bool:\\n        return __JS_OP__(self, \\\"==\\\", o)\\n    \\n    def __ge__(self, o: object, /) -> bool:\\n        return __JS_OP__(self, \\\">=\\\", o)\\n\\n\\n    def __add__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"+\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __radd__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(o, \\\"+\\\", self)\\n            case _      : return NotImplemented\\n    \\n\\n    def __sub__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"-\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __rsub__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(o, \\\"-\\\", self)\\n            case _      : return NotImplemented\\n    \\n    def __mul__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"*\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __rmul__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(o, \\\"*\\\", self)\\n            case _      : return NotImplemented\\n\\n    def __pow__(self, o: object, mod: int|None = None, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"**\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __rpow__(self, o: object, mod: int|None = None, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(o, \\\"**\\\", self)\\n            case _      : return NotImplemented\\n\\n    def __truediv__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(self),\\n                                           \\\"/\\\",\\n                                           __JS_AS_NUMBER__(o))\\n            case _      : return NotImplemented\\n    \\n    def __rtruediv__(self, o: object, /) -> NotImplementedType|float:\\n        match o:\\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o),\\n                                           \\\"*\\\",\\n                                           __JS_AS_NUMBER__(self) )\\n            case _      : return NotImplemented\\n\\n    def __mod__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"%\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __rmod__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"%\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __or__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"|\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __ror__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"|\\\", o)\\n            case _      : return NotImplemented\\n\\n    def __and__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"&\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __rand__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"&\\\", o)\\n            case _      : return NotImplemented\\n        \\n    def __xor__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"^\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __rxor__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"^\\\", o)\\n            case _      : return NotImplemented\\n\\n    def __lshift__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  ():\\n                __JS_LOG__(\\\"INT\\\")\\n                return __JS_OP__(self, \\\"<<\\\", o)\\n            case _      :\\n                __JS_LOG__(\\\"OTHER\\\", o)\\n                return NotImplemented\\n    \\n    def __rlshift__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\"<<\\\", o)\\n            case _      : return NotImplemented\\n\\n    def __rshift__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\">>\\\", o)\\n            case _      : return NotImplemented\\n    \\n    def __rrshift__(self, o: object, /) -> NotImplementedType|int:\\n        match o:\\n            case int  (): return __JS_OP__(self, \\\">>\\\", o)\\n            case _      : return NotImplemented\\n    \\n    ### unary operators ###\\n    def __invert__(self, /) -> int:\\n        return __JS_OP__(\\\"~\\\", self)\\n\\n    def __neg__(self, /) -> int:\\n        return __JS_OP__(\\\"-\\\", self)\\n    \\n    def __abs__(self, /) -> int:\\n         return __JS_RUN__(\\\"x => x < 0n ? -x : x\\\", self) # type: ignore\";","import { RaiseNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Raise(node: RaiseNode, ctx: EmitContext) {\n    ctx.w`throw ${node.exc};`;\n}","import { nodeType } from \"../../../ast\";\nimport { AttributeNode, CallNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Call(node: CallNode, ctx: EmitContext) {\n    const f        = node.func;\n\n    // @ts-ignore\n    const fid: string = f.id;\n\n    if( fid in ctx.macros) {\n        ctx.macros[fid](ctx, ...node.args);\n        return;\n    }\n\n    if( nodeType(f) === \"Attribute\") {\n        const m = f as AttributeNode;\n        ctx.w`$RB.mcall(${m.value}, \"${m.attr}\", `;\n    } else {\n        ctx.w`$RB.call(${f}, `;\n    }\n\n    writeArgs(node, ctx);\n\n    ctx.w_str(\")\");\n}\n\nexport function writeArgs(node: CallNode, ctx: EmitContext) {\n\n    const args     = node.args;\n    const keywords = node.keywords;\n\n    //TODO: args parsing...\n    for(let i = 0; i < args.length; ++i)\n        ctx.w`${args[i]}, `;\n\n    if( keywords.length ) {\n        ctx.w`$RB.setKW({`;\n            for( let i = 0; i < keywords.length; ++i)\n                ctx.w`${keywords[i].arg}: ${keywords[i].value},`;\n        ctx.w`})`;\n    }\n}","import { ASTNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"@RBrython/rbry/emitter/EmitContext\";\nimport { HMacro } from \"../..\";\nimport { nodeType } from \"@RBrython/rbry/ast\";\n\nexport function isSimple(node: ASTNode) {\n\n    const type = nodeType(node);\n\n    return type === \"Constant\" || type === \"Name\";\n}\n\nexport default function saveTmp(fallback: HMacro, node: ASTNode) {\n\n    if( isSimple(node) )\n        return (ctx: EmitContext) => ctx.w_node(node);\n\n    return fallback(node);\n}","import { IfNode } from \"../../../ast/types\";\nimport { nodeType } from \"../../../ast/\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function If(node: IfNode, ctx: EmitContext) {\n\n    ctx.w`if( ${ctx.hm.bool(node.test)} ){${node.body}}`;\n\n    for(let i = 0; i < node.orelse.length; ++i) {\n        const snode = node.orelse[i];\n        const type = nodeType(snode);\n\n        if( type === \"If\")\n            ctx.w`else ${snode}`;  // if node (else is prefix)\n        else\n            ctx.w`else{${snode}}`; // a body I guess ?\n    }\n}","import { nodeType } from \"@RBrython/rbry/ast\";\nimport { ASTNode, BodyNode, FunctionDefNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nfunction hasYield(body: BodyNode) {\n\n    const stack: ASTNode[] = [...body];\n\n    let elem;\n    while( elem = stack.pop() ) {\n\n        if( nodeType(elem) === \"Expr\" )\n            // @ts-ignore\n            elem = elem.value;\n\n        if( nodeType(elem) === \"Yield\" || nodeType(elem) === \"YieldFrom\" )\n            return true;\n\n        // can only be in a body.\n        if( \"body\" in elem)\n            // @ts-ignore\n            stack.push(...elem.body);\n    }\n\n    return false;\n}\n\nexport default function FunctionDef(node: FunctionDefNode, ctx: EmitContext) {\n\n    const isMethod = ctx.isMethod();\n\n    const name = node.name;\n    const body = node.body;\n\n    const genSym = hasYield(body) ? \"*\" : \"\";\n\n    if( isMethod ) {\n        ctx.w`${ctx.getName(-1)}.prototype.${name} = `;\n        if( name === \"__iter__\")\n            ctx.w`${ctx.getName(-1)}.prototype[Symbol.iterator] = `;\n    }\n\n    // open decorator\n    for( let i = 0; i < node.decorator_list.length ; ++i )\n        ctx.w`${node.decorator_list[i]}(`;\n\n    ctx.w`function ${genSym}${name} ${node.args}`;\n\n    // start of the function/lambda is included in the arguments...\n\n    ctx.w_body(body);\n    ctx.w`}`;\n\n    // close decorator\n    for( let i = 0; i < node.decorator_list.length ; ++i )\n        ctx.w`)`;\n}","import { nodeType } from \"@RBrython/rbry/ast\";\nimport { AssignNode, AttributeNode, SubscriptNode } from \"../../../ast/types\";\nimport { EmitContext, LOCAL_VAR } from \"../../EmitContext\";\n\nexport default function Assign(node: AssignNode, ctx: EmitContext) {\n\n    const type = nodeType(node.targets[0]);\n    if( type === \"Attribute\" ) {\n        const attr = node.targets[0] as AttributeNode;\n        ctx.w`$RB.setattr(${attr.value}, \"${attr.attr}\", ${node.value})`;\n        return;\n    }\n    if( type === \"Subscript\") {\n        const snode = node.targets[0] as SubscriptNode;\n        ctx.w`$RB.setitem(${snode.value}, ${snode.slice}, ${node.value})`;\n        return;\n    }\n\n    for(let i = 1; i < node.targets.length; ++i)\n        // @ts-ignore\n        if( ctx.getScope(node.targets[i].id) & LOCAL_VAR || ctx.isTopLevel() )\n            ctx.w`var ${node.targets[i]};`;\n\n    // @ts-ignore\n    if( ctx.getScope(node.targets[0].id) & LOCAL_VAR || ctx.isTopLevel() )\n        ctx.w`var `;\n\n    for(let i = 0; i < node.targets.length; ++i)\n        ctx.w`${node.targets[i]} = `;\n\n    return ctx.w_node(node.value);\n}","import { ASTNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../EmitContext\";\n\nexport default function bool(node: ASTNode) {\n    return function(ctx: EmitContext) {\n        ctx.w`bool(${node})`;\n    }\n}","import { ConstantNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Constant(node: ConstantNode, ctx: EmitContext) {\n\n        const type = typeof node.value;\n\n        if( type === \"object\") {\n            // @ts-ignore\n            const qname = node.value.__class__.__qualname__\n            // @ts-ignore\n            const value: float|bigint = node.value.value;\n\n            if( qname === \"float\"   ) return ctx.w`${value}`;\n            if( qname === \"int\"     ) return ctx.w`${value}n`;\n            if( qname === \"NoneType\") return ctx.w`null`;\n            //if( qname === \"ellipsis\") return \"$RB.ellipsis\";\n        }\n        if( type === \"string\" ) return ctx.w`\"${node.value}\"`;\n        if( type === \"number\" ) return ctx.w`${node.value}n`; // bigint\n        if( type === \"boolean\") return ctx.w`${node.value}`;\n\n        console.warn(node, type);\n        throw new Error(`Unknown Cste ${type}`);\n}","export default \"def repr(o: object):\\n    return type(o).__repr__(o)\";","import Runner, { PyModule } from \"./interface\";\n\nexport default class RBrythonGlobalRunner extends Runner {\n\n    override run(jscode: string) {\n        return this.runFunction( this.loadAsFunction(jscode) );\n    }\n    override runSync(jscode: string) {\n        return this.runSyncFunction( this.loadAsSyncFunction(jscode) );\n    }\n\n    override loadAsFunction(jscode: string): () => Promise<PyModule> {\n        $B.imported[\"_\"] = {};\n        return eval(jscode) as () => Promise<PyModule>;\n    }\n    override runFunction( fct: (runlib: any) => Promise<PyModule> ) {\n        // @ts-ignore\n        return fct();\n    }\n\n    override loadAsSyncFunction(jscode: string): () => PyModule {\n        $B.imported[\"_\"] = {};\n\n        return eval(jscode) as () => PyModule;\n    }\n    override runSyncFunction( fct: (runlib: any) => PyModule ) {\n        // @ts-ignore\n        return fct();\n    }\n\n    override registerBuiltins(symbols: PyModule): void {\n        for(let name in symbols)\n            this.registerBuiltin(name, symbols[name]);\n    }\n    override registerBuiltin(name: string, value: any): void {\n        $B.builtins[name] = $B.jsobj2pyobj(value);\n    }\n    override registerModule(name: string, symbols: PyModule): void {\n        $B.imported[name] = $B.jsobj2pyobj( symbols );\n    }\n    override getModule(name: string): PyModule {\n        return $B.imported[name];\n    }\n}","export default function globalExport(name: string, exported: string[]) {\n    return `  globalThis.${name} = {${exported.join(\", \")}};\\n`;\n}","import { YieldNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function YieldFrom(node: YieldNode, ctx: EmitContext) {\n    ctx.w`yield * ${node.value}`;\n}","const SafeOpti = [\n    require(\"./bool.ts\").default,\n    require(\"./tmp.ts\" ).default,\n    require(\"./getTmp.ts\").default,\n    require(\"./saveTmp.ts\").default,\n    require(\"./withTmp.ts\").default\n];\n\nexport default SafeOpti;","import { LambdaDefNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Lambda(node: LambdaDefNode, ctx: EmitContext){\n    ctx.w`function ${node.args} return ${node.body}}`; // shouldn't have many lines...\n}","import { ListCompNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function ListComp(node: ListCompNode, ctx: EmitContext) {\n\n    ctx.w`(function(){${ctx.hm.BB()}`;\n\n    ctx.w`const _r_ = [];${ctx.hm.NL()}`\n\n    for(let i = 0; i < node.generators.length; ++i) {\n        const gen = node.generators[i];\n        ctx.w`for(let ${gen.target} of ${gen.iter}){${ctx.hm.BB()}`;\n\n        for(let j = 0; j < gen.ifs.length; ++j) {\n            ctx.w`if(${gen.ifs[j]}){${ctx.hm.BB()}`;\n        }\n    }\n\n    ctx.w`_r_.push(${node.elt})`;\n\n    for(let i = 0; i < node.generators.length; ++i) {\n        ctx.w`${ctx.hm.BE()}}`;\n\n        for(let j = 0; j < node.generators[i].ifs.length; ++j) {\n            ctx.w`${ctx.hm.BE()}}`;\n        }\n    }\n\n    ctx.w`${ctx.hm.NL()}return _r_;`;\n\n    ctx.w`${ctx.hm.BE()}})()`\n}","import { ASTNode } from \"../ast/types\";\nimport { EmitContext } from \"../emitter/EmitContext\";\n\nexport default function __JS_AWAIT__(ctx: EmitContext, node: ASTNode) {\n    ctx.w`await ${node}`;\n}\n\n","import { ASTNode } from \"../ast/types\";\nimport { EmitContext } from \"../emitter/EmitContext\";\n\nexport default function __JS_AS_STRING__(ctx: EmitContext, node: ASTNode) {\n    ctx.w`\\`\\${${node}}\\``;\n}","import { ASTNode } from \"../ast/types\";\nimport { EmitContext } from \"../emitter/EmitContext\";\n\nexport default function __JS_SHADOW__(ctx: EmitContext, jstype: ASTNode) {\n    ctx.w`$RB.shadowJS(${jstype})`;\n}","import { getChildren, nodeType } from \"../ast\";\nimport { ASTNode, ParsedCode, SymTab } from \"../ast/types\";\nimport handlers from \"./handlers\";\nimport { TypeDesc } from \"./types\";\n\nexport type TypedASTNode<T extends ASTNode = ASTNode> = T & {result_type: TypeDesc}\nexport type TypedSymTab     = SymTab & {typedSymbols: Record<string, TypeDesc>}\n\nexport type Entry<T extends ASTNode = ASTNode> = {\n    node  : T,\n    symtab: SymTab\n}\nexport type TypedEntry<T extends ASTNode = ASTNode> = Entry<TypedASTNode<T>>\n                                                    & {symtab: TypedSymTab};\n\nexport function walk(parsed: ParsedCode) {\n\n    const pending = new Array<Entry>();\n\n    for(let i = 0; i < parsed.ast.body.length; ++i)\n        pending.push({\n            symtab: parsed.symtable,\n            node  : parsed.ast.body[i]\n        })\n\n    const toProcess = new Array<TypedEntry>();\n    \n    let elem: Entry|undefined;\n    while( elem = pending.pop() ) {\n\n        toProcess.push(elem as any);\n\n        for( let node of getChildren(elem.node) )\n            pending.push({\n                node,\n                symtab: elem.symtab\n            });\n        \n        // @ts-ignore\n        if( elem.node.body) {\n\n            let symtab = elem.symtab;\n            const type = nodeType(elem.node);\n\n            if( type === \"FunctionDef\" || type === \"ClassDef\")\n                // @ts-ignore\n                symtab = symtab.children.find(e => e.name === elem.node.name)!;\n\n            // @ts-ignore\n            for(let i = 0; i < elem.node.body.length ; ++i ) {\n                pending.push({\n                    // @ts-ignore\n                    node  : elem.node.body[i],\n                    symtab\n                });\n            }\n        }\n    }\n\n    let entry: TypedEntry|undefined;\n    while( entry = toProcess.pop() ) {\n\n        const handler = handlers[nodeType(entry.node) as keyof typeof handlers];\n        if( handler === undefined) {\n            //\n            continue;\n        }\n        \n        handler(entry);\n    }\n}\n","export type TypeDesc = {\n    // meta\n    const?: boolean\n    type  : object\n}\n\nexport const FunctionType = {};\nexport const BoolType = {};\n\nexport function isInstance(v: TypeDesc, t: object) {\n    return v !== undefined && v.type === t;\n}","import { UnaryOpNode } from \"@RBrython/rbry/ast/types\";\nimport { TypedEntry } from \"../../Walker\";\nimport { getOp } from \"@RBrython/rbry/ast\";\nimport { BoolType } from \"../../types\";\n\nexport default function UnaryOp(entry: TypedEntry<UnaryOpNode>) {\n\n    if( getOp(entry.node.op) === \"Not\")\n        entry.node.result_type = { type: BoolType }\n}","const SafeOpti = [\n    require(\"./Call.ts\").default\n];\n\nexport default SafeOpti;","import { TryNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Try(node: TryNode, ctx: EmitContext) {\n\n    ctx.w`try{${node.body}}`;\n\n    if( node.handlers.length > 0) {\n        ctx.w`catch(_e_){${ctx.hm.BB()}`\n\n        for(let i = 0; i < node.handlers.length; ++i) {\n\n            // TODO: as cond.\n            const except = node.handlers[i];\n\n            if( i !== 0)\n                ctx.w`else `;\n            if( except.type !== undefined)\n                ctx.w`if( isinstance(_e_, ${except.type}) )`;\n\n            ctx.w`{`;\n\n                if( except.name !== undefined)\n                    ctx.w`${ctx.hm.BB()}var ${except.name} = _e_;${ctx.hm.BE()}`\n                ctx.w_body(except.body);\n            \n            ctx.w`}`;\n\n\n        }\n    \n        ctx.w`${ctx.hm.BE()}}`;\n    }\n\n    if( node.finalbody.length > 0)\n        ctx.w`finally{${node.finalbody}}`;\n}","// quick h4ck (should move it).\nimport \"../runlib\";\nimport \"./handlers/list\"; // ensure Handlers are loaded.\n\nimport { ParsedCode } from \"../ast/types\";\nimport SourceMap from \"./SourceMap\";\nimport { EmitContext, Macro } from \"./EmitContext\";\nimport globalExport from \"./exports/global\";\nimport returnExport from \"./exports/return\";\nimport moduleExport from \"./exports/module\";\nimport brythonExport from \"./exports/brython\";\nimport RawTarget from \"./targets/raw\";\nimport { walk } from \"../checker/Walker\";\nimport Optimizers, { Optimizer } from \"../optimizers\";\n\nexport type Target = {\n    defaults : Partial<EmitterOptions>\n    transform: (jscode: string, sync: boolean) => string;\n}\n\nexport type JSCode = {\n    name    : string,\n    jscode  : string,\n    imported: string[],\n    exported: string[],\n}\n\nexport const enum MODE {\n  DEBUG,\n  TEST,\n  PROD,\n}\n\nexport const enum EXPORT {\n    NONE    = 0,\n    GLOBAL  = 1<<0,\n    MODULE  = 1<<1,\n    RETURN  = 1<<2,\n    BRYTHON = 1<<3,\n}\n\nexport type EmitterOptions = {\n    mode   : MODE,\n    target : Target,\n    opti   : Optimizer,\n    exports: EXPORT,\n    sync   : boolean\n}\n\nconst EmitterDefaults: EmitterOptions = {\n    mode   : MODE.DEBUG,\n    target : RawTarget,\n    opti   : Optimizers.safe,\n    exports: EXPORT.NONE,\n    sync   : false\n}\n\nexport abstract class Emitter {\n    abstract emit(parsed: ParsedCode, opts?: Partial<EmitterOptions>): string;\n\n    abstract registerMacros(macros: Record<string, Macro>):void;\n    abstract registerMacro(name: string, fct: Macro): void;\n}\n\nexport default class RBrythonEmitter extends Emitter {\n\n    protected readonly macros: Record<string, Macro> = {};\n\n    registerMacros(macros: Record<string, Macro>) {\n        for(let name in macros)\n            this.macros[name] = macros[name];\n    }\n    registerMacro(name: string, fct: Macro) {\n        this.macros[name] = fct;\n    }\n\n    emit(parsed: ParsedCode, options: Partial<EmitterOptions> = {}) {\n\n        const name = \"_\";\n\n        const opts: EmitterOptions = Object.assign({}, \n                                        EmitterDefaults,\n                                        options.target?.defaults,\n                                        options);\n\n        if( opts.opti.require_typechecker )\n            walk(parsed); //TODO\n        \n        const ctx = new EmitContext(opts,\n                                    this.macros,\n                                    parsed.symtable);\n\n        const exported = this.extractExportedSymbols(parsed);\n        ctx.w_body(parsed.ast.body);\n\n        let jscode = ctx.jscode;\n\n        if( opts.exports & EXPORT.GLOBAL)\n            jscode += globalExport(name, exported);\n        if( opts.exports & EXPORT.MODULE)\n            jscode += moduleExport(name, exported);\n        if( opts.exports & EXPORT.RETURN)\n            jscode += returnExport(name, exported);\n        if( opts.exports & EXPORT.BRYTHON) {\n            jscode += brythonExport(name, exported);\n        }\n\n        const output = {\n            name,\n            imported: [],\n            exported,\n            jscode,\n        }\n\n        return opts.target.transform(jscode, opts.sync!)\n    }\n\n    private extractExportedSymbols(parsed: ParsedCode) {\n        \n        const symbols = parsed.symtable.symbols.$strings\n        return Object.keys(symbols)\n                     .filter( k => symbols[k] === 4098); // magic value\n    }\n}\n\n/*\nTODO: filter...\nconst sm = new SourceMap(\"a\", \"b\", \"c\");\nsm.addMapping({line: 3, col: 4}, {line: 3, col: 5});\nsm.addMapping({line: 3, col: 5}, {line: 3, col: 5});\n\nconsole.warn(sm.toFile());\n*/","import { ASTNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Continue(node: ASTNode, ctx: EmitContext) {\n    ctx.w_str(\"continue;\");\n}","import { WhileNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function While(node: WhileNode, ctx: EmitContext) {\n    ctx.w`while( ${ctx.hm.bool(node.test)} ){${node.body}}`;\n}","import { ASTNode } from \"../ast/types\";\nimport { EmitContext } from \"../emitter/EmitContext\";\n\nexport default function __JS_AS_NUMBER__(ctx: EmitContext, node: ASTNode) {\n    ctx.w`Number(${node})`;\n}","export const FUNCTION = 0;\nexport const CLASS    = 1;\nexport const BODY     = 1;\n\nexport type SymTab = {\n    name    : string;\n    children: SymTab[];\n    symbols : {\n        $strings: Record<string, number>\n    }\n    type: typeof FUNCTION|typeof CLASS|typeof BODY;\n};\n\nexport type ParsedCode = {\n    filename: string,\n    pycode  : string,\n    ast     : ModuleNode,\n    symtable: SymTab,\n};\n\nexport type ASTNode<T={}> = {\n    js_start?: number,\n    js_end  ?: number\n} & T;\n\nexport type BodyNode = ASTNode[];\n\nexport type ModuleNode = ASTNode<{\n    body: BodyNode\n}>;\n\nexport type ExprNode = ASTNode<{\n    value: ASTNode\n}>\n\nexport type ConstantNode = ASTNode<{\n    value: number|string|boolean|{value: number|bigint}\n}>\nexport type StringNode = ASTNode<{\n    value: string;\n}>\n\nexport type AssertNode = ASTNode<{\n    test : ASTNode\n    msg ?: string\n}>\n\nexport type OperatorNode = unknown; // better to shadow it...\n\nexport type UnaryOpNode = ASTNode<{\n    operand: ASTNode;\n    op     : OperatorNode; \n}>\n\nexport type BinaryOpNode = ASTNode<{\n    left : ASTNode;\n    right: ASTNode;\n    op   : OperatorNode;\n}>\nexport type BoolOpNode = ASTNode<{\n    op: OperatorNode;\n    values: [ASTNode, ASTNode]\n}>\n\nexport type CompareNode = ASTNode<{\n    left       : ASTNode;\n    ops        : OperatorNode[];\n    comparators: ASTNode[];\n}>\n\nexport type NameNode = ASTNode<{\n    id: string;\n}>\n\nexport type AssignNode = ASTNode<{\n    value  : ASTNode;\n    targets: ASTNode[];\n}>\n\nexport type AugAssignNode = ASTNode<{\n    target : ASTNode;\n    value  : ASTNode;\n    op     : OperatorNode;\n}>\n\n\nexport type ReturnNode = ASTNode<{\n    value  : ASTNode;\n}>\n\nexport type PassNode = ASTNode<{}>\n\nexport type AttributeNode = ASTNode<{\n    value: ASTNode;\n    attr : string;\n}>\n\nexport type CallNode = ASTNode<{\n    func    : ASTNode\n    args    : ASTNode[],\n    keywords: {arg: string, value: ASTNode}[]\n}>\n\ntype Generator = {\n    iter  : ASTNode,\n    target: ASTNode,\n    ifs   : ASTNode[]\n};\n\nexport type GeneratorExpNode = ASTNode<{\n    elt: ASTNode,\n    generators: Generator[]\n}>\n\nexport type ListCompNode = GeneratorExpNode;\n\nexport type DictCompNode = ASTNode<{\n    key  : ASTNode,\n    value: ASTNode,\n    generators: Generator[]\n}>;\n\nexport type TupleNode = ASTNode<{\n    elts: ASTNode[]\n}>\n\nexport type ListNode = TupleNode;\n\nexport type DictNode = ASTNode<{\n    keys  : ASTNode[],\n    values: ASTNode[]\n}>\n\n\nexport type ClassDefNode = ASTNode<{\n    name: string;\n    body: BodyNode;\n    bases: ASTNode[];\n    decorator_list: ASTNode[];\n}>\n\nexport type ArgsDefNode = ASTNode<{\n    posonlyargs: ArgDefNode[];\n    args       : ArgDefNode[];\n    vararg    ?: ArgDefNode;\n    kwonlyargs : ArgDefNode[];\n    kwarg     ?: ArgDefNode;\n\n    defaults   : ASTNode[];\n    kw_defaults: ASTNode[];\n}>\n\nexport type ArgDefNode = ASTNode<{\n    arg: string\n}>\n\nexport type LambdaDefNode = ASTNode<{\n    args: ArgsDefNode;\n    body: BodyNode;\n}>\n\nexport type FunctionDefNode = ASTNode<{\n    name: string;\n    posonlyargs: ASTNode[];\n    args: ArgsDefNode;\n    body: BodyNode;\n    decorator_list: ASTNode[]\n}>\n\nexport type IfNode = ASTNode<{\n    test: ASTNode;\n    body: BodyNode;\n    orelse: ASTNode[];\n}>\n\n\nexport type IfExpNode = ASTNode<{\n    test  : ASTNode;\n    body  : ASTNode;\n    orelse: ASTNode;\n}>\n\nexport type WhileNode = ASTNode<{\n    test: ASTNode;\n    body: BodyNode;\n    //TODO: orelse\n}>\n\nexport type ForNode = ASTNode<{\n    target: ASTNode;\n    iter  : ASTNode;\n    body  : BodyNode;\n    //TODO: orelse\n}>\n\nexport type YieldNode = ASTNode<{\n    value : ASTNode\n}>\n\nexport type NamedExprNode = ASTNode<{\n    target: ASTNode,\n    value : ASTNode\n}>\n\nexport type RaiseNode = ASTNode<{\n    exc: ASTNode;\n}>\n\nexport type TryNode = ASTNode<{\n    body: BodyNode;\n    finalbody: BodyNode;\n    handlers: {body: BodyNode, type?: ASTNode, name?:string}[];\n}>\n\nexport type DeleteNode = ASTNode<{\n    targets: ASTNode[];\n}>\n\nexport type WithNode = ASTNode<{\n    body: BodyNode,\n    items: {\n        context_expr  : ASTNode,\n        optional_vars?: ASTNode,\n    }[]\n}>\n\nexport type FormattedValueNode = ASTNode<{\n    value: ASTNode,\n    format_spec?: {\n        values: StringNode[]\n    }\n}>;\n\nexport type JoinedStrNode = ASTNode<{\n    values: (FormattedValueNode|StringNode)[]\n}>\n\nexport type MatchNode = ASTNode<{\n    subject: ASTNode,\n    cases  : {\n        pattern: {\n            cls: {\n                id: string\n            }\n        }\n        body: BodyNode\n    }[]\n}>\n\nexport type ImportNode = ASTNode<{\n    names: {name: string, asname?: string}[]\n}>\n\nexport type ImportFromNode = ASTNode<{\n    module: string\n    names: {name: string, asname?: string}[]\n}>\n\nexport type SubscriptNode = ASTNode<{\n    value: ASTNode,\n    slice: ASTNode\n}>\n\nexport type AwaitNode = ASTNode<{\n    value: ASTNode\n}>","import \"@RBrython/rbry/runlib\";\n\nimport Runner, { PyModule } from \"./interface\";\nimport { $RB } from \"@RBrython/rbry/runlib\";\n\nexport const modules: Record<string, any> = {};\n\nexport default class RBrythonGlobalRunner extends Runner {\n\n    #module   = modules; // h4ck\n    #builtins: Record<string, any> = {};\n\n    override async run(jscode: string) {\n        return await this.runFunction( this.loadAsFunction(jscode) );\n    }\n    override runSync(jscode: string) {\n        return this.runSyncFunction( this.loadAsSyncFunction(jscode) );\n    }\n\n    override loadAsFunction(jscode: string): (runlib: any) => Promise<PyModule> {\n        return eval(jscode) as (runlib: any) => Promise<PyModule>;\n    }\n    override async runFunction( fct: (runlib: any) => Promise<PyModule> ) {\n        return await fct($RB);\n    }\n\n    override loadAsSyncFunction(jscode: string): (runlib: any) => PyModule {\n        return eval(jscode) as (runlib: any) => PyModule;\n    }\n    override runSyncFunction( fct: (runlib: any) => PyModule ) {\n        return fct($RB);\n    }\n\n    // modules\n    override registerModule(name: string, symbols: PyModule): void {\n        this.#module[name] = symbols;\n    }\n    override getModule(name: string): PyModule {\n        return this.#module[name];\n    } \n\n    // builtins\n    override registerBuiltins(symbols: PyModule): void {\n        for(let name in symbols)\n            this.registerBuiltin(name, symbols[name]);\n    }\n    override registerBuiltin(name: string, value: any): void {\n        this.#builtins[name] = value;\n\n        // @ts-ignore\n        globalThis[name] = value;\n    }\n}","import { ParsedCode } from \"../ast/types\";\nimport { EmitterOptions } from \"../emitter\";\nimport { Macro } from \"../emitter/EmitContext\";\nimport { PyModule } from \"../runners/interface\";\n\nexport default abstract class Engine {\n    abstract run(pycode: string, opts?: Omit<EmitterOptions, \"target\">): Promise<PyModule>\n    abstract runSync(pycode: string, opts?: Omit<EmitterOptions, \"target\">): PyModule;\n\n    abstract registerModule(name: string, symbols: string|PyModule): Promise<void>;\n    abstract registerModuleSync(name: string, symbols: string|PyModule): void;\n    abstract      getModule(name: string): PyModule;\n\n    abstract registerBuiltins(symbols: string|PyModule): void;\n    abstract registerBuiltin(name: string, value: any): void;\n    \n    abstract registerMacros(macros: Record<string, Macro>):void;\n    abstract registerMacro(name: string, fct: Macro): void;\n\n    // low level\n    abstract parse(pycode: string): ParsedCode;\n    abstract emit (parsed: ParsedCode, opts?: Partial<EmitterOptions>): string;\n    \n    abstract loadAsFunction(jscode: string): (runlib: any) => Promise<PyModule>;\n    abstract runFunction(fct: (runlib: any) => Promise<PyModule>): Promise<PyModule>;\n\n    abstract loadAsSyncFunction(jscode: string): (runlib: any) => PyModule;\n    abstract runSyncFunction(fct: (runlib: any) => PyModule): PyModule;\n}","import { nodeType } from \"@RBrython/rbry/ast\";\nimport { CallNode } from \"@RBrython/rbry/ast/types\";\nimport { FunctionType, isInstance } from \"@RBrython/rbry/checker/types\";\nimport { EmitContext } from \"@RBrython/rbry/emitter/EmitContext\";\nimport { Handler     } from \"@RBrython/rbry/emitter/handlers\";\nimport { writeArgs   } from \"@RBrython/rbry/emitter/handlers/operators/Call\";\n\nexport default function Call(node    : CallNode,\n                             ctx     : EmitContext,\n                             fallback: Handler) {\n\n    //TODO: better assert type...\n    if( nodeType(node.func) === \"Name\"\n        // @ts-ignore\n        && ctx.symtab.typedSymbols !== undefined) {\n        // @ts-ignore\n        const name: string = node.func.id;\n\n        // @ts-ignore\n        const type = ctx.symtab.typedSymbols[name];\n        if( isInstance(type, FunctionType) ) {\n            ctx.w`${name}(`;\n            writeArgs(node, ctx);\n            ctx.w`)`;\n\n            return;\n        }\n    }\n\n    fallback(node, ctx);\n}","export default function Global() {\n    ;\n}","export const SHADOW_JS: Record<string, any> = {}\n\nexport default function shadowJS(value: string, ro: boolean = false) {\n    const prefix = ro ? \"RO\" : \"\"\n    return (cls: any) => (SHADOW_JS[prefix + value] = cls);\n}","import { SHADOW_JS } from \"../interface/shadowJS\";\n\nexport function getClass(o: unknown) {\n\n    const typename = typeof o;\n\n    if( typename === \"function\" ) {\n        //TODO: is class ? is something else ?\n        // @ts-ignore\n        return type;\n    }\n\n    if( typename === \"object\" ) {\n\n        // @ts-ignore\n        const klassname = o.constructor.name;\n\n        if( klassname in SHADOW_JS)\n            return SHADOW_JS[klassname];\n\n        if( Object.isFrozen(o) && `RO${klassname}` in SHADOW_JS)\n            return SHADOW_JS[`RO${klassname}`];\n\n        // @ts-ignore;\n        if( o.constructor === Error )\n            // @ts-ignore\n            return Exception;\n\n        // @ts-ignore;\n        return o.constructor;\n    }\n\n    // @ts-ignore\n    //TODO: remove globalThis[]\n    const lit_class = SHADOW_JS[typename];\n    if( lit_class !== undefined)\n        return lit_class;\n\n    throw new Error(`JS type ${typename} not implemented yet`);\n}","import { getClass } from \"../helpers/getClass\";\n\n// @ts-ignore\nconst NotImplemented = globalThis.NotImplemented = Symbol();\n\nexport default function op(a: unknown, op: string, b: unknown) {\n\n    const ka = getClass(a);\n    if( ka === undefined ) {\n        console.warn(a, op);\n        throw new Error(\"?\")\n    }\n\n    let result = NotImplemented;\n\n    let fct = ka.prototype[`__${op}__`];\n    if( fct !== undefined )\n        result = fct.call(a, b);\n\n    if( result !== NotImplemented)\n        return result;\n    \n    // iop\n    if( op[0] === \"i\" ) {\n\n        op = op.slice(1);\n        fct = ka.prototype[`__${op}__`];\n        \n        if( fct !== undefined)\n            result = fct.call(a, b)\n\n        if( result !== NotImplemented)\n            return result;\n    }\n\n    // try to reverse\n    const kb = getClass(b);\n    if( kb === undefined ) {\n        console.warn(b, \"r\" + op);\n        throw new Error(\"?\");\n    }\n\n    let rop;\n    if( op.length == 2 && op !== \"or\" ) // cmp\n        rop = cmp_reversed[op as keyof typeof cmp_reversed];\n    else\n        rop = `r${op}`;\n    \n    fct = kb.prototype[`__${rop}__`];\n    if( fct !== undefined )\n        result = fct.call(b, a);\n\n    if( result !== NotImplemented)\n        return result;\n\n    // fallbacks\n    if( op === \"eq\" ) return a === b;\n    if( op === \"ne\" ) return a !== b;\n    \n    throw new Error(`Operation not implemented ${ka.name} ${op} ${kb.name}`);\n}\n\nconst cmp_reversed = {\n    \"lt\": \"gt\",\n    \"gt\": \"lt\",\n    \"le\": \"ge\",\n    \"ge\": \"le\",\n    \"ne\": \"ne\",\n    \"eq\": \"eq\"\n}","export let KW: Record<string, any>|null = null;\n\nexport const IGNORE_ARG = Symbol();\n\nexport function setKW(args: Record<string, any>) {\n    KW = args;\n    return IGNORE_ARG;\n}\n\nexport function getKW() {\n    if( KW === null )\n        return {};\n    const args = KW;\n    KW = null;\n    return args;\n}","let _tmp: any = null;\n\nexport function saveTmp(v: any): any {\n    return _tmp = v;\n}\n\nexport function tmp(): any { // may reuse many time ?\n    return _tmp;\n}\n\nexport function getTmp(): any {\n    const tmp = _tmp;\n    _tmp = null\n    return tmp;\n}\n\nexport function withTmp(value: any): any {\n    _tmp = null;\n    return value;\n}\n\n/*\nexport function saveTmp(v: any): any {\n    return tmp = v;\n}\nexport function releaseTmp(v: any) {\n    tmp = null;\n    return v;\n}*/\n\n","// interface\nimport op     from \"./interface/op\";\nimport uop    from \"./interface/uop\";\nimport call   from \"./interface/call\";\nimport mcall  from \"./interface/mcall\";\nimport assert from \"./interface/assert\";\nimport getModule from \"./interface/getModule\";\nimport getModuleSync from \"./interface/getModuleSync\";\nimport { getTmp, saveTmp, tmp, withTmp } from \"./interface/tmp\";\nimport { getKW, setKW } from \"./interface/KW\";\nimport { getClass } from \"./helpers/getClass\";\nimport _in from \"./interface/in\";\nimport getitem from \"./interface/getitem\";\nimport setitem from \"./interface/setitem\";\nimport delitem from \"./interface/delitem\";\nimport getattr from \"./interface/getattr\";\nimport delattr from \"./interface/delattr\";\nimport setattr from \"./interface/setattr\";\nimport shadowJS from \"./interface/shadowJS\";\nimport ro from \"./interface/ro\";\n\n// @ts-ignore\nconst $RB = globalThis.$RB = {\n    // interface\n    op,\n    uop,\n    call,\n    mcall,\n    assert,\n    getitem,\n    setitem,\n    delitem,\n    getattr,\n    setattr,\n    delattr,\n    getKW,\n    setKW,\n    tmp,\n    getTmp,\n    saveTmp,\n    withTmp,\n    getModule,\n    getModuleSync,\n    getClass,\n    in: _in,\n    shadowJS,\n    ro\n}\nexport {$RB};\n\n// =====================================================\n\n//TODO: as macro...\nexport const IVALUE = Symbol();\n\n// @ts-ignore\nglobalThis.__JS_SET_IVALUE__ = (self, v) => self[IVALUE] = v;\n// @ts-ignore\nglobalThis.__JS_GET_IVALUE__ = (self) => self[IVALUE];","import { getClass } from \"../helpers/getClass\";\n\nexport default function uop(op:string, a: unknown) {\n\n    const ka = getClass(a);\n\n    if( ka === undefined ) {\n        console.warn(a, op);\n        throw new Error(\"?\")\n    }\n\n    let fct = ka.prototype[`__${op}__`];\n    if( fct === undefined) {\n        console.warn(a, ka);\n        throw new Error(`__${op}__ not defined`);\n    }\n    return fct.call(a);\n}","import { getClass } from \"../helpers/getClass\";\nimport isClass from \"../helpers/isClass\";\nimport { IGNORE_ARG } from \"./KW\";\n\nexport default function call(a: (...args:unknown[]) => unknown, ...args: unknown[]) {\n\n    if( args[args.length-1] === IGNORE_ARG)\n        args = args.slice(0,-1);\n\n    // @ts-ignore\n    let fct = a.__call__\n\n    if( fct === undefined ) {\n        fct = a;\n\n        // h4cky\n        if( fct.prototype?.__new__ !== undefined ) {\n            const b = getClass(fct).prototype.__call__;\n            if( b !== undefined) {\n                return b.call(fct, ...args);\n            }\n        }\n\n        if( isClass(fct) ) // only for JS classes now...\n            return new fct(...args);\n    }\n\n    return fct(...args);\n}\n","export default function isClass(o: unknown) {\n\n    if( o === Symbol)\n        return false;\n    \n    // from https://stackoverflow.com/questions/526559/testing-if-something-is-a-class-in-javascript\n    return Object.getOwnPropertyDescriptors(o)?.prototype?.writable === false;\n\n}\n// + https://github.com/brython-dev/brython/issues/2513","import { IGNORE_ARG } from \"./KW\";\n\nexport default function mcall(o: unknown, name: string, ...args: unknown[]) {\n    \n    if( args[args.length-1] === IGNORE_ARG)\n        args = args.slice(0,-1);\n    \n    // @ts-ignore\n    let fct = o[name];\n    if( fct === undefined) {\n        // @ts-ignore\n        if( o.prototype[name] === undefined) {\n            // @ts-ignore\n            console.warn(o, o.name, name);\n        }\n        // @ts-ignore\n        return o.prototype[name].call(...args);\n    }\n\n    // @ts-ignore\n    return o[name](...args);\n}","export default function assert(cond: boolean, msg: string = \"\") {\n    if( ! cond )\n        throw new Error(`Assertion failed: ${msg}`);\n}","import { getClass } from \"../helpers/getClass\";\n\nexport default function getitem(o: any, key: any) {\n    return getClass(o).prototype.__getitem__.call(o, key);\n}","import { getClass } from \"../helpers/getClass\";\n\nexport default function getitem(o: any, key: any, v: any) {\n    return getClass(o).prototype.__setitem__.call(o, key, v);\n}","import { getClass } from \"../helpers/getClass\";\n\nexport default function delitem(o: any, key: any) {\n    return getClass(o).prototype.__delitem__.call(o, key);\n}","import { getClass } from \"../helpers/getClass\";\n\nexport default function getattr(o: any, key: any) {\n    /*\n    if( ! (attr in o) )\n        return o.constructor[attr];\n    return o[attr];\n    */\n    return getClass(o).prototype.__getattr__.call(o, key);\n}","import { getClass } from \"../helpers/getClass\";\n\nexport default function setattr(o: any, key: any, v: any) {\n    return getClass(o).prototype.__setattr__.call(o, key, v);\n}","import { getClass } from \"../helpers/getClass\";\n\nexport default function delattr(o: any, key: any) {\n    return getClass(o).prototype.__delattr__.call(o, key);\n}","import { modules } from \"@RBrython/rbry/runners/RBrythonGlobalRunner\";\n\nexport default async function getModule(name: string) {\n\n    // h4ck\n    const module = modules[name];\n    if( module !== undefined )\n        return module;\n\n    if( name in globalThis)\n        return modules[name] = globalThis[name as keyof typeof globalThis];\n\n    // TODO...\n    if( \"__BRYTHON__\" in globalThis) {\n        // @ts-ignore\n        if( name in __BRYTHON__.imported)\n            // @ts-ignore\n            return modules[name] = __BRYTHON__.pyobj2jsob(__BRYTHON__.imported[name]);\n    }\n    \n    throw new Error(`module ${name} not found`);\n}\n    ","import { modules } from \"@RBrython/rbry/runners/RBrythonGlobalRunner\";\n\nexport default function getModuleSync(name: string) {\n\n    // h4ck\n    const module = modules[name];\n    if( module !== undefined )\n        return module;\n\n    if( name in globalThis)\n        return modules[name] = globalThis[name as keyof typeof globalThis];\n\n    // TODO...\n    if( \"__BRYTHON__\" in globalThis) {\n        // @ts-ignore\n        if( name in __BRYTHON__.imported)\n            // @ts-ignore\n            return modules[name] = __BRYTHON__.pyobj2jsob(__BRYTHON__.imported[name]);\n    }\n    \n    throw new Error(`module ${name} not found`);\n}\n    ","import { getClass } from \"../helpers/getClass\";\n\nexport default function _in(e: any, c: any) {\n\n    const kc = getClass(c);\n    if( kc === undefined ) {\n        console.warn(c);\n        throw new Error(\"?\")\n    }\n\n    let fct = kc.prototype[\"__contains__\"];\n    if( fct !== undefined )\n        return fct.call(c, e);\n\n    fct = kc.prototype[Symbol.iterator] //kc.prototype[\"__iter__\"];\n    if( fct !== undefined ) {\n        for( let elem of fct.call(c) )\n            // @ts-ignore\n            if( $RB.op(elem, \"eq\", e) )\n                return true;\n        return false;\n    }\n\n    throw new Error(\"Not implemented\");\n    //TODO: getitem...\n\n}","export default function ro(o: any) {\n    return Object.freeze(o);\n}","import { ImportNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Import(node: ImportNode, ctx: EmitContext) {\n\n    for(let i = 0; i < node.names.length; ++i) {\n        \n        const module = node.names[i];\n\n        const moduleName = module.name;\n\n        if( moduleName === \"RBM\" )\n            continue; // RBrython macros...\n\n        let asname = module.asname;\n        if( asname === undefined)\n            asname = moduleName;\n\n        const importfct = ctx.isTopLevel() && ! ctx.sync\n                            ? \"await $RB.getModule\"\n                            : \"$RB.getModuleSync\"\n        \n        ctx.w`const ${asname} = ${importfct}(\"${moduleName}\")`;\n    }\n}","import { EmitContext } from \"@RBrython/rbry/emitter/EmitContext\";\nimport { HMacro } from \"../..\";\nimport { ASTNode } from \"@RBrython/rbry/ast/types\";\nimport { isSimple } from \"./saveTmp\";\n\nexport default function tmp(fallback: HMacro, node: ASTNode) {\n\n    if( isSimple(node) )\n        return (ctx: EmitContext) => ctx.w_node(node);\n\n    return fallback(node);\n}","import { ASTNode } from \"../../../ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Break(node: ASTNode, ctx: EmitContext) {\n    ctx.w_str(\"break;\");\n}","import { YieldNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Yield(node: YieldNode, ctx: EmitContext) {\n    ctx.w`yield ${node.value}`;\n}","import { ASTNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"@RBrython/rbry/emitter/EmitContext\";\nimport { HMacro } from \"../..\";\nimport { isSimple } from \"./saveTmp\";\n\nexport default function withTmp(fallback: HMacro, node: ASTNode) {\n\n    if( isSimple(node) )\n        return (_: EmitContext) => {};\n\n    return fallback(node);\n}","import { CompareNode } from \"@RBrython/rbry/ast/types\";\nimport { TypedEntry } from \"../../Walker\";\nimport { BoolType } from \"../../types\";\n\nexport default function Compare(entry: TypedEntry<CompareNode>) {\n    entry.node.result_type = { type: BoolType }\n}","export default function moduleExport(_: string, exported: string[]) {\n    return `  export {${exported.join(\", \")}};\\n`;\n}","import { MatchNode } from \"@RBrython/rbry/ast/types\";\nimport { EmitContext } from \"../../EmitContext\";\n\nexport default function Match(node: MatchNode, ctx: EmitContext) {\n\n    ctx.w`{${ctx.hm.BB()}`; // we want a special scope for the match.\n\n    //TODO: indent...\n\n    ctx.w`const _s_ = ${node.subject};${ctx.hm.NL()}`\n\n    for(let i = 0; i < node.cases.length -1; ++i) {\n        if( i !== 0)\n            ctx.w`else `;\n\n        const c = node.cases[i];\n\n        ctx.w`if( isinstance(_s_, ${c.pattern.cls.id}) ){${c.body}}`;\n    }\n    ctx.w`else {${node.cases[node.cases.length-1].body}}`;\n    ctx.w`${ctx.hm.BE()}}`;\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { EXPORT } from \"..\";\n\nexport default {\n    defaults: {\n        exports: EXPORT.BRYTHON,\n        sync   : true\n    },\n    transform: (e: string) => e\n}","import { EXPORT } from \"..\";\n\nexport default {\n    defaults: {\n        exports: EXPORT.MODULE\n    },\n    transform: (e: string) => e\n}","import { default as BrythonTarget } from \"./brython\";\nimport { default as FunctionTarget } from \"./function\";\nimport { default as ModuleTarget } from \"./module\";\nimport { default as RawTarget } from \"./raw\";\n\nconst Targets = {\n    raw     : RawTarget,\n    function: FunctionTarget,\n    module  : ModuleTarget,\n    brython : BrythonTarget\n}\n\nexport default Targets;","import Engines from \"@RBrython/rbry/engines/\";\n\nexport {default as Targets} from \"@RBrython/rbry/emitter/targets\";\nexport {default as Optimizers} from \"@RBrython/rbry/optimizers/index\";\nexport {EXPORT} from \"@RBrython/rbry/emitter/index\";\n\nexport default Engines;"],"names":["BE","ctx","indent_level","w_line","__JS_OP__","args","length","op","value","w","BrythonEmitter","Emitter","emit","parsed","$B","js_from_root","ast","symtable","filename","src","pycode","imported","js","registerMacros","macros","Error","registerMacro","name","fct","Engines","getBrythonEngine","emitter","runner","BrythonGlobalRunner","engine","BaseEngine","parse","registerModule","globalThis","BrythonEngineFactory","getRBrythonEngine","RBrythonEngineFactory","NL","require","BB","bool","tmp","getTmp","saveTmp","withTmp","JoinedStr","node","w_str","i","values","nodeType","val","undefined","format_spec","a","operand","getOp","hm","opname","uops","Invert","USub","UAdd","Nonlocal","attr","hacked","ClassDef","body","decorator_list","w_node","bases","includes","id","slice","w_body","Expr","For","target","iter","Tuple","elts","__JS_RUN__","code","str","replaceAll","fallback","isInstance","result_type","BoolType","isASTNode","o","constructor","$name","getChildren","elem","Object","filter","e","returnExport","_","exported","join","ListComp","console","warn","generators","gen","j","ifs","key","LOCAL_VAR","EmitContext","mode","sync","handlers","jscode","opti","hmacros","symtab","this","getScope","symbols","$strings","getName","idx","isTopLevel","isMethod","last","type","FUNCTION","CLASS","strings","exprs","Array","isArray","nl","repeat","endsWith","nodes","handler","hasNewContext","enter","js_start","js_end","leave","children","find","l","push","pop","If","test","orelse","isSimple","Return","Runner","BoolOp","b","cond","saved","guard","NamedExpr","GeneratorExp","elt","safeHandlers","patch","patchedHandlers","patchHandlers","SafeOpti_handlers","safeHmacros","patchedHMacros","patchHMacros","SafeOpti_hmacros","disabled","require_typechecker","safe","unsafe","Constant","entry","__JS_LOG__","Compare","prev","left","ops","isFirst","isLast","comparators","cmpops","Eq","NotEq","Gt","GtE","Lt","LtE","In","Name","MODE","DEBUG","right","binops","Add","Sub","Mult","Div","FloorDiv","Pow","Mod","BitOr","BitAnd","BitXor","LShift","RShift","AugAssign","__JS_WRITE__","AsyncFunctionDef","__JS_AS_BIGINT__","defaults","exports","EXPORT","RETURN","transform","brythonExport","Engine","parser","super","run","opts","FunctionTarget","runSync","registerModuleSync","getModule","registerBuiltins","registerBuiltin","loadAsFunction","runFunction","loadAsSyncFunction","runSyncFunction","builtins","object","int","float","tuple","list","dict","format","repr","print","abs","len","range","next","Exception","isinstance","RBrythonEmitter","RBrythonGlobalRunner","__JS_AWAIT__","__JS_AS_STRING__","__JS_AS_NUMBER__","__JS_SHADOW__","builtin","With","items","context_expr","r","optional_vars","Subscript","Parser","_PyPegen","run_parser","future","future_features","_PySymtable_Build","List","keys","Assert","PROD","msg","ImportFrom","module","names","as","asname","importfct","Delete","targets","snode","Handlers","FunctionDef","Lambda","Arguments","Global","Pass","Assign","Attribute","BinOp","Call","UnaryOp","While","Try","Match","Continue","Break","Raise","Import","typedSymbols","FunctionType","Await","pos_offset","arg_offset","posonlyargs","d_idx","arg","hasVararg","vararg","hasKW","kwarg","kwonlyargs","writeKW","selfname","kw_defaults","exc","f","func","fid","m","writeArgs","keywords","genSym","stack","hasYield","qname","__class__","__qualname__","eval","jsobj2pyobj","globalExport","YieldFrom","jstype","walk","pending","toProcess","v","t","except","finalbody","EmitterDefaults","RawTarget","Optimizers","options","assign","extractExportedSymbols","moduleExport","k","modules","$RB","SHADOW_JS","getClass","typename","klassname","isFrozen","lit_class","NotImplemented","Symbol","cmp_reversed","KW","IGNORE_ARG","_tmp","ka","result","prototype","call","kb","rop","uop","__call__","__new__","getOwnPropertyDescriptors","writable","mcall","assert","getitem","__getitem__","setitem","__setitem__","delitem","__delitem__","getattr","__getattr__","setattr","__setattr__","delattr","__delattr__","getKW","setKW","async","__BRYTHON__","pyobj2jsob","getModuleSync","in","c","kc","iterator","shadowJS","ro","prefix","cls","freeze","IVALUE","__JS_SET_IVALUE__","self","__JS_GET_IVALUE__","moduleName","Yield","subject","cases","pattern","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","defineProperty","enumerable","get","obj","prop","hasOwnProperty","BRYTHON","MODULE","Targets","raw","function","ModuleTarget","brython"],"sourceRoot":""}