export const __webpack_id__=228;export const __webpack_ids__=[228];export const __webpack_modules__={55:(e,t,n)=>{n.a(e,(async(e,t)=>{try{var o=n(523),r=e([o]);o=(r.then?(await r)():r)[0],t()}catch(e){t(e)}}))},80:(e,t,n)=>{n.d(t,{A:()=>o});const o='from types     import NotImplementedType\nfrom RBM import __JS_OP__, string\n\nclass str(string):\n    def __new__(cls, o: object, /) -> str:\n        return __JS_AS_STRING__(o) # type: ignore\n        #return type(o).__str__(o) # type: ignore\n    \n    def __eq__(self, o: object, /) -> bool:\n        return __JS_OP__(self, "==", o)\n\n    def __mul__(self, o: object, /) -> NotImplementedType|str:\n        match o:\n            case int  (): return __JS_WRITE__("self.repeat(Number(b))") # type: ignore\n            case _      : return NotImplemented\n    \n    def __rmul__(self, o: object, /) -> NotImplementedType|str:\n        match o:\n            case int  (): return __JS_WRITE__("self.repeat(Number(b))") # type: ignore\n            case _      : return NotImplemented'},238:(e,t,n)=>{n.d(t,{A:()=>o});const o="assert 3 * 3.75 / 1.5 == 7.5\nassert 7.0 / 2 == 3.5"},389:(e,t,n)=>{n.d(t,{A:()=>o});const o='from RBM import __JS_OP__, boolean\n\nclass bool(boolean): # type: ignore (bool is Final)\n    def __eq__(self, o: object, /) -> bool:\n        return __JS_OP__(self, "==", o)'},398:(e,t,n)=>{n.d(t,{A:()=>o});const o='def test(o: object, /):\n    match o:\n        case bool (): return "bool"\n        case int  (): return "int"\n        case float(): return "float"\n        case _      : return "unknown"\n\nassert test(1)    == "int"\nassert test(1.)   == "float"\nassert test(True) == "bool"'},414:()=>{},417:(e,t,n)=>{n.p},523:(e,t,n)=>{n.a(e,(async(e,t)=>{try{var o=n(805),r=n(761),s=n(955),_=n(594);const l=3,a=["basic test suite","numbers","classes"],i=new URLSearchParams(location.search),c=i.get("test"),u="true"===i.get("merge"),f=(i.get("parser"),i.get("compat")??"NONE");function p(){const e=new o.A;e.addEngine("Brython",r.A).addEngine("RBrython",r.O),e.addStep("parse",((e,t)=>{t.ast=e.parse(t.pycode)})).addStep("emit",((e,t)=>{t.jscode=e.emit(t.ast)})).addStep("load",((e,t)=>{t.fct=e.loadAsFunction(t.jscode)}));for(let t=0;t<l;++t)e.addStep(`execute${t}`,((e,t)=>{t.fct()}));e.addStat("nbTokens",(e=>$B.tokenizer(e.pycode,"_").length)),e.addStat("nbFiles",(e=>1)),e.addStat("asserts_count",(e=>{const n=t/l;return t=0,n})),e.addStat("asserts_fail",(e=>{const t=n/l;return n=0,t}));let t=0,n=0;return $RB.assert=function(e){++t,e||++n},e.resetStats(),e}function m(e,t,n){e.textContent=(0,s.A)(t,n),e.classList.add("success"),t.errors.length>0&&(console.warn(t.errors),e.classList.add("error"),e.textContent+="\n"+t.errors.map((e=>{let t=e.message;return""===t&&(t=e.args[0]),t})).join("\n"))}function d(e){T.classList.remove("error","success"),T.textContent="",J.classList.remove("error","success"),J.textContent="",P.resetStats();for(let t=0;t<e.length;++t)P.bench({pycode:e[t]});const t=P.getStats();1===e.length&&(w.textContent=t.Brython.ctx.pycode,v.textContent=t.Brython.ctx.jscode,O.textContent=t.RBrython.ctx.jscode),m(J,t.Brython,t.RBrython),m(T,t.RBrython,t.Brython)}function h(e,t){let n=[e];"brython"===e&&(n=a);let o="";const r=new Array;let s=-1;const _=["NONE"];for(let e=0;e<n.length;++e){const l=I[n[e]];$[n[e]];for(let e=0;e<l.length;++e){++s;for(const n of _){globalThis.__SBRY_COMPAT__=n;let _=l[e];""!==_&&(_=B(_),t?o+=`def _${s}():\n${_.split("\n").map((e=>`    ${e}`)).join("\n")+"pass"}\n_${s}()\n`:r.push(_))}}}return t?[o]:r}async function g(){const e=await(await fetch("/assets/exclude_list.txt")).text();return Object.fromEntries(e.split("#").slice(0).map((e=>{let t=e.split("\n"),n=t[0].slice(1),o=t.slice(1).filter((e=>"/"!==e[0]&&0!==e.length)).map((e=>{const t=e.split("-");return 1===t.length?"*"===t[0]?t[0]:parseInt(t[0]):[parseInt(t[0]),parseInt(t[1])]}));return[n,o]})))}async function y(...e){const t={};for(let n=0;n<e.length;++n)t[e[n]]=await b(e[n]);return t}async function b(e,t=N){const n=await(await fetch(`/assets/unittests/${e}.py`)).text();$[e]=[];const o=n.split("\n#");return o[0]=o[0].slice(1),o.map(((n,r)=>{let s=n.split("\n");const _=s[0].trim();s[0]="# "+e+"."+_+" ("+(r+1)+"/"+o.length+")";let l=t[`${e}.${_}`];void 0===l&&(l=t[`${e}.*`]),s=S(s,l);let a=0;for(let e=1;e<s.length;++e)""===s[e].trim()&&++a;let i=0;for(let e=1;e<s.length;++e)"#"===s[e][0]&&(""===s[e].slice(1).trim()?++a:++i);let c=s.length-1-a;return $[e].push({excluded:i,total:c}),c===i?"":s.join("\n")+"\n"}))}function S(e,t){return t??=[],e.map(((e,n)=>(n+=1,void 0!==t.find((e=>"*"===e||n===e||!!(Array.isArray(e)&&e[0]<=n&&e[1]>=n)))?`# ${e}`:e)))}window.onerror=(...e)=>{console.log(e)};const $={},N=await g(),I=await y(...a),J=document.querySelector(".brython_output"),T=document.querySelector(".sbrython_output"),w=document.querySelector("#python"),O=(document.querySelector(".python_ouput"),document.querySelector("#ast"),document.querySelector("#rbry_js")),v=document.querySelector("#bry_js");w.addEventListener("input",(()=>{const e=w.value;localStorage.setItem("sbrython_code",e),d([e])})),w.addEventListener("keydown",(e=>{if("Tab"===e.code){e.preventDefault();let t=w.selectionStart,n=w.selectionEnd;const o=w.value,r=o.slice(0,t),s=o.slice(n,o.length);w.value=r+"    "+s;const _=t+4;w.setSelectionRange(_,_)}}));const j=document.querySelector("#tests"),A=new Option("----",void 0,!0,!0);A.toggleAttribute("disabled"),j.append(A);for(let R in _.A)j.append(new Option(R,_.A[R]));function B(e){const t=e.split("\n");for(let e=1;e<t.length;++e){const n=t[e].indexOf("#");n<=0||(JSON.parse(t[e].slice(n+1).trim()).COMPAT!==f?t[e]="#"+t[e]:t[e]=t[e].slice(0,n).trimEnd())}return t.join("\n")}j.addEventListener("change",(()=>{const e=B(j.value);w.value=e,localStorage.setItem("sbrython_code",e),d([e])}));for(let x=0;x<a.length;++x){const M=I[a[x]];for(let C=0;C<M.length;++C){const U=M[C];if(""===U)continue;const F=U.slice(2,U.indexOf("\n")),q=new Option(F,U);j.append(q)}}const P=p();let E;E="rbrython"===c?Object.values(_.A):null!==c?h(c,u):[w.value=localStorage.getItem("sbrython_code")??""],d(E),t()}catch(k){t(k)}}),1)},591:(e,t,n)=>{n.d(t,{A:()=>o});const o="assert 2 + 2 == 4\nassert (50 - 5 * 6) / 4 == 5.0\nassert 8 / 5 == 1.6\n#assert 7 // 3 == 2\n#assert 7 // -3 == -3"},594:(e,t,n)=>{n.d(t,{A:()=>o});const o={"kernel/match/classes":n(398).A,"core/int/op":n(591).A,"core/float/op":n(238).A}},741:(e,t,n)=>{n.d(t,{A:()=>o});const o='from types import NotImplementedType\nfrom RBM import __JS_OP__, __JS_AS_NUMBER__, number\n\nclass float(number):\n    def __new__(cls, o: object, /) -> float:\n        if type(o) is str:\n            return __JS_AS_NUMBER__(o)\n        return type(o).__float__(o) # type: ignore\n    \n    def __eq__(self, o: object, /) -> bool:\n        return __JS_OP__(self, "==", o)    \n\n    def __add__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(self, "+", o)\n            case int  (): return __JS_OP__(self, "+", __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n\n    def __radd__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(o                  , "+", self)\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), "+", self)\n            case _      : return NotImplemented\n\n    def __sub__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(self, "-", o)\n            case int  (): return __JS_OP__(self, "-", __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n\n    def __rsub__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(o                  , "-", self)\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), "-", self)\n            case _      : return NotImplemented\n\n    def __mul__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(self, "*", o)\n            case int  (): return __JS_OP__(self, "*", __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n\n    def __rmul__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(o                  , "*", self)\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), "*", self)\n            case _      : return NotImplemented\n\n    def __div__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(self, "/", o)\n            case int  (): return __JS_OP__(self, "/", __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n\n    def __rdiv__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case float(): return __JS_OP__(o                  , "/", self)\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o), "/", self)\n            case _      : return NotImplemented\n\n    ### unary operators ###\n\n    def __neg__(self, /) -> float:\n        return __JS_OP__("-", self)\n    \n    def __int__(self, /) -> int:\n        return __JS_RUN__(\'(x) => Math.trunc(x)\', self) # type: ignore\n    \n    def __abs__(self, /) -> int:\n         return __JS_RUN__(\'(x) => Math.abs(x)\', self) # type: ignore'},761:(e,t,n)=>{function o(e,t){const n=new $B.Parser(e,t,"file"),o=$B._PyPegen.run_parser(n),r=$B.future_features(o,t);return{filename:t,pycode:e,ast:o,symtable:$B._PySymtable_Build(o,t,r)}}n.d(t,{A:()=>w,O:()=>O});class r{}class s extends r{constructor(){super(),this.initialize()}run(e){this.loadAsFunction(this.emit(this.parse(e)))()}#e=!1;initialize(){$B.imported.JS=$B.jsobj2pyobj(globalThis),this.#e=!0}parse(e){return o(e,"_")}emit(e){return $B.js_from_root({ast:e.ast,symtable:e.symtable,filename:e.filename,src:e.pycode,imported:void 0}).js}loadAsFunction(e){return $B.imported._={},Function("'use strict';"+e)}}class _{__call__(...e){const t=this.prototype.__new__,n=void 0!==t?t.call(this,...e):new this(...e),o=this.prototype.__init__;return void 0!==o&&o.call(n,...e),n}__eq__(e){return this==e}}const l={bigint:"int",number:"float",string:"str",boolean:"bool"};function a(e){const t=typeof e;if("function"===t)return _;if("object"===t)return e.constructor;const n=globalThis[l[t]];if(void 0!==n)return n;throw new Error(`JS type ${t} not implemented yet`)}const i=Symbol(),c={eq:function(e){return this==e}};let u=null;const f=Symbol();globalThis.$RB={op:function(e,t,n){const o=a(e);if(void 0===o)throw console.warn(e,t),new Error("?");let r=o.prototype[`__${t}__`];if(void 0===r){if("ne"===t)return!o.prototype.__eq__.call(e,n);"i"===t[0]&&(r=o.prototype[`__${t.slice(1)}__`]),void 0===r&&(r=c[t])}let s=r.call(e,n);if(s===i){const o=a(n);if(void 0===o)throw console.warn(n,"r"+t),new Error("?");s=o.prototype[`__r${t}__`].call(n,e)}return s},uop:function(e,t){if("not"===e)return!t;const n=a(t);if(void 0===n)throw console.warn(t,e),new Error("?");return n.prototype[`__${e}__`].call(t)},call:function(e,...t){t[t.length-1]===f&&(t=t.slice(0,-1));let n=e.__call__;if(void 0===n){if(n=e,void 0!==n.prototype?.__new__){const e=a(n).prototype.__call__;if(void 0!==e)return e.call(n,...t)}if(o=n,!1===Object.getOwnPropertyDescriptors(o)?.prototype?.writable)return new n(...t)}var o;return n(...t)},mcall:function(e,t,...n){return n[n.length-1]===f&&(n=n.slice(0,-1)),void 0===e[t]?e.prototype[t].call(...n):e[t](...n)},assert:function(e){if(!e)throw new Error("Assertion failed")},attr:function(e,t){return t in e?e[t]:e.constructor[t]},getKW:function(){if(null===u)return{};const e=u;return u=null,e},setKW:function(e){return u=e,f},getModule:function(e){if("JS"===e)return globalThis;throw new Error(`module ${e} not found`)}},globalThis.abs=function(e){return a(e).prototype.__abs__.call(e)},globalThis.type=function(e){return a(e)},globalThis.NotImplemented=i,globalThis.range=function*(e){for(let t=0;t<e;++t)yield t},globalThis.Exception=function(e){throw new Error(e)},globalThis.__JS_LOG__=(...e)=>console.log(...e);const p=Symbol();globalThis.__JS_SET_IVALUE__=(e,t)=>e[p]=t,globalThis.__JS_GET_IVALUE__=e=>e[p],globalThis.__JS_AS_NUMBER__=e=>"infinity"===e||"inf"===e?Number.POSITIVE_INFINITY:"-infinity"===e||"-inf"===e?Number.NEGATIVE_INFINITY:Number(e),globalThis.__JS_AS_STRING__=e=>`${e}`;const m={};function d(e){return e.constructor.$name}function h(e){return e.constructor.$name}function g(e){const t=m[d(e)];if(void 0===t)throw console.warn(e),new Error(`Node type ${d(e)} is unknown`);return t(e)}function y(e,t=!1){const n=globalThis.inClass;globalThis.inClass=t;let o="";for(let t=0;t<e.length;++t)o+=g(e[t])+";\n";return globalThis.inClass=n,o}globalThis.inCstrFct=!1;const b={Add:"add",Sub:"sub",Mult:"mul",Div:"div",Pow:"pow",Mod:"mod",BitOr:"or",BitAnd:"and",LShift:"lshift",RShift:"rshift"},S={},$={Eq:"eq",NotEq:"ne"},N={Invert:"invert",USub:"neg",Not:"not"};m.ClassDef=function(e){const t=e.name,n=e.body;let o=`globalThis.${t} = (() =>{\n        function ${t}() {\n            return Object.create(${t}.prototype);\n        }\n        const classname = ${t};\n    `;if((1!==e.bases.length||!["number","bigint","boolean","string"].includes(e.bases[0].id))&&e.bases.length>=1){o+=`${t}.prototype = Object.create(${g(e.bases[0])}.prototype);\n`;for(let n=1;n<e.bases.length;++n)o+=`Object.assign(${t}.prototype, ${g(e.bases[n])}.prototype);`;o+=`${t}.prototype.constructor = ${t};\n`}for(let e=0;e<n.length;++e)"FunctionDef"===d(n[e])&&(globalThis.inCstrFct=!0,o+=`${"_"===n[e].name?"":`${t}.prototype.${n[e].name} = `}${g(n[e])}\n            `,globalThis.inCstrFct=!1);return o+=`\n        return ${t};\n    })();\n    `,o},m.FunctionDef=function(e){const t=e.name,n=e.body;let o=globalThis.inClass?"":"function ",r="",s=0,_=0,l="";if(globalThis.inClass||globalThis.inCstrFct){let t="";e.args.posonlyargs.length?t=e.args.posonlyargs[0].arg:(t=e.args.args[0].arg,++_),l=`const ${t} = this;`,++s}for(;s<e.args.posonlyargs.length;++s)r+=`${e.args.posonlyargs[s].arg}, `;for(s=_;s<e.args.args.length;++s)r+=`_${e.args.args[s].arg}, `;if(e.args.args.length){r+="{";for(let t=_;t<e.args.args.length;++t)r+=`${e.args.args[t].arg} = _${e.args.args[t].arg}, `;r+="} = $RB.getKW()"}let a=`${o}${t}(${r}) {\n        ${l}\n        ${y(n)}\n    }`;if(0===e.decorator_list.length)return a;const i=e.decorator_list[0];return globalThis.inClass?`static {\n            this.prototype.${t} = ${g(i)}(function ${a});\n        }`:`${g(i)}(${a})`},m.Lambda=function(e){let t="";for(let n=0;n<e.args.posonlyargs.length;++n)t+=e.args.posonlyargs[n].arg+", ";return`(${t}) => { return ${g(e.body)}}`},m.Assert=function(e){return`$RB.assert(${g(e.test)})`},m.Pass=function(e){return""},m.Return=function(e){return`return ${g(e.value)}`},m.Assign=function(e){let t="";const n=globalThis.inClass?"static ":"var ";for(let o=1;o<e.targets.length;++o)t+=`${n}${g(e.targets[o])};`;t+=n+g(e.targets[0])+" = ";for(let n=1;n<e.targets.length;++n)t+=g(e.targets[n])+" = ";return t+g(e.value)},m.Attribute=function(e){return`$RB.attr(${g(e.value)}, "${e.attr}")`},m.AugAssign=function(e){const t=e.target,n=h(e.op),o=e.value,r=b[n];if(void 0===r)throw new Error(`BinOp ${n} not impl`);return`${g(t)} = $RB.op(${g(t)}, "i${r}", ${g(o)})`},m.BinOp=function(e){const t=e.left,n=e.right,o=h(e.op),r=b[o];if(void 0===r)throw new Error(`BinOp ${o} not impl`);return`$RB.op(${g(t)}, "${r}", ${g(n)})`},m.Call=function(e){const t=e.func,n=e.args,o=e.keywords;if(t.id in S)return S[t.id](...e.args);let r="";for(let e=0;e<n.length;++e)r+=g(n[e])+", ";if(o.length){r+="$RB.setKW({";for(let e=0;e<o.length;++e)r+=`${o[e].arg}: ${g(o[e].value)},`;r+="})"}if("Attribute"===d(t)){const e=t;return`$RB.mcall(${g(e.value)}, "${e.attr}", ${r} )`}return`$RB.call(${g(t)}, ${r})`},m.Compare=function(e){const t=e.left,n=h(e.ops[0]),o=e.comparators[0];if("Is"===n)return`${g(t)} === ${g(o)}`;const r=$[n];if(void 0===r)throw console.warn(n),new Error(`CmpOp ${n} not impl`);return`$RB.op(${g(t)}, "${r}", ${g(o)})`},m.UnaryOp=function(e){const t=e.operand,n=h(e.op),o=N[n];if(void 0===o)throw new Error(`UnaryOp ${n} not impl`);return`$RB.uop("${o}", ${g(t)})`},m.Constant=function(e){const t=typeof e.value;if("object"===t){const t=e.value.__class__.__qualname__,n=e.value.value;if("float"===t)return`${n}`;if("int"===t)return`${n}n`;if("NoneType"===t)return"null"}if("string"===t)return`"${e.value}"`;if("number"===t)return`${e.value}n`;if("boolean"===t)return`${e.value}`;throw console.warn(e,t),new Error(`Unknown Cste ${t}`)},m.Expr=function(e){return g(e.value)},m.Name=function(e){return e.id},m.JoinedStr=function(e){console.warn(e);let t="`";for(let n=0;n<e.values.length;++n){const o=e.values[n];t+="Constant"===d(o)?o.value:`\${${g(o.value)}}`}return t+="`",t},m.If=function(e){let t=`if( ${g(e.test)} ) {\n        ${y(e.body)}\n    }`;for(let n=0;n<e.orelse.length;++n){const o=e.orelse[n];t+="If"===d(o)?"else "+g(o):`else { ${g(o)} }`}return t},m.While=function(e){return`while( ${g(e.test)} ) {\n        ${y(e.body)}\n    }`},m.For=function(e){return`for(${g(e.target)} of ${g(e.iter)}){\n        ${y(e.body)}\n    }`},m.Try=function(e){return`try {\n        ${y(e.body)}\n    } catch {\n        ${y(e.handlers[0].body)}\n    }`},m.Match=function(e){let t="{";t+=`const tname = type(${g(e.subject)}).name;`;for(let n=0;n<e.cases.length-1;++n)0!==n&&(t+="else "),t+=`if( tname === "${e.cases[n].pattern.cls.id}") {\n            ${y(e.cases[n].body)}\n        }`;return t+=`else {\n            ${y(e.cases[e.cases.length-1].body)}\n    }`,t+="}",t},m.Continue=function(e){return"continue;"},m.Break=function(e){return"break;"},m.Raise=function(e){return`throw ${g(e.exc)};`},m.ImportFrom=function(e){const t=e.module;if("RBM"===t)return"";if("types"===t||"typing"===t)return"";if("functools"===t)return console.warn("Import not implemented yet"),"";let n="const {";for(let t=0;t<e.names.length;++t)n+=`${e.names[t].name},`;return n+`} = $RB.getModule("${t}")`},m.Import=function(e){const t=e.names[0].name;return"RBM"===t?"":`const ${t} = $RB.getModule("${t}")`},S.__DISPATCH__=(...e)=>{let t="((fct) => {\n\n        const registered = {";for(let n=0;n<e[0].keys.length;++n)t+=`${g(e[0].keys[n])}: ${g(e[0].values[n])},`;return t+='};\n    \n        function _(...args) {\n            let f = registered[type(args[0]).name];\n            if( f === undefined )\n                f = fct;\n            return f.call(null, this, ...args);\n        }\n\n        Object.defineProperty(_, "name", {value: fct.name});\n    \n        return _;\n    })',t},S.__JS_WRITE__=e=>e.value,S.__JS_OP__=(...e)=>2===e.length?`${e[0].value}${g(e[1])}`:`${g(e[0])} ${e[1].value} ${g(e[2])}`,S.__JS_RUN__=(...e)=>{return`(${t=e[0].value,t.replaceAll("\\n\\","\n")})(${e.slice(1).map((e=>g(e))).join(",")})`;var t};const I={int:n(970).A,float:n(741).A,bool:n(389).A,str:n(80).A};class J extends r{constructor(){super(),this.initialize()}run(e){this.loadAsFunction(this.emit(this.parse(e)))()}#e=!1;initialize(){for(let e in I)this.run(I[e]);this.#e=!0}parse(e){return o(e,"_")}emit(e){return function(e){return y(e.ast.body)}(e)}loadAsFunction(e){return Function("'use strict';"+e)}}class T{static getBrythonEngine(){return new s}static getRBrythonEngine(){return new J}}const w=T.getBrythonEngine(),O=T.getRBrythonEngine()},805:(e,t,n)=>{n.d(t,{A:()=>o});class o{steps=[];engines=[];stats=[];addStat(e,t){this.stats.push({name:e,fct:t})}addEngine(e,t){return this.engines.push({name:e,engine:t}),this}addStep(e,t){return this.steps.push({name:e,fct:t}),this}#t=null;resetStats(){this.#t={};for(let e=0;e<this.engines.length;++e){this.#t[this.engines[e].name]={steps:new Array(this.steps.length),ctx:{},errors:[],stats:{}};for(let t=0;t<this.steps.length;++t)this.#t[this.engines[e].name].steps[t]={name:this.steps[t].name,time:0};for(let t=0;t<this.stats.length;++t)this.#t[this.engines[e].name].stats[this.stats[t].name]=0}}getStats(){return this.#t}bench(e){null===this.#t&&this.resetStats();const t=this.#t;for(let n=0;n<this.engines.length;++n){const o=this.engines[n].engine,r=t[this.engines[n].name],s=r.ctx={...e};try{for(let e=0;e<this.steps.length;++e){const t=this.steps[e].fct,n=performance.now();t(o,s);const _=performance.now();r.steps[e].time+=_-n}for(let e=0;e<this.stats.length;++e)r.stats[this.stats[e].name]+=this.stats[e].fct(s)}catch(e){r.errors.push(e)}}}}},955:(e,t,n)=>{function o(e,t){return e.toFixed(3).padStart(7)+t}function r(e,t){const n=e/t;return 1===n?"   =   ":n>1?"x"+n.toFixed(2).padStart(6):"-"+(-(100*e/t-100)).toFixed(2).padStart(5)+"%"}function s(e,t){let n="";const s=e.stats.asserts_count-e.stats.asserts_fail;let _=s/e.stats.asserts_count;0===e.stats.asserts_count&&(_=1);const l=e.stats.nbTokens;n+=`Asserts: ${s}/${e.stats.asserts_count} (${100*_}%)\n`,n+=`Py code: ${l} tokens (${e.stats.nbFiles} file)\n`,n+="JS code: "+r(e.ctx.jscode?.length,t.ctx.jscode?.length)+"\n",n+="\nTimes:\n";const a=1e5/l/1e3;for(let s=0;s<e.steps.length;++s){const _=e.steps[s].name,l=e.steps[s].time,i=t.steps[s].time;n+=`- ${_.padEnd(7)}\t`+o(l*a,"s")+" ["+r(l,i)+"] "+o(l,"ms")+"\n"}return n}n.d(t,{A:()=>s})},970:(e,t,n)=>{n.d(t,{A:()=>o});const o='from types     import NotImplementedType\n\nfrom RBM import __JS_AS_NUMBER__, __JS_OP__, bigint\n\nclass int(bigint):\n\n    def __new__(cls, o: object, base: int, /) -> int:\n        if type(o) == str:\n            return __JS_RUN__( # type: ignore\n                \'\'\'\n                    (x, base) => {\n                        if( base !== 16)\n                            return BigInt(x);\n                        \n                        let result = 0n;\n                        for(let i = 2; i < x.length; ++i)\n                            result = result << 4n + BigInt( parseInt(this.slice(i, i+8), 16) );\n                        return result;\n                    }\n                \'\'\', o, base) # type: ignore\n        return type(o).__int__(o) # type: ignore\n    \n    def __eq__(self, o: object, /) -> bool:\n        return __JS_OP__(self, "==", o)\n\n\n    def __add__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "+", o)\n            case _      : return NotImplemented\n    \n    def __radd__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(o, "+", self)\n            case _      : return NotImplemented\n    \n\n    def __sub__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "-", o)\n            case _      : return NotImplemented\n    \n    def __rsub__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(o, "-", self)\n            case _      : return NotImplemented\n    \n    def __mul__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "*", o)\n            case _      : return NotImplemented\n    \n    def __rmul__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(o, "*", self)\n            case _      : return NotImplemented\n\n    def __pow__(self, o: object, mod: int|None = None, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "**", o)\n            case _      : return NotImplemented\n    \n    def __rpow__(self, o: object, mod: int|None = None, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(o, "**", self)\n            case _      : return NotImplemented\n\n    def __div__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(self),\n                                           "/",\n                                           __JS_AS_NUMBER__(o))\n            case _      : return NotImplemented\n    \n    def __rdiv__(self, o: object, /) -> NotImplementedType|float:\n        match o:\n            case int  (): return __JS_OP__(__JS_AS_NUMBER__(o),\n                                           "*",\n                                           __JS_AS_NUMBER__(self) )\n            case _      : return NotImplemented\n\n    def __mod__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "%", o)\n            case _      : return NotImplemented\n    \n    def __rmod__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "%", o)\n            case _      : return NotImplemented\n    \n    def __or__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "|", o)\n            case _      : return NotImplemented\n    \n    def __ror__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "|", o)\n            case _      : return NotImplemented\n\n    def __and__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "&", o)\n            case _      : return NotImplemented\n    \n    def __rand__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "&", o)\n            case _      : return NotImplemented\n        \n    def __xor__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "^", o)\n            case _      : return NotImplemented\n    \n    def __rxor__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "^", o)\n            case _      : return NotImplemented\n\n    def __lshift__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "<<", o)\n            case _      : return NotImplemented\n    \n    def __rlshift__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, "<<", o)\n            case _      : return NotImplemented\n\n    def __rshift__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, ">>", o)\n            case _      : return NotImplemented\n    \n    def __rrshift__(self, o: object, /) -> NotImplementedType|int:\n        match o:\n            case int  (): return __JS_OP__(self, ">>", o)\n            case _      : return NotImplemented\n    \n    ### unary operators ###\n    def __invert__(self, /) -> int:\n        return __JS_OP__("~", self)\n\n    def __neg__(self, /) -> int:\n        return __JS_OP__("-", self)\n    \n    def __abs__(self, /) -> int:\n         return __JS_RUN__("x => x < 0n ? -x : x", self) # type: ignore'}};import e from"../skeleton/index.js";var t=t=>e(e.s=t);import*as n from"./index.js";e.C(n),t(55),t(417),t(414);
//# sourceMappingURL=index.js.map